{"ast":null,"code":"/*\r\n    Modifications copyright 2018 The caver-js Authors\r\n    This file is part of web3.js.\r\n\r\n    web3.js is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    web3.js is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n    This file is derived from web3.js/packages/web3-eth-accounts/src/index.js (2019/06/12).\r\n    Modified and improved for the caver-js development.\r\n*/\n\n/**\r\n * @file accounts.js\r\n * @author Fabian Vogelsteller <fabian@ethereum.org>\r\n * @date 2017\r\n */\nconst _ = require('lodash');\n\nconst Promise = require('any-promise'); // account, hash, rlp, nat, bytes library will be used from 'eth-lib' temporarily.\n\n\nconst AccountLib = require('eth-lib/lib/account');\n\nconst Hash = require('eth-lib/lib/hash');\n\nconst RLP = require('eth-lib/lib/rlp');\n\nconst Nat = require('eth-lib/lib/nat');\n\nconst Bytes = require('eth-lib/lib/bytes');\n\nconst cryp = typeof global === 'undefined' ? require('crypto-browserify') : require('crypto');\n\nconst uuid = require('uuid');\n\nconst elliptic = require('elliptic');\n\nconst scrypt = require('scrypt-js');\n\nconst utils = require('../../../caver-utils');\n\nconst helpers = require('../../../caver-core-helpers');\n\nconst Method = require('../../../caver-core-method');\n\nconst core = require('../../../caver-core');\n\nconst {\n  encodeRLPByTxType,\n  makeRawTransaction,\n  getSenderTxHash,\n  decodeFromRawTransaction,\n  splitFeePayer,\n  extractSignatures\n} = require('./makeRawTransaction');\n\nconst secp256k1 = new elliptic.ec('secp256k1');\n\nconst AccountKeyPublic = require('./accountKey/accountKeyPublic');\n\nconst AccountKeyMultiSig = require('./accountKey/accountKeyMultiSig');\n\nconst AccountKeyRoleBased = require('./accountKey/accountKeyRoleBased');\n\nconst {\n  AccountKeyEnum\n} = require('./accountKey/accountKeyEnum');\n\nconst Account = require('./account/account');\n\nconst AccountForUpdate = require('./account/accountForUpdate');\n\nconst {\n  rpc\n} = require('../../../caver-rtm');\n\nconst isNot = function (value) {\n  return _.isUndefined(value) || _.isNull(value);\n};\n\nfunction coverInitialTxValue(tx) {\n  if (typeof tx !== 'object') throw new Error('Invalid transaction');\n\n  if (!tx.senderRawTransaction && (!tx.type || tx.type === 'LEGACY' || tx.type.includes('SMART_CONTRACT_DEPLOY'))) {\n    tx.to = tx.to || '0x';\n    tx.data = utils.addHexPrefix(tx.data || '0x');\n  }\n\n  tx.chainId = utils.numberToHex(tx.chainId);\n  return tx;\n}\n/**\r\n * resolveArgsForSignTransaction parse arguments for signTransaction.\r\n *\r\n * @method resolveArgsForSignTransaction\r\n * @param {Object} args Parameters of signTransaction.\r\n * @return {Object}\r\n */\n\n\nfunction resolveArgsForSignTransaction(args) {\n  if (args.length === 0 || args.length > 3) {\n    throw new Error('Invalid parameter: The number of parameters is invalid.');\n  } // privateKey and callback are optional parameter\n  // \"args.length === 2\" means that user sent parameter privateKey or callback\n\n\n  const tx = args[0];\n  let privateKey;\n  let callback;\n\n  if (!tx || !_.isObject(tx) && !_.isString(tx)) {\n    throw new Error('Invalid parameter: The transaction must be defined as an object or RLP encoded string');\n  }\n\n  if (args.length === 2) {\n    if (_.isFunction(args[1])) {\n      callback = args[1];\n    } else {\n      privateKey = args[1];\n    }\n  } else if (args.length === 3) {\n    if (args[1] && typeof args[1] !== 'string' && !_.isArray(args[1])) {\n      throw new Error('Invalid parameter: The parameter for the private key is invalid');\n    }\n\n    privateKey = args[1];\n    callback = args[2];\n  } // For handling when callback is undefined.\n\n\n  callback = callback || function () {};\n\n  return {\n    tx,\n    privateKey,\n    callback\n  };\n}\n/**\r\n * resolveArgsForFeePayerSignTransaction parse arguments for feePayerSignTransaction.\r\n *\r\n * @method resolveArgsForFeePayerSignTransaction\r\n * @param {Object} args Parameters of feePayerSignTransaction.\r\n * @return {Object}\r\n */\n\n\nfunction resolveArgsForFeePayerSignTransaction(args) {\n  if (args.length === 0 || args.length > 4) {\n    throw new Error('Invalid parameter: The number of parameters is invalid.');\n  } // privateKey and callback are optional parameter\n  // \"args.length === 3\" means that user sent parameter privateKey or callback\n\n\n  const tx = args[0];\n  const feePayer = args[1];\n  let privateKey;\n  let callback;\n\n  if (!tx || !_.isObject(tx) && !_.isString(tx)) {\n    throw new Error('Invalid parameter: The transaction must be defined as an object or RLP encoded string');\n  }\n\n  if (!utils.isAddress(feePayer)) {\n    throw new Error(`Invalid fee payer address : ${feePayer}`);\n  }\n\n  if (args.length === 3) {\n    if (_.isFunction(args[2])) {\n      callback = args[2];\n    } else {\n      privateKey = args[2];\n    }\n  } else if (args.length === 4) {\n    if (args[2] && typeof args[2] !== 'string' && !_.isArray(args[2])) {\n      throw new Error('Invalid parameter: The parameter for the private key is invalid');\n    }\n\n    privateKey = args[2];\n    callback = args[3];\n  } // For handling when callback is undefined.\n\n\n  callback = callback || function () {};\n\n  return {\n    tx,\n    privateKey,\n    feePayer,\n    callback\n  };\n}\n/**\r\n * resolveArgsForSignTransactionWithHash parse arguments for signTransactionWithHash.\r\n *\r\n * @method resolveArgsForSignTransactionWithHash\r\n * @param {Object} args Parameters of signTransactionWithHash.\r\n * @return {Object}\r\n */\n\n\nfunction resolveArgsForSignTransactionWithHash(args) {\n  if (args.length < 2 || args.length > 4) {\n    throw new Error('Invalid parameter: The number of parameters is invalid.');\n  }\n\n  const hash = args[0];\n  const privateKeys = args[1];\n  let chainId;\n  let callback;\n\n  if (!hash) {\n    throw new Error('Invalid parameter: The hash of transaction must be defined as a parameter.');\n  }\n\n  if (!utils.isValidHashStrict(hash)) {\n    throw new Error('Invalid parameter: The hash of transaction must be 0x-hex prefixed string format.');\n  }\n\n  if (!privateKeys || !Array.isArray(privateKeys) && !_.isString(privateKeys)) {\n    throw new Error(`Invalid parameter: The private key should be a private key string or an array of private keys.`);\n  }\n\n  if (args.length === 3) {\n    if (_.isFunction(args[2])) {\n      callback = args[2];\n    } else {\n      chainId = args[2];\n    }\n  } else if (args.length === 4) {\n    if (args[2] && !_.isString(args[2]) && !_.isNumber(args[2])) {\n      throw new Error('Invalid parameter: The parameter for the chain id is invalid.');\n    }\n\n    chainId = args[2];\n    callback = args[3];\n  } // For handling when callback is undefined.\n\n\n  callback = callback || function () {};\n\n  return {\n    hash,\n    privateKeys,\n    chainId,\n    callback\n  };\n}\n\nfunction encryptKey(privateKey, password, options) {\n  const encryptedArray = [];\n  if (!privateKey) return encryptedArray;\n  const privateKeyArray = _.isArray(privateKey) ? privateKey : [privateKey];\n\n  for (let i = 0; i < privateKeyArray.length; i++) {\n    const salt = options.salt || cryp.randomBytes(32);\n    const iv = options.iv || cryp.randomBytes(16);\n    let derivedKey;\n    const kdf = options.kdf || 'scrypt';\n    const kdfparams = {\n      dklen: options.dklen || 32,\n      salt: salt.toString('hex')\n    };\n    /**\r\n     * Supported kdf modules are the following:\r\n     * 1) pbkdf2\r\n     * 2) scrypt - default\r\n     */\n\n    if (kdf === 'pbkdf2') {\n      kdfparams.c = options.c || 262144;\n      kdfparams.prf = 'hmac-sha256';\n      derivedKey = cryp.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');\n    } else if (kdf === 'scrypt') {\n      // FIXME: support progress reporting callback\n      kdfparams.n = options.n || 4096; // 2048 4096 8192 16384\n\n      kdfparams.r = options.r || 8;\n      kdfparams.p = options.p || 1;\n      derivedKey = scrypt.syncScrypt(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n    } else {\n      throw new Error('Unsupported kdf');\n    }\n\n    const cipher = cryp.createCipheriv(options.cipher || 'aes-128-ctr', derivedKey.slice(0, 16), iv);\n\n    if (!cipher) {\n      throw new Error('Unsupported cipher');\n    }\n\n    const ciphertext = Buffer.from([...cipher.update(Buffer.from(privateKeyArray[i].replace('0x', ''), 'hex')), ...cipher.final()]);\n    const mac = utils.sha3(Buffer.from([...derivedKey.slice(16, 32), ...ciphertext])).replace('0x', '');\n    encryptedArray.push({\n      ciphertext: ciphertext.toString('hex'),\n      cipherparams: {\n        iv: iv.toString('hex')\n      },\n      cipher: options.cipher || 'aes-128-ctr',\n      kdf,\n      kdfparams,\n      mac: mac.toString('hex')\n    });\n  }\n\n  return encryptedArray;\n}\n\nconst Accounts = function Accounts() {\n  const _this = this; // sets _requestmanager\n\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  core.packageInit(this, args); // remove unecessary core functions\n\n  delete this.BatchRequest;\n  delete this.extend;\n  const _klaytnCall = [rpc.getChainId, rpc.getGasPrice, rpc.getTransactionCount, rpc.getHeader]; // attach methods to this._klaytnCall\n\n  this._klaytnCall = {};\n\n  _.each(_klaytnCall, function (method) {\n    method = new Method(method);\n    method.attachToObject(_this._klaytnCall);\n    method.setRequestManager(_this._requestManager);\n  });\n\n  this.wallet = new Wallet(this);\n};\n\nAccounts.prototype._addAccountFunctions = function (account) {\n  const _this = this; // add sign functions\n\n\n  account.signTransaction = function signTransaction(tx, callback) {\n    const roleKey = _this._getRoleKey(tx, account);\n\n    return _this.signTransaction(tx, roleKey, callback);\n  };\n\n  account.feePayerSignTransaction = function feePayerSignTransaction(tx, callback) {\n    return _this.feePayerSignTransaction(tx, account.address, account.feePayerKey, callback);\n  };\n\n  account.sign = function sign(data) {\n    return _this.sign(data, account.privateKey);\n  };\n\n  account.encrypt = function encrypt(password) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    options.address = account.address;\n    return _this.encrypt(account.keys, password, options);\n  };\n\n  account.getKlaytnWalletKey = function getKlaytnWalletKey() {\n    return genKlaytnWalletKeyStringFromAccount(account);\n  };\n\n  return account;\n};\n/**\r\n * _determineAddress determines the priority of the parameters entered and returns the address that should be used for the account.\r\n *\r\n * @method _determineAddress\r\n * @param {Object} legacyAccount Account with a legacy account key extracted from private key to be used for address determination.\r\n * @param {String} addressFromKey Address extracted from key.\r\n * @param {String} userInputAddress Address passed as parameter by user.\r\n * @return {String}\r\n */\n\n\nAccounts.prototype._determineAddress = function _determineAddress(legacyAccount, addressFromKey, userInputAddress) {\n  if (userInputAddress) {\n    if (addressFromKey && addressFromKey !== userInputAddress) {\n      throw new Error('The address extracted from the private key does not match the address received as the input value.');\n    }\n\n    if (!utils.isAddress(userInputAddress)) {\n      throw new Error('The address received as the input value is invalid.');\n    }\n\n    return userInputAddress;\n  }\n\n  if (addressFromKey) {\n    if (!utils.isAddress(addressFromKey)) {\n      throw new Error('The address extracted from the private key is invalid.');\n    } // If userInputAddress is undefined and address which is came from private is existed, set address in account.\n\n\n    return addressFromKey;\n  }\n\n  return legacyAccount.address;\n};\n/**\r\n * _getRoleKey returns a key that matches the role that should be used according to the transaction.\r\n *\r\n * @method _getRoleKey\r\n * @param {Object} tx transaction object to be sign.\r\n * @param {Object} account Account to be used for signing.\r\n * @return {String|Array}\r\n */\n\n\nAccounts.prototype._getRoleKey = function _getRoleKey(tx, account) {\n  let key;\n\n  if (!account) {\n    throw new Error('The account to be used for signing is not defined.');\n  }\n\n  if (tx.senderRawTransaction && tx.feePayer) {\n    key = account.feePayerKey;\n  } else if (tx.type && tx.type.includes('ACCOUNT_UPDATE')) {\n    key = account.updateKey;\n  } else {\n    key = account.transactionKey;\n  }\n\n  if (!key) {\n    throw new Error('The key corresponding to the role used for signing is not defined.');\n  }\n\n  return key;\n};\n/**\r\n * _suggestGasPrice suggests a gas price.\r\n * This function will be used to set gasPrice field if that is omitted.\r\n * Before common architecture does not support newly added transaction types.\r\n *\r\n * @method _suggestGasPrice\r\n * @return {string}\r\n */\n\n\nAccounts.prototype._suggestGasPrice = async function _suggestGasPrice() {\n  const gasPrice = await this._klaytnCall.getGasPrice();\n  return gasPrice;\n};\n/**\r\n * create function creates random account with entropy.\r\n *\r\n * @method create\r\n * @param {Object} entropy A random string to increase entropy.\r\n * @return {Object}\r\n */\n\n\nAccounts.prototype.create = function create(entropy) {\n  return this._addAccountFunctions(Account.fromObject(AccountLib.create(entropy || utils.randomHex(32))));\n};\n/**\r\n * createAccountKey creates AccountKeyPublic, AccountKeyMultiSig or AccountKeyRoleBased instance with parameter.\r\n *\r\n * @method createAccountKey\r\n * @param {String|Array|Object} accountKey Parameters to be used when creating the AccountKey.\r\n * @return {Object}\r\n */\n\n\nAccounts.prototype.createAccountKey = function createAccountKey(accountKey) {\n  if (Account.isAccountKey(accountKey)) accountKey = accountKey.keys;\n\n  if (_.isString(accountKey)) {\n    accountKey = this.createAccountKeyPublic(accountKey);\n  } else if (_.isArray(accountKey)) {\n    accountKey = this.createAccountKeyMultiSig(accountKey);\n  } else if (_.isObject(accountKey)) {\n    accountKey = this.createAccountKeyRoleBased(accountKey);\n  } else {\n    throw new Error(`Invalid accountKey type: ${typeof accountKey}`);\n  }\n\n  return accountKey;\n};\n/**\r\n * createAccountKeyPublic creates AccountKeyPublic with a string of private key.\r\n *\r\n * @method createAccountKeyPublic\r\n * @param {String} privateKey Private key string that will be used to create AccountKeyPublic.\r\n * @return {Object}\r\n */\n\n\nAccounts.prototype.createAccountKeyPublic = function createAccountKeyPublic(privateKey) {\n  if (privateKey instanceof AccountKeyPublic) return privateKey;\n\n  if (!_.isString(privateKey)) {\n    throw new Error('Creating a AccountKeyPublic requires a private key string.');\n  }\n\n  const parsed = utils.parsePrivateKey(privateKey);\n  privateKey = parsed.privateKey;\n\n  if (!utils.isValidPrivateKey(privateKey)) {\n    throw new Error(`Failed to create AccountKeyPublic. Invalid private key : ${privateKey}`);\n  }\n\n  return new AccountKeyPublic(privateKey);\n};\n/**\r\n * createAccountKeyMultiSig creates AccountKeyMultiSig with an array of private keys.\r\n *\r\n * @method createAccountKeyMultiSig\r\n * @param {Array} privateKeys An Array of private key strings that will be used to create AccountKeyMultiSig.\r\n * @return {Object}\r\n */\n\n\nAccounts.prototype.createAccountKeyMultiSig = function createAccountKeyMultiSig(privateKeys) {\n  if (privateKeys instanceof AccountKeyMultiSig) return privateKeys;\n\n  if (!_.isArray(privateKeys)) {\n    throw new Error('Creating a AccountKeyMultiSig requires an array of private key string.');\n  }\n\n  for (let i = 0; i < privateKeys.length; i++) {\n    const parsed = utils.parsePrivateKey(privateKeys[i]);\n    const p = parsed.privateKey;\n\n    if (!utils.isValidPrivateKey(p)) {\n      throw new Error(`Failed to create AccountKeyMultiSig. Invalid private key : ${p}`);\n    }\n  }\n\n  return new AccountKeyMultiSig(privateKeys);\n};\n/**\r\n * createAccountKeyRoleBased creates AccountKeyRoleBased with an object of key.\r\n *\r\n * @method createAccountKeyRoleBased\r\n * @param {Object} keyObject Object that defines key for each role to use when creating AccountKeyRoleBased.\r\n * @return {Object}\r\n */\n\n\nAccounts.prototype.createAccountKeyRoleBased = function createAccountKeyRoleBased(keyObject) {\n  if (keyObject instanceof AccountKeyRoleBased) return keyObject;\n\n  if (!_.isObject(keyObject) || _.isArray(keyObject)) {\n    throw new Error('Creating a AccountKeyRoleBased requires an object.');\n  }\n\n  return new AccountKeyRoleBased(keyObject);\n};\n/**\r\n * accountKeyToPublicKey creates public key format with AccountKey.\r\n *\r\n * @method accountKeyToPublicKey\r\n * @param {Object} accountKey AccountKey instance for which you want to generate a public key format.\r\n * @return {String|Array|Object}\r\n */\n\n\nAccounts.prototype.accountKeyToPublicKey = function accountKeyToPublicKey(accountKey) {\n  accountKey = this.createAccountKey(accountKey);\n  return accountKey.toPublicKey(this.privateKeyToPublicKey);\n};\n/**\r\n * createWithAccountKey creates Account instance with AccountKey.\r\n *\r\n * @method createWithAccountKey\r\n * @param {String} address The address of account.\r\n * @param {String|Array|Object} accountKey The accountKey of account.\r\n * @return {Object}\r\n */\n\n\nAccounts.prototype.createWithAccountKey = function createWithAccountKey(address, accountKey) {\n  const account = new Account(address, this.createAccountKey(accountKey));\n  return this._addAccountFunctions(account);\n};\n/**\r\n * createWithAccountKeyPublic create an account with AccountKeyPublic.\r\n *\r\n * @method createWithAccountKeyPublic\r\n * @param {String} address An address of account.\r\n * @param {String|Object} key Key of account.\r\n * @return {Object}\r\n */\n\n\nAccounts.prototype.createWithAccountKeyPublic = function createWithAccountKeyPublic(address, key) {\n  if (!Account.isAccountKey(key)) key = this.createAccountKeyPublic(key);\n\n  if (key.type !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) {\n    throw new Error(`Failed to create account with AccountKeyPublic. Invalid account key : ${key.type}`);\n  }\n\n  const account = new Account(address, key);\n  return this._addAccountFunctions(account);\n};\n/**\r\n * createWithAccountKeyMultiSig create an account with AccountKeyMultiSig.\r\n *\r\n * @method createWithAccountKeyMultiSig\r\n * @param {String} address An address of account.\r\n * @param {String|Object} keys Key of account.\r\n * @return {Object}\r\n */\n\n\nAccounts.prototype.createWithAccountKeyMultiSig = function createWithAccountKeyMultiSig(address, keys) {\n  if (!Account.isAccountKey(keys)) keys = this.createAccountKeyMultiSig(keys);\n\n  if (keys.type !== AccountKeyEnum.ACCOUNT_KEY_MULTISIG) {\n    throw new Error(`Failed to create account with AccountKeyMultiSig. Invalid account key : ${keys.type}`);\n  }\n\n  const account = new Account(address, keys);\n  return this._addAccountFunctions(account);\n};\n/**\r\n * createWithAccountKeyRoleBased create an account with AccountKeyRoleBased.\r\n *\r\n * @method createWithAccountKeyRoleBased\r\n * @param {String} address An address of account.\r\n * @param {String|Object} keyObject Key of account.\r\n * @return {Object}\r\n */\n\n\nAccounts.prototype.createWithAccountKeyRoleBased = function createWithAccountKeyRoleBased(address, keyObject) {\n  if (!Account.isAccountKey(keyObject)) {\n    keyObject = this.createAccountKeyRoleBased(keyObject);\n  }\n\n  if (keyObject.type !== AccountKeyEnum.ACCOUNT_KEY_ROLEBASED) {\n    throw new Error(`Failed to create account with AccountKeyRoleBased. Invalid account key : ${keyObject.type}`);\n  }\n\n  const account = new Account(address, keyObject);\n  return this._addAccountFunctions(account);\n};\n/**\r\n * privateKeyToAccount creates and returns an Account through the input passed as parameters.\r\n *\r\n * @method privateKeyToAccount\r\n * @param {String} key The key parameter can be either normal private key or KlaytnWalletKey format.\r\n * @param {String} userInputAddress The address entered by the user for use in creating an account.\r\n * @return {Object}\r\n */\n\n\nAccounts.prototype.privateKeyToAccount = function privateKeyToAccount(key, userInputAddress) {\n  const {\n    legacyAccount: account,\n    klaytnWalletKeyAddress\n  } = this.getLegacyAccount(key);\n  account.address = this._determineAddress(account, klaytnWalletKeyAddress, userInputAddress);\n  account.address = account.address.toLowerCase();\n  account.address = utils.addHexPrefix(account.address);\n  return account;\n};\n/**\r\n * createAccountForUpdate creates an AccountForUpdate instance.\r\n * The AccountForUpdate returned as a result of this function contains only the address and public key used to update the account.\r\n *\r\n * @method createAccountForUpdate\r\n * @param {String} address The address value of AccountForUpdate, a structure that contains data for updating an account.\r\n * @param {String|Array|Object} accountKey Private key or AccountKey to update account.\r\n * @param {Object} options Options to use for setting threshold and weight for multiSig.\r\n * @return {Object}\r\n */\n\n\nAccounts.prototype.createAccountForUpdate = function createAccountForUpdate(address, accountKey, options) {\n  let legacyOrFail; // Logic for handling cases where legacyKey or failKey is set inside AccountKeyRoleBased object.\n\n  if (!_.isArray(accountKey) && _.isObject(accountKey)) {\n    legacyOrFail = {};\n    Object.keys(accountKey).map(role => {\n      if (accountKey[role] === 'legacyKey' || accountKey[role] === 'failKey') {\n        legacyOrFail[role] = accountKey[role];\n        delete accountKey[role];\n      }\n    });\n\n    if (Object.keys(accountKey).length === 0) {\n      return new AccountForUpdate(address, legacyOrFail, options);\n    }\n  }\n\n  const publicKey = this.accountKeyToPublicKey(accountKey);\n\n  if (legacyOrFail !== undefined) {\n    Object.assign(publicKey, legacyOrFail);\n  }\n\n  return new AccountForUpdate(address, publicKey, options);\n};\n/**\r\n * createAccountForUpdateWithPublicKey creates AccountForUpdate instance with public key format.\r\n *\r\n * @method createAccountForUpdateWithPublicKey\r\n * @param {String} address The address value of AccountForUpdate, a structure that contains data for updating an account.\r\n * @param {String|Array|Object} keyForUpdate Public key to update.\r\n * @param {Object} options Options to use for setting threshold and weight for multiSig.\r\n * @return {Object}\r\n */\n\n\nAccounts.prototype.createAccountForUpdateWithPublicKey = function createAccountForUpdateWithPublicKey(address, keyForUpdate, options) {\n  return new AccountForUpdate(address, keyForUpdate, options);\n};\n/**\r\n * createAccountForUpdateWithLegacyKey creates AccountForUpdate instance with legacyKey.\r\n *\r\n * @method createAccountForUpdateWithLegacyKey\r\n * @param {String} address The address of account to update with the legacy key.\r\n * @return {Object}\r\n */\n\n\nAccounts.prototype.createAccountForUpdateWithLegacyKey = function createAccountForUpdateWithLegacyKey(address) {\n  return new AccountForUpdate(address, 'legacyKey');\n};\n/**\r\n * createAccountForUpdateWithFailKey creates AccountForUpdate instance with failKey.\r\n *\r\n * @method createAccountForUpdateWithFailKey\r\n * @param {String} address The address of account to update with the fail key.\r\n * @return {Object}\r\n */\n\n\nAccounts.prototype.createAccountForUpdateWithFailKey = function createAccountForUpdateWithFailKey(address) {\n  return new AccountForUpdate(address, 'failKey');\n};\n/**\r\n * isDecoupled determines whether or not it is decoupled based on the input value.\r\n *\r\n * @method isDecoupled\r\n * @param {String} key The key parameter can be either normal private key or KlaytnWalletKey format.\r\n * @param {String} userInputAddress The address to use when determining whether it is decoupled.\r\n * @return {Boolean}\r\n */\n\n\nAccounts.prototype.isDecoupled = function isDecoupled(key, userInputAddress) {\n  const {\n    legacyAccount,\n    klaytnWalletKeyAddress\n  } = this.getLegacyAccount(key);\n\n  const actualAddress = this._determineAddress(legacyAccount, klaytnWalletKeyAddress, userInputAddress);\n\n  return legacyAccount.address.toLowerCase() !== actualAddress.toLowerCase();\n};\n/**\r\n * getLegacyAccount extracts the private key from the input key and returns an account with the corresponding legacy account key.\r\n * If the input key is KlaytnWalletKey format, it returns klaytnWalletKeyAddress, which is the address extracted from KlaytnWalletKey.\r\n *\r\n * @method getLegacyAccount\r\n * @param {String} key The key parameter can be either normal private key or KlaytnWalletKey format.\r\n * @return {Object}\r\n */\n\n\nAccounts.prototype.getLegacyAccount = function getLegacyAccount(key) {\n  const parsed = utils.parsePrivateKey(key);\n\n  if (!utils.isValidPrivateKey(parsed.privateKey)) {\n    throw new Error('Invalid private key');\n  }\n\n  const privateKey = utils.addHexPrefix(parsed.privateKey);\n\n  const account = this._addAccountFunctions(Account.fromObject(AccountLib.fromPrivate(privateKey)));\n\n  return {\n    legacyAccount: account,\n    klaytnWalletKeyAddress: parsed.address\n  };\n};\n/**\r\n * signTransaction signs to transaction with private key.\r\n * If there are signatures(feePayerSignatures if the fee payer signs) in tx entered as a parameter,\r\n * the signatures(feePayerSignatures if the fee payer signs) are appended.\r\n *\r\n * @method signTransaction\r\n * @param {String|Object} tx The transaction to sign.\r\n * @param {String|Array} privateKey The private key to use for signing.\r\n * @param {Function} callback The callback function to call.\r\n * @return {Object}\r\n */\n\n\nAccounts.prototype.signTransaction = function signTransaction() {\n  const _this = this;\n\n  let isLegacy = false;\n  let isFeePayer = false;\n  let existedSenderSignatures = [];\n  let existedFeePayerSignatures = [];\n  let result;\n  let tx;\n  let privateKey;\n  let callback;\n\n  const handleError = e => {\n    e = e instanceof Error ? e : new Error(e);\n    if (callback) callback(e);\n    return Promise.reject(e);\n  };\n\n  try {\n    const resolved = resolveArgsForSignTransaction(arguments);\n    tx = resolved.tx;\n    privateKey = resolved.privateKey;\n    callback = resolved.callback;\n  } catch (e) {\n    return handleError(e);\n  } // If the user signs an RLP encoded transaction, tx is of type string.\n\n\n  if (_.isString(tx)) {\n    tx = decodeFromRawTransaction(tx);\n  } // Validate tx object\n\n\n  const error = helpers.validateFunction.validateParams(tx);\n  if (error) return handleError(error);\n\n  if (tx.senderRawTransaction) {\n    if (tx.feePayerSignatures) {\n      existedFeePayerSignatures = existedFeePayerSignatures.concat(tx.feePayerSignatures);\n    }\n\n    try {\n      // Decode senderRawTransaction to get signatures of fee payer\n      const {\n        senderRawTransaction,\n        feePayer,\n        feePayerSignatures\n      } = splitFeePayer(tx.senderRawTransaction); // feePayer !== '0x' means that in senderRawTransaction there are feePayerSignatures\n\n      if (feePayer !== '0x' && feePayer !== '0x0000000000000000000000000000000000000000') {\n        // The feePayer inside the tx object does not match the feePayer information contained in the senderRawTransaction.\n        if (feePayer.toLowerCase() !== tx.feePayer.toLowerCase()) {\n          return handleError(`Invalid feePayer: The fee payer(${feePayer}) included in the transaction does not match the fee payer(${tx.feePayer}) you want to sign.`);\n        }\n\n        existedFeePayerSignatures = existedFeePayerSignatures.concat(feePayerSignatures);\n      }\n\n      tx.senderRawTransaction = senderRawTransaction;\n      isFeePayer = true;\n    } catch (e) {\n      return handleError(e);\n    }\n  } else {\n    isLegacy = !!(tx.type === undefined || tx.type === 'LEGACY');\n\n    if (tx.signatures) {\n      // if there is existed signatures or feePayerSignatures, those should be preserved.\n      if (isLegacy) {\n        return handleError('Legacy transaction cannot be signed with multiple keys.');\n      }\n\n      existedSenderSignatures = existedSenderSignatures.concat(tx.signatures);\n    }\n  } // When privateKey is undefined, find Account from Wallet.\n\n\n  if (privateKey === undefined) {\n    try {\n      const account = this.wallet.getAccount(isFeePayer ? tx.feePayer : tx.from);\n\n      if (!account) {\n        return handleError('Failed to find get private key to sign. The account you want to use for signing must exist in caver.klay.accounts.wallet or you must pass the private key as a parameter.');\n      }\n\n      privateKey = this._getRoleKey(tx, account);\n    } catch (e) {\n      return handleError(e);\n    }\n  }\n\n  const privateKeys = _.isArray(privateKey) ? privateKey : [privateKey];\n\n  try {\n    for (let i = 0; i < privateKeys.length; i++) {\n      const parsed = utils.parsePrivateKey(privateKeys[i]);\n      privateKeys[i] = parsed.privateKey;\n      privateKeys[i] = utils.addHexPrefix(privateKeys[i]);\n\n      if (!utils.isValidPrivateKey(privateKeys[i])) {\n        return handleError('Invalid private key');\n      }\n    }\n  } catch (e) {\n    return handleError(e);\n  } // Attempting to sign with a decoupled account into a legacy type transaction should be rejected.\n\n\n  if (isLegacy) {\n    if (privateKeys.length > 1) {\n      return handleError('Legacy transaction cannot signed with multiple keys');\n    }\n\n    if (_this.isDecoupled(privateKeys[0], tx.from)) {\n      return handleError('A legacy transaction must be with a legacy account key');\n    }\n  }\n\n  function signed(txObject) {\n    try {\n      // Guarantee all property in transaction is hex.\n      txObject = helpers.formatters.inputCallFormatter(txObject);\n      const transaction = coverInitialTxValue(txObject);\n      const rlpEncoded = encodeRLPByTxType(transaction);\n      const messageHash = Hash.keccak256(rlpEncoded);\n      const sigs = isFeePayer ? existedFeePayerSignatures : existedSenderSignatures;\n\n      for (const p of privateKeys) {\n        const signature = AccountLib.makeSigner(Nat.toNumber(transaction.chainId || '0x1') * 2 + 35)(messageHash, p);\n        const [v, r, s] = AccountLib.decodeSignature(signature).map(sig => utils.makeEven(utils.trimLeadingZero(sig)));\n        sigs.push([v, r, s]);\n      } // makeRawTransaction will return signatures and feePayerSignatures with duplicates removed.\n\n\n      const {\n        rawTransaction,\n        signatures,\n        feePayerSignatures\n      } = makeRawTransaction(rlpEncoded, sigs, transaction);\n      result = {\n        messageHash,\n        v: sigs[0][0],\n        r: sigs[0][1],\n        s: sigs[0][2],\n        rawTransaction,\n        txHash: Hash.keccak256(rawTransaction),\n        senderTxHash: getSenderTxHash(rawTransaction)\n      };\n\n      if (isFeePayer) {\n        result.feePayerSignatures = feePayerSignatures;\n      } else {\n        result.signatures = signatures;\n      }\n    } catch (e) {\n      callback(e);\n      return Promise.reject(e);\n    }\n\n    callback(null, result);\n    return result;\n  }\n\n  if (tx.nonce !== undefined && tx.chainId !== undefined && tx.gasPrice !== undefined) {\n    return Promise.resolve(signed(tx));\n  } // When the feePayer signs a transaction, required information is only chainId.\n\n\n  if (isFeePayer) {\n    return Promise.all([isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId]).then(function (args) {\n      if (isNot(args[0])) {\n        throw new Error(`\"chainId\" couldn't be fetched: ${JSON.stringify(args)}`);\n      }\n\n      return signed(_.extend(tx, {\n        chainId: args[0]\n      }));\n    });\n  } // Otherwise, get the missing info from the Klaytn Node\n\n\n  return Promise.all([isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId, isNot(tx.gasPrice) ? _this._suggestGasPrice() : tx.gasPrice, isNot(tx.nonce) ? _this._klaytnCall.getTransactionCount(tx.from, 'pending') : tx.nonce]).then(function (args) {\n    if (isNot(args[0]) || isNot(args[1]) || isNot(args[2])) {\n      throw new Error(`One of the values \"chainId\", \"gasPrice\", or \"nonce\" couldn't be fetched: ${JSON.stringify(args)}`);\n    }\n\n    return signed(_.extend(tx, {\n      chainId: args[0],\n      gasPrice: args[1],\n      nonce: args[2]\n    }));\n  });\n};\n/**\r\n * feePayerSignTransaction calls signTransaction, creating a format for feePayer to sign the transaction.\r\n * If there are feePayerSignatures in tx entered as a parameter, the signatures for fee payer are appended.\r\n *\r\n * @method feePayerSignTransaction\r\n * @param {Object|String} tx The transaction to sign.\r\n * @param {String} feePayer The address of fee payer.\r\n * @param {String|Array} privateKey The private key to use for signing.\r\n * @param {Function} callback The callback function to call.\r\n * @return {Object}\r\n */\n\n\nAccounts.prototype.feePayerSignTransaction = function feePayerSignTransaction() {\n  const _this = this;\n\n  let tx;\n  let feePayer;\n  let privateKey;\n  let callback;\n\n  const handleError = e => {\n    e = e instanceof Error ? e : new Error(e);\n    if (callback) callback(e);\n    return Promise.reject(e);\n  };\n\n  try {\n    const resolved = resolveArgsForFeePayerSignTransaction(arguments);\n    tx = resolved.tx;\n    feePayer = resolved.feePayer;\n    privateKey = resolved.privateKey;\n    callback = resolved.callback;\n  } catch (e) {\n    return handleError(e);\n  }\n\n  if (_.isString(tx)) {\n    return this.signTransaction({\n      senderRawTransaction: tx,\n      feePayer\n    }, privateKey, callback);\n  }\n\n  if (!tx.feePayer || tx.feePayer === '0x' || tx.feePayer === '0x0000000000000000000000000000000000000000') {\n    tx.feePayer = feePayer;\n  }\n\n  if (!tx.senderRawTransaction) {\n    if (!tx.type || !tx.type.includes('FEE_DELEGATED')) {\n      return handleError(`Failed to sign transaction with fee payer: invalid transaction type(${tx.type ? tx.type : 'LEGACY'})`);\n    }\n  }\n\n  const e = helpers.validateFunction.validateParams(tx);\n\n  if (e) {\n    return handleError(e);\n  }\n\n  if (tx.feePayer.toLowerCase() !== feePayer.toLowerCase()) {\n    return handleError('Invalid parameter: The address of fee payer does not match.');\n  }\n\n  if (tx.senderRawTransaction) {\n    return this.signTransaction(tx, privateKey, callback);\n  }\n\n  return Promise.all([isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId, isNot(tx.gasPrice) ? _this._klaytnCall.getGasPrice() : tx.gasPrice, isNot(tx.nonce) ? _this._klaytnCall.getTransactionCount(tx.from, 'pending') : tx.nonce]).then(function (args) {\n    const chainId = args[0];\n    const gasPrice = args[1];\n    const nonce = args[2];\n\n    if (isNot(chainId) || isNot(gasPrice) || isNot(nonce)) {\n      throw new Error(`One of the values \"chainId\", \"gasPrice\", or \"nonce\" couldn't be fetched: ${JSON.stringify(args)}`);\n    }\n\n    let transaction = _.extend(tx, {\n      chainId,\n      gasPrice,\n      nonce\n    });\n\n    transaction = helpers.formatters.inputCallFormatter(transaction);\n    transaction = coverInitialTxValue(transaction);\n    const rlpEncoded = encodeRLPByTxType(transaction);\n    const sig = transaction.signatures ? transaction.signatures : [['0x01', '0x', '0x']];\n    const {\n      rawTransaction\n    } = makeRawTransaction(rlpEncoded, sig, transaction);\n    return _this.signTransaction({\n      senderRawTransaction: rawTransaction,\n      feePayer,\n      chainId\n    }, privateKey, callback);\n  });\n};\n/**\r\n * signTransactionWithHash signs to transaction hash with private key(s).\r\n *\r\n * @method signTransactionWithHash\r\n * @param {String} hash The hash of transaction to sign.\r\n * @param {String|Array} privateKeys The private key(s) to use for signing.\r\n * @param {String|Number} chainId The chain id of the network.\r\n * @param {Function} callback The callback function to call.\r\n * @return {Array}\r\n */\n\n\nAccounts.prototype.signTransactionWithHash = function signTransactionWithHash() {\n  const _this = this;\n\n  let hash;\n  let privateKeys;\n  let chainId;\n  let callback;\n\n  const handleError = e => {\n    e = e instanceof Error ? e : new Error(e);\n    if (callback) callback(e);\n    return Promise.reject(e);\n  };\n\n  try {\n    const resolved = resolveArgsForSignTransactionWithHash(arguments);\n    hash = resolved.hash;\n    chainId = resolved.chainId;\n    privateKeys = resolved.privateKeys;\n    callback = resolved.callback;\n  } catch (e) {\n    return handleError(e);\n  }\n\n  privateKeys = Array.isArray(privateKeys) ? privateKeys : [privateKeys];\n\n  function signWithHash(transactionHash, prvKeys, chain, callbackFunc) {\n    const result = [];\n    chain = utils.numberToHex(chain);\n\n    try {\n      for (const privateKey of prvKeys) {\n        const p = utils.addHexPrefix(utils.parsePrivateKey(privateKey).privateKey);\n\n        if (!utils.isValidPrivateKey(p)) {\n          return handleError(`Failed to sign transaction with hash: Invalid private key ${privateKey}`);\n        }\n\n        const signature = AccountLib.makeSigner(Nat.toNumber(chain || '0x1') * 2 + 35)(transactionHash, p);\n        const [v, r, s] = AccountLib.decodeSignature(signature).map(sig => utils.makeEven(utils.trimLeadingZero(sig)));\n        result.push(utils.transformSignaturesToObject([v, r, s]));\n      }\n    } catch (e) {\n      callbackFunc(e);\n      return Promise.reject(e);\n    }\n\n    callbackFunc(null, result);\n    return result;\n  }\n\n  return Promise.resolve(isNot(chainId) ? _this._klaytnCall.getChainId() : chainId).then(id => {\n    return signWithHash(hash, privateKeys, id, callback);\n  });\n};\n/**\r\n * getRawTransactionWithSignatures returns object which contains rawTransaction.\r\n *\r\n * @method getRawTransactionWithSignatures\r\n * @param {Object} tx The transaction object which contains signatures or feePayerSignatures.\r\n * @param {Function} callback The callback function to call.\r\n * @return {Object}\r\n */\n\n\nAccounts.prototype.getRawTransactionWithSignatures = function getRawTransactionWithSignatures(tx, callback) {\n  const _this = this;\n\n  let result;\n\n  callback = callback || function () {};\n\n  const handleError = e => {\n    e = e instanceof Error ? e : new Error(e);\n    if (callback) callback(e);\n    return Promise.reject(e);\n  };\n\n  if (!tx || !_.isObject(tx)) {\n    return handleError('Invalid parameter: The transaction must be defined as an object');\n  }\n\n  if (!tx.signatures && !tx.feePayerSignatures) {\n    return handleError('There are no signatures or feePayerSignatures defined in the transaction object.');\n  }\n\n  const error = helpers.validateFunction.validateParams(tx);\n  if (error) return handleError(error);\n\n  if (tx.senderRawTransaction) {\n    tx.feePayerSignatures = tx.feePayerSignatures || [['0x01', '0x', '0x']];\n    const decoded = decodeFromRawTransaction(tx.senderRawTransaction); // feePayer !== '0x' means that in senderRawTransaction there are feePayerSignatures\n\n    if (decoded.feePayer !== '0x' && decoded.feePayer !== '0x0000000000000000000000000000000000000000' && !utils.isEmptySig(decoded.feePayerSignatures)) {\n      if (decoded.feePayer.toLowerCase() !== tx.feePayer.toLowerCase()) {\n        return handleError('Invalid feePayer');\n      }\n\n      tx.feePayerSignatures = tx.feePayerSignatures.concat(decoded.feePayerSignatures);\n    }\n\n    decoded.feePayer = tx.feePayer;\n    decoded.feePayerSignatures = tx.feePayerSignatures;\n\n    if (tx.signatures) {\n      decoded.signatures = decoded.signatures.concat(tx.signatures);\n    }\n\n    tx = decoded;\n  }\n\n  function signed(txObject) {\n    try {\n      // Guarantee all property in transaction is hex.\n      txObject = helpers.formatters.inputCallFormatter(txObject);\n      const transaction = coverInitialTxValue(txObject);\n      const rlpEncoded = encodeRLPByTxType(transaction);\n      let sigs = transaction.signatures ? transaction.signatures : ['0x01', '0x', '0x'];\n      if (!_.isArray(sigs[0])) sigs = [sigs];\n      const {\n        rawTransaction,\n        signatures,\n        feePayerSignatures\n      } = makeRawTransaction(rlpEncoded, sigs, transaction);\n      result = {\n        rawTransaction,\n        txHash: Hash.keccak256(rawTransaction),\n        senderTxHash: getSenderTxHash(rawTransaction)\n      };\n\n      if (signatures && !utils.isEmptySig(signatures)) {\n        result.signatures = signatures;\n      }\n\n      if (feePayerSignatures && !utils.isEmptySig(feePayerSignatures)) {\n        result.feePayerSignatures = feePayerSignatures;\n      }\n    } catch (e) {\n      callback(e);\n      return Promise.reject(e);\n    }\n\n    callback(null, result);\n    return result;\n  }\n\n  if (tx.nonce !== undefined && tx.chainId !== undefined && tx.gasPrice !== undefined) {\n    return Promise.resolve(signed(tx));\n  } // Otherwise, get the missing info from the Klaytn Node\n\n\n  return Promise.all([isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId, isNot(tx.gasPrice) ? _this._klaytnCall.getGasPrice() : tx.gasPrice, isNot(tx.nonce) ? _this._klaytnCall.getTransactionCount(tx.from, 'pending') : tx.nonce]).then(function (args) {\n    if (isNot(args[0]) || isNot(args[1]) || isNot(args[2])) {\n      throw new Error(`One of the values \"chainId\", \"gasPrice\", or \"nonce\" couldn't be fetched: ${JSON.stringify(args)}`);\n    }\n\n    return signed(_.extend(tx, {\n      chainId: args[0],\n      gasPrice: args[1],\n      nonce: args[2]\n    }));\n  });\n};\n/**\r\n * combineSignatures combines RLP encoded raw transaction strings.\r\n * combineSignatures compares transaction before combining, and if values in field are not same, this throws error.\r\n * The comparison allows that the address of the fee payer is '0x0000000000000000000000000000000000000000'(default value) for some transactions while the other transactions have a specific fee payer. This is for the use case that some transactions do not have the fee payer's information.\r\n * In this case, feePayer field doesn't have to be compared with other transaction.\r\n *\r\n * @method combineSignatures\r\n * @param {Array} rawTransactions The array of raw transaction string to combine.\r\n * @param {Function} callback The callback function to call.\r\n * @return {Object}\r\n */\n\n\nAccounts.prototype.combineSignatures = function combineSignatures(rawTransactions, callback) {\n  let decodedTx;\n  let senders = [];\n  let feePayers = [];\n  let feePayer;\n\n  callback = callback || function () {};\n\n  const handleError = e => {\n    e = e instanceof Error ? e : new Error(e);\n    if (callback) callback(e);\n    return Promise.reject(e);\n  };\n\n  if (!_.isArray(rawTransactions)) {\n    return handleError('The parameter of the combineSignatures function must be an array of RLP encoded transaction strings.');\n  }\n\n  for (const raw of rawTransactions) {\n    const {\n      senderSignatures,\n      feePayerSignatures,\n      decodedTransaction\n    } = extractSignatures(raw);\n    senders = senders.concat(senderSignatures);\n    feePayers = feePayers.concat(feePayerSignatures);\n\n    if (decodedTx) {\n      let isSame = true;\n      const keys = Object.keys(decodedTx);\n\n      for (const key of keys) {\n        if (key === 'v' || key === 'r' || key === 's' || key === 'signatures' || key === 'payerV' || key === 'payerR' || key === 'payerS' || key === 'feePayerSignatures') {\n          continue;\n        } // feePayer field can be '0x' or '0x0000000000000000000000000000000000000000' when after sender signs to trasnaction.\n        // For handling this, if feePayer is '0x' or '0x0000000000000000000000000000000000000000', don't compare with other transaction\n\n\n        if (key === 'feePayer') {\n          if (decodedTransaction[key] === '0x' || decodedTransaction[key] === '0x0000000000000000000000000000000000000000') {\n            continue;\n          } else {\n            // set feePayer letiable with valid feePayer address(not '0x' and '0x0000000000000000000000000000000000000000')\n            feePayer = decodedTransaction[key];\n\n            if (decodedTx[key] === '0x' || decodedTx[key] === '0x0000000000000000000000000000000000000000') {\n              // set feePayer field to decodedTx for comparing feePayer address with other transactions\n              decodedTx[key] = decodedTransaction[key];\n            }\n          }\n        }\n\n        if (decodedTransaction[key] === undefined || decodedTx[key] !== decodedTransaction[key]) {\n          isSame = false;\n          break;\n        }\n      }\n\n      if (!isSame) {\n        return handleError('Failed to combineSignatures: Signatures that sign to different transaction cannot be combined.');\n      }\n    } else {\n      decodedTx = decodedTransaction;\n    }\n  }\n\n  const parsedTxObject = decodeFromRawTransaction(rawTransactions[0]);\n  parsedTxObject.signatures = senders;\n\n  if (feePayer) {\n    parsedTxObject.feePayer = feePayer;\n\n    if (feePayers.length > 0) {\n      parsedTxObject.feePayerSignatures = feePayers;\n    }\n  }\n\n  return this.getRawTransactionWithSignatures(parsedTxObject, callback);\n};\n/**\r\n * cav.klay.accounts.recoverTransaction('0xf86180808401ef364594f0109fc8df283027b6285cc889f5aa624eac1f5580801ca031573280d608f75137e33fc14655f097867d691d5c4c44ebe5ae186070ac3d5ea0524410802cdc025034daefcdfa08e7d2ee3f0b9d9ae184b2001fe0aff07603d9');\r\n * > \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\"\r\n */\n\n\nAccounts.prototype.recoverTransaction = function recoverTransaction(rawTx) {\n  if (utils.getTxTypeStringFromRawTransaction(rawTx) !== undefined) {\n    throw new Error('recoverTransaction only supports transactions of type \"LEGACY\".');\n  }\n\n  const values = RLP.decode(rawTx); // If the leading zero is trimmed, it will be filled with a valid length of '0'.\n\n  const arr = values.slice(7, 9).map(sig => {\n    sig = sig.replace('0x', '');\n\n    while (sig.length < 64) {\n      sig = `0${sig}`;\n    }\n\n    return `0x${sig}`;\n  });\n  arr.unshift(values[6]);\n  const signature = AccountLib.encodeSignature(arr);\n  const recovery = Bytes.toNumber(values[6]);\n  const extraData = recovery < 35 ? [] : [Bytes.fromNumber(recovery - 35 >> 1), '0x', '0x'];\n  const signingData = values.slice(0, 6).concat(extraData);\n  const signingDataHex = RLP.encode(signingData);\n  return AccountLib.recover(Hash.keccak256(signingDataHex), signature);\n};\n/**\r\n * Hashes the given message to be passed cav.klay.accounts.recover() function.\r\n * The data will be UTF-8 HEX decoded and enveloped as follows:\r\n * \"\\x19Klaytn Signed Message:\\n\" + message.length + message and hashed using keccak256.\r\n *\r\n * cav.klay.accounts.hashMessage(\"Hello World\")\r\n * > \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\"\r\n * // the below results in the same hash\r\n * cav.klay.accounts.hashMessage(caver.utils.utf8ToHex(\"Hello World\"))\r\n * > \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\"\r\n */\n\n\nAccounts.prototype.hashMessage = function hashMessage(data) {\n  const message = utils.isHexStrict(data) ? utils.hexToBytes(data) : data;\n  const messageBuffer = Buffer.from(message);\n  const preamble = `\\x19Klaytn Signed Message:\\n${message.length}`;\n  const preambleBuffer = Buffer.from(preamble); // klayMessage is concatenated buffer (preambleBuffer + messageBuffer)\n\n  const klayMessage = Buffer.concat([preambleBuffer, messageBuffer]); // Finally, run keccak256 on klayMessage.\n\n  return Hash.keccak256(klayMessage);\n};\n/**\r\n * Signs arbitrary data.\r\n * This data is before UTF-8 HEX decoded and enveloped as follows:\r\n * \"\\x19Klaytn Signed Message:\\n\" + message.length + message.\r\n *\r\n * cav.klay.accounts.sign('Some data', '0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318');\r\n * > {\r\n *     message: 'Some data',\r\n *     messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655',\r\n *     v: '0x1c',\r\n *     r: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd',\r\n *     s: '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029',\r\n *     signature: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a0291c'\r\n *   }\r\n */\n\n\nAccounts.prototype.sign = function sign(data, privateKey) {\n  const parsed = utils.parsePrivateKey(privateKey);\n  privateKey = parsed.privateKey;\n\n  if (!utils.isValidPrivateKey(privateKey)) {\n    throw new Error('Invalid private key');\n  }\n\n  const messageHash = this.hashMessage(data);\n  const signature = AccountLib.sign(messageHash, privateKey);\n  const [v, r, s] = AccountLib.decodeSignature(signature);\n  return {\n    message: data,\n    messageHash,\n    v,\n    r,\n    s,\n    signature\n  };\n};\n/**\r\n * preFixed - Boolean (optional, default: false):\r\n * If the last parameter is true,\r\n * the given message will NOT automatically be prefixed with \"\\x19Klaytn Signed Message:\\n\" + message.length + message,\r\n * and assumed to be already prefixed.\r\n */\n\n\nAccounts.prototype.recover = function recover(message, signature, preFixed) {\n  const args = [].slice.apply(arguments);\n\n  if (_.isObject(message)) {\n    return this.recover(message.messageHash, AccountLib.encodeSignature([message.v, message.r, message.s]), true);\n  }\n\n  if (!preFixed) {\n    message = this.hashMessage(message);\n  }\n\n  if (args.length >= 4) {\n    preFixed = args.slice(-1)[0];\n    preFixed = _.isBoolean(preFixed) ? !!preFixed : false;\n    return this.recover(message, AccountLib.encodeSignature(args.slice(1, 4)), preFixed); // v, r, s\n  }\n  /**\r\n   * recover in Account module\r\n   * const recover = (hash, signature) => {\r\n   *   const vals = decodeSignature(signature);\r\n   *   const vrs = { v: Bytes.toNumber(vals[0]), r: vals[1].slice(2), s: vals[2].slice(2) };\r\n   *   const ecPublicKey = secp256k1.recoverPubKey(Buffer.from(hash.slice(2), 'hex'), vrs, vrs.v < 2 ? vrs.v : 1 - vrs.v % 2); // because odd vals mean v=0... sadly that means v=0 means v=1... I hate that\r\n   *   const publicKey = \"0x\" + ecPublicKey.encode('hex', false).slice(2);\r\n   *   const publicHash = keccak256(publicKey);\r\n   *   const address = toChecksum(\"0x\" + publicHash.slice(-40));\r\n   *   return address;\r\n   * };\r\n   */\n\n\n  return AccountLib.recover(message, signature);\n}; // Taken from https://github.com/ethereumjs/ethereumjs-wallet\n\n\nAccounts.prototype.decrypt = function (v3Keystore, password, nonStrict) {\n  if (!_.isString(password)) {\n    throw new Error('No password given.');\n  } // To deep copy an object, using JSON.parse and JSON.stringify (object -> string -> object)\n\n\n  const json = _.isObject(v3Keystore) ? _.cloneDeep(v3Keystore) : JSON.parse(nonStrict ? v3Keystore.toLowerCase() : v3Keystore);\n\n  if (json.version !== 3 && json.version !== 4) {\n    console.warn('This is not a V3 or V4 wallet.'); // throw new Error('Not a valid V3 wallet');\n  }\n\n  if (json.version === 3 && !json.crypto) {\n    // crypto field should be existed in keystore version 3\n    throw new Error(\"Invalid keystore V3 format: 'crypto' is not defined.\");\n  }\n\n  if (json.crypto) {\n    if (json.keyring) {\n      throw new Error(\"Invalid key store format: 'crypto' can not be with 'keyring'\");\n    }\n\n    json.keyring = [json.crypto];\n    delete json.crypto;\n  }\n\n  if (_.isArray(json.keyring[0]) && json.keyring.length > 3) {\n    throw new Error('Invalid key store format');\n  }\n\n  let accountKey = {}; // AccountKeyRoleBased format\n\n  if (_.isArray(json.keyring[0])) {\n    const transactionKey = decryptKey(json.keyring[0]);\n    if (transactionKey) accountKey.transactionKey = transactionKey;\n    const updateKey = decryptKey(json.keyring[1]);\n    if (updateKey) accountKey.updateKey = updateKey;\n    const feePayerKey = decryptKey(json.keyring[2]);\n    if (feePayerKey) accountKey.feePayerKey = feePayerKey;\n  } else {\n    accountKey = decryptKey(json.keyring);\n  }\n\n  function decryptKey(encryptedArray) {\n    if (!encryptedArray || encryptedArray.length === 0) return undefined;\n    const decryptedArray = [];\n\n    for (const encrypted of encryptedArray) {\n      let derivedKey;\n      let kdfparams;\n      /**\r\n       * Supported kdf modules are the following:\r\n       * 1) pbkdf2\r\n       * 2) scrypt\r\n       */\n\n      if (encrypted.kdf === 'scrypt') {\n        kdfparams = encrypted.kdfparams; // FIXME: support progress reporting callback\n\n        derivedKey = scrypt.syncScrypt(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n      } else if (encrypted.kdf === 'pbkdf2') {\n        kdfparams = encrypted.kdfparams;\n\n        if (kdfparams.prf !== 'hmac-sha256') {\n          throw new Error('Unsupported parameters to PBKDF2');\n        }\n\n        derivedKey = cryp.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');\n      } else {\n        throw new Error('Unsupported key derivation scheme');\n      }\n\n      const ciphertext = Buffer.from(encrypted.ciphertext, 'hex');\n      const mac = utils.sha3(Buffer.from([...derivedKey.slice(16, 32), ...ciphertext])).replace('0x', '');\n\n      if (mac !== encrypted.mac) {\n        throw new Error('Key derivation failed - possibly wrong password');\n      }\n\n      const decipher = cryp.createDecipheriv(encrypted.cipher, derivedKey.slice(0, 16), Buffer.from(encrypted.cipherparams.iv, 'hex'));\n      decryptedArray.push(`0x${Buffer.from([...decipher.update(ciphertext), ...decipher.final()]).toString('hex')}`);\n    }\n\n    return decryptedArray.length === 1 ? decryptedArray[0] : decryptedArray;\n  }\n\n  return this.createWithAccountKey(json.address, accountKey);\n};\n/*\r\n    The fields of kdfparams are described below.\r\n\r\n    `dklen` is the desired length of the derived key\r\n    `salt` - A string of characters that modifies the hash to protect against Rainbow table attacks\r\n    `n` - CPU/memory cost parameter\r\n    `r` - The blocksize parameter, which fine-tunes sequential memory read size and performance. 8 is commonly used.\r\n    `p` - Parallelization parameter\r\n    `c` - the number of iterations desired\r\n */\n\n/**\r\n * encrypt encrypts an account and returns a key store v4 object.\r\n *\r\n * @method encrypt\r\n * @param {String} key The key parameter can be a raw key format(private key string, KlaytnWalletKey, array of private keys or object with keys by roles) or an instance of Account or AccountKey.\r\n * @param {String} password The password to be used for account encryption. The encrypted key store can be decrypted with this password.\r\n * @param {Object} options The options to use when encrypt an account.\r\n * @return {Object}\r\n */\n\n\nAccounts.prototype.encrypt = function (key, password, options) {\n  /**\r\n   * options can include below\r\n   * {\r\n   *   salt: ...,\r\n   *   iv: ...,\r\n   *   kdf: ...,\r\n   *   dklen: ...,\r\n   *   c: ...,\r\n   *   n: ...,\r\n   *   r: ...,\r\n   *   p: ...,\r\n   *   cipher: ...,\r\n   *   uuid: ...,\r\n   *   cipher: ...,\r\n   * }\r\n   */\n  options = options || {};\n  let address;\n  let account;\n\n  if (key instanceof Account) {\n    if (options.address && options.address !== key.address) {\n      throw new Error('Address in account is not matched with address in options object');\n    }\n\n    address = key.address;\n    account = key;\n  } else if (_.isString(key)) {\n    account = this.privateKeyToAccount(key, options.address);\n    address = account.address;\n  } else {\n    if (!options.address) {\n      throw new Error('The address must be defined inside the options object.');\n    }\n\n    address = options.address;\n  }\n\n  if (!account) account = this.createWithAccountKey(address, key);\n  let keyring;\n  let transactionKey;\n  let updateKey;\n  let feePayerKey;\n\n  switch (account.accountKeyType) {\n    case AccountKeyEnum.ACCOUNT_KEY_PUBLIC:\n    case AccountKeyEnum.ACCOUNT_KEY_MULTISIG:\n      keyring = encryptKey(account.keys, password, options);\n      break;\n\n    case AccountKeyEnum.ACCOUNT_KEY_ROLEBASED:\n      keyring = [];\n      transactionKey = encryptKey(account.transactionKey, password, options);\n      updateKey = encryptKey(account.updateKey, password, options);\n      feePayerKey = encryptKey(account.feePayerKey, password, options);\n      keyring.push(transactionKey);\n      keyring.push(updateKey);\n      keyring.push(feePayerKey);\n\n      for (let i = keyring.length - 1; i >= 0; i--) {\n        if (keyring[i].length !== 0) break;\n        keyring = keyring.slice(0, i);\n      }\n\n      break;\n\n    default:\n      throw new Error(`Unsupported account key type: ${account.accountKeyType}`);\n  }\n\n  return {\n    version: 4,\n    id: uuid.v4({\n      random: options.uuid || cryp.randomBytes(16)\n    }),\n    address: account.address.toLowerCase(),\n    keyring\n  };\n};\n/**\r\n * encryptV3 encrypts an account and returns a key store v3 object.\r\n *\r\n * @method encryptV3\r\n * @param {String} key The key parameter can be a normal private key(KlaytnWalletKey format also supported) or an instance of Account or AccountKeyPublic.\r\n * @param {String} password The password to be used for account encryption. The encrypted key store can be decrypted with this password.\r\n * @param {Object} options The options to use when encrypt an account.\r\n * @return {Object}\r\n */\n\n\nAccounts.prototype.encryptV3 = function (key, password, options) {\n  options = options || {};\n  let address;\n  let account;\n  const notSupportedType = 'Invalid parameter: encryptV3 only supports a single private key (also supports KlantnWalletKey format), or an instance of Account or AccountKeyPublic as a parameter. If you want to encrypt multiple keys, use caver.klay.accounts.encrypt which encrypts to keystore v4.';\n\n  if (key instanceof Account) {\n    if (options.address && options.address !== key.address) {\n      throw new Error('Address in account is not matched with address in options object');\n    }\n\n    if (key.accountKeyType !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) throw new Error(notSupportedType);\n    address = key.address;\n    account = key;\n  } else if (_.isString(key)) {\n    account = this.privateKeyToAccount(key, options.address);\n    address = account.address;\n  } else if (Account.isAccountKey(key)) {\n    if (key.type !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) throw new Error(notSupportedType);\n\n    if (!options.address) {\n      throw new Error('The address must be defined inside the options object.');\n    }\n\n    address = options.address;\n  } else {\n    throw new Error(notSupportedType);\n  }\n\n  if (!account) account = this.createWithAccountKey(address, key);\n  const crypto = encryptKey(account.keys, password, options);\n  return {\n    version: 3,\n    id: uuid.v4({\n      random: options.uuid || cryp.randomBytes(16)\n    }),\n    address: account.address.toLowerCase(),\n    crypto: crypto[0]\n  };\n};\n\nAccounts.prototype.privateKeyToPublicKey = function (privateKey) {\n  let compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const parsed = utils.parsePrivateKey(privateKey);\n  privateKey = parsed.privateKey;\n  privateKey = privateKey.slice(0, 2) === '0x' ? privateKey.slice(2) : privateKey;\n\n  if (privateKey.length !== 64) {\n    throw new Error('Received a invalid privateKey. The length of privateKey should be 64.');\n  }\n\n  const buffer = Buffer.from(privateKey, 'hex');\n  const ecKey = secp256k1.keyFromPrivate(buffer);\n  let publicKey;\n\n  if (!compressed) {\n    publicKey = `0x${ecKey.getPublic(false, 'hex').slice(2)}`;\n  } else {\n    publicKey = `0x${ecKey.getPublic(true, 'hex')}`;\n  }\n\n  return publicKey;\n};\n\nAccounts.prototype.encodeRLPByTxType = encodeRLPByTxType;\n\nAccounts.prototype.setAccounts = function (accounts) {\n  this.wallet.clear();\n\n  for (let i = 0; i < accounts.wallet.length; i++) {\n    this.wallet.add(accounts.wallet[i]);\n  }\n\n  return this;\n};\n/* eslint-enable complexity */\n// Note: this is trying to follow closely the specs on\n\n/**\r\n  > Wallet {\r\n      0: {...}, // account by index\r\n      \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\": {...},  // same account by address\r\n      \"0xf0109fc8df283027b6285cc889f5aa624eac1f55\": {...},  // same account by address lowercase\r\n      1: {...},\r\n      \"0xD0122fC8DF283027b6285cc889F5aA624EaC1d23\": {...},\r\n      \"0xd0122fc8df283027b6285cc889f5aa624eac1d23\": {...},\r\n\r\n      add: function(){},\r\n      remove: function(){},\r\n      save: function(){},\r\n      load: function(){},\r\n      clear: function(){},\r\n\r\n      length: 2,\r\n  }\r\n *\r\n * Contains an in memory wallet with multiple accounts.\r\n * These accounts can be used when using cav.klay.sendTransaction().\r\n */\n\n\nfunction Wallet(accounts) {\n  this._accounts = accounts;\n  this.length = 0;\n  this.defaultKeyName = 'caverjs_wallet';\n  this.lastIndex = -1;\n}\n\nWallet.prototype._findSafeIndex = function (pointer) {\n  pointer = pointer || 0;\n\n  while (this.lastIndex >= pointer) {\n    if (!_.has(this, pointer)) {\n      break;\n    }\n\n    pointer++;\n  }\n\n  if (this.lastIndex < pointer) {\n    this.lastIndex = pointer;\n  }\n\n  return pointer;\n};\n\nWallet.prototype._findSafeLastIndex = function (pointer) {\n  pointer = this.lastIndex;\n\n  while (pointer >= 0) {\n    if (_.has(this, pointer)) {\n      break;\n    }\n\n    pointer--;\n  }\n\n  return pointer;\n};\n\nWallet.prototype._currentIndexes = function () {\n  const keys = Object.keys(this);\n  const indexes = keys.map(function (key) {\n    return parseInt(key);\n  }).filter(function (n) {\n    return n < 9e20;\n  });\n  return indexes;\n};\n\nWallet.prototype.create = function (numberOfAccounts, entropy) {\n  for (let i = 0; i < numberOfAccounts; ++i) {\n    this.add(this._accounts.create(entropy).privateKey);\n  }\n\n  return this;\n};\n/**\r\n * Adds an account using a private key or account object to the wallet.\r\n *\r\n * cav.klay.accounts.wallet.add({\r\n    privateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\r\n    address: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01'\r\n    });\r\n    > {\r\n        index: 0,\r\n        address: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01',\r\n        privateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\r\n        signTransaction: function(tx){...},\r\n        sign: function(data){...},\r\n        encrypt: function(password){...}\r\n    }\r\n */\n\n\nWallet.prototype.add = function (account, userInputAddress) {\n  let accountForWallet;\n  /**\r\n   * cav.klay.accounts.wallet.add('0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318');\r\n   *\r\n   * cav.klay.accounts.wallet.add({\r\n   *   privateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\r\n   *   address: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01'\r\n   * });\r\n   */\n\n  if (Account.isAccountKey(account)) {\n    if (!userInputAddress) {\n      throw new Error('Address is not defined. Address cannot be determined from AccountKey');\n    }\n\n    accountForWallet = this._accounts.createWithAccountKey(userInputAddress, account);\n  } else if (account instanceof Account) {\n    accountForWallet = this._accounts.createWithAccountKey(account.address, account.accountKey);\n    accountForWallet.address = userInputAddress || account.address;\n  } else if (_.isObject(account) && account.address && account.privateKey) {\n    accountForWallet = this._accounts.privateKeyToAccount(account.privateKey, userInputAddress || account.address);\n  } else if (_.isString(account)) {\n    accountForWallet = this._accounts.privateKeyToAccount(account, userInputAddress);\n  } else {\n    const accountKey = this._accounts.createAccountKey(account);\n\n    if (!userInputAddress) {\n      throw new Error('Address is not defined. Address cannot be determined from AccountKey format');\n    }\n\n    accountForWallet = this._accounts.createWithAccountKey(userInputAddress, accountKey);\n  }\n\n  if (this[accountForWallet.address]) {\n    throw new Error(`Account exists with ${accountForWallet.address}`);\n  }\n\n  accountForWallet.index = this._findSafeIndex();\n  this[accountForWallet.index] = accountForWallet;\n  this[accountForWallet.address] = accountForWallet;\n  this[accountForWallet.address.toLowerCase()] = accountForWallet;\n  this[accountForWallet.address.toUpperCase()] = accountForWallet;\n\n  try {\n    this[utils.toChecksumAddress(accountForWallet.address)] = accountForWallet;\n  } catch (e) {}\n\n  this.length++;\n  return accountForWallet;\n};\n\nWallet.prototype.updatePrivateKey = function (privateKey, address) {\n  if (privateKey === undefined || address === undefined) {\n    throw new Error('To update the privatKey in wallet, need to set both privateKey and address.');\n  } // If privateKey parameter is not string type, return error\n\n\n  if (!_.isString(privateKey)) {\n    throw new Error('The private key used for the update is not a valid string.');\n  }\n\n  if (!utils.isAddress(address)) {\n    throw new Error(`Invalid address : ${address}`);\n  } // If failed to find account through address, return error\n\n\n  const accountExists = !!this[address];\n  if (!accountExists) throw new Error(`Failed to find account with ${address}`);\n  const account = this[address];\n\n  if (account.accountKeyType !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) {\n    throw new Error('Account using AccountKeyMultiSig or AccountKeyRoleBased must be updated using the caver.klay.accounts.updateAccountKey function.');\n  }\n\n  const parsed = utils.parsePrivateKey(privateKey);\n\n  if (!utils.isValidPrivateKey(parsed.privateKey)) {\n    throw new Error('Invalid private key');\n  }\n\n  if (parsed.address && parsed.address !== account.address) {\n    throw new Error('The address extracted from the private key does not match the address received as the input value.');\n  }\n\n  const newAccountKeyPublic = new AccountKeyPublic(parsed.privateKey);\n  this[account.index].accountKey = newAccountKeyPublic;\n  this[account.address].accountKey = newAccountKeyPublic;\n  this[account.address.toLowerCase()].accountKey = newAccountKeyPublic;\n  this[account.address.toUpperCase()].accountKey = newAccountKeyPublic;\n\n  try {\n    this[utils.toChecksumAddress(account.address)].accountKey = newAccountKeyPublic;\n  } catch (e) {}\n\n  return account;\n};\n\nWallet.prototype.updateAccountKey = function updateAccountKey(address, accountKey) {\n  if (address === undefined || accountKey === undefined) {\n    throw new Error('To update the accountKey in wallet, need to set both address and accountKey.');\n  }\n\n  if (!Account.isAccountKey(accountKey)) {\n    accountKey = this._accounts.createAccountKey(accountKey);\n  }\n\n  if (!utils.isAddress(address)) {\n    throw new Error(`Invalid address : ${address}`);\n  } // If failed to find account through address, return error\n\n\n  const accountExists = !!this[address];\n  if (!accountExists) throw new Error(`Failed to find account with ${address}`);\n  const account = this[address];\n  this[account.index].accountKey = accountKey;\n  this[account.address].accountKey = accountKey;\n  this[account.address.toLowerCase()].accountKey = accountKey;\n  this[account.address.toUpperCase()].accountKey = accountKey;\n\n  try {\n    this[utils.toChecksumAddress(account.address)].accountKey = accountKey;\n  } catch (e) {}\n\n  return account;\n};\n\nWallet.prototype.remove = function (addressOrIndex) {\n  const account = this[addressOrIndex];\n\n  if (account && account.address) {\n    // address\n    this[account.address].accountKey = null;\n    delete this[account.address];\n\n    if (this[account.address.toLowerCase()]) {\n      // address lowercase\n      this[account.address.toLowerCase()].accountKey = null;\n      delete this[account.address.toLowerCase()];\n    }\n\n    if (this[account.address.toUpperCase()]) {\n      // address uppercase\n      this[account.address.toUpperCase()].accountKey = null;\n      delete this[account.address.toUpperCase()];\n    }\n\n    try {\n      this[utils.toChecksumAddress(account.address)].accountKey = null;\n      delete this[utils.toChecksumAddress(account.address)];\n    } catch (e) {} // index\n\n\n    this[account.index].accountKey = null;\n    delete this[account.index];\n    this.length--; // Update last index\n\n    if (account.index === this.lastIndex) {\n      this.lastIndex = this._findSafeLastIndex();\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nWallet.prototype.clear = function () {\n  const _this = this;\n\n  const indexes = this._currentIndexes();\n\n  indexes.forEach(function (index) {\n    _this.remove(index);\n  });\n  return this;\n};\n/**\r\n * cav.klay.accounts.wallet.encrypt('test');\r\n    > [ { version: 3,\r\n        id: 'dcf8ab05-a314-4e37-b972-bf9b86f91372',\r\n        address: '06f702337909c06c82b09b7a22f0a2f0855d1f68',\r\n        crypto:\r\n         { ciphertext: '0de804dc63940820f6b3334e5a4bfc8214e27fb30bb7e9b7b74b25cd7eb5c604',\r\n           cipherparams: [Object],\r\n           cipher: 'aes-128-ctr',\r\n           kdf: 'scrypt',\r\n           kdfparams: [Object],\r\n           mac: 'b2aac1485bd6ee1928665642bf8eae9ddfbc039c3a673658933d320bac6952e3' } },\r\n      { version: 3,\r\n        id: '9e1c7d24-b919-4428-b10e-0f3ef79f7cf0',\r\n        address: 'b5d89661b59a9af0b34f58d19138baa2de48baaf',\r\n        crypto:\r\n         { ciphertext: 'd705ebed2a136d9e4db7e5ae70ed1f69d6a57370d5fbe06281eb07615f404410',\r\n           cipherparams: [Object],\r\n           cipher: 'aes-128-ctr',\r\n           kdf: 'scrypt',\r\n           kdfparams: [Object],\r\n           mac: 'af9eca5eb01b0f70e909f824f0e7cdb90c350a802f04a9f6afe056602b92272b' } }\r\n    ]\r\n */\n\n\nWallet.prototype.encrypt = function (password, options) {\n  const _this = this;\n\n  const indexes = this._currentIndexes();\n\n  const accounts = indexes.map(function (index) {\n    return _this[index].encrypt(password, options);\n  });\n  return accounts;\n};\n/**\r\n * cav.klay.accounts.wallet.decrypt([\r\n    { version: 3,\r\n    id: '83191a81-aaca-451f-b63d-0c5f3b849289',\r\n    address: '06f702337909c06c82b09b7a22f0a2f0855d1f68',\r\n    crypto:\r\n     { ciphertext: '7d34deae112841fba86e3e6cf08f5398dda323a8e4d29332621534e2c4069e8d',\r\n       cipherparams: { iv: '497f4d26997a84d570778eae874b2333' },\r\n       cipher: 'aes-128-ctr',\r\n       kdf: 'scrypt',\r\n       kdfparams:\r\n        { dklen: 32,\r\n          salt: '208dd732a27aa4803bb760228dff18515d5313fd085bbce60594a3919ae2d88d',\r\n          n: 262144,\r\n          r: 8,\r\n          p: 1 },\r\n       mac: '0062a853de302513c57bfe3108ab493733034bf3cb313326f42cf26ea2619cf9' } },\r\n     { version: 3,\r\n    id: '7d6b91fa-3611-407b-b16b-396efb28f97e',\r\n    address: 'b5d89661b59a9af0b34f58d19138baa2de48baaf',\r\n    crypto:\r\n     { ciphertext: 'cb9712d1982ff89f571fa5dbef447f14b7e5f142232bd2a913aac833730eeb43',\r\n       cipherparams: { iv: '8cccb91cb84e435437f7282ec2ffd2db' },\r\n       cipher: 'aes-128-ctr',\r\n       kdf: 'scrypt',\r\n       kdfparams:\r\n        { dklen: 32,\r\n          salt: '08ba6736363c5586434cd5b895e6fe41ea7db4785bd9b901dedce77a1514e8b8',\r\n          n: 262144,\r\n          r: 8,\r\n          p: 1 },\r\n       mac: 'd2eb068b37e2df55f56fa97a2bf4f55e072bef0dd703bfd917717d9dc54510f0' } }\r\n  ], 'test');\r\n  > Wallet {\r\n      0: {...},\r\n      1: {...},\r\n      \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\": {...},\r\n      \"0xD0122fC8DF283027b6285cc889F5aA624EaC1d23\": {...}\r\n      ...\r\n  }\r\n */\n\n\nWallet.prototype.decrypt = function (encryptedWallet, password) {\n  const _this = this;\n\n  encryptedWallet.forEach(function (keystore) {\n    const account = _this._accounts.decrypt(keystore, password);\n\n    if (!account) {\n      throw new Error(\"Couldn't decrypt the keystore. Maybe wrong password?\");\n    }\n\n    const exist = !!_this[account.address];\n\n    if (!exist) {\n      _this.add(account);\n    }\n  });\n  return this;\n};\n\nWallet.prototype.save = function (password, keyName) {\n  /* eslint-disable-next-line no-undef */\n  localStorage.setItem(keyName || this.defaultKeyName, JSON.stringify(this.encrypt(password)));\n  return true;\n};\n/**\r\n * cav.klay.accounts.wallet.load('test#!$', 'myWalletKey' || 'web3js_wallet');\r\n    > Wallet {\r\n        0: {...},\r\n        1: {...},\r\n        \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\": {...},\r\n        \"0xD0122fC8DF283027b6285cc889F5aA624EaC1d23\": {...}\r\n        ...\r\n    }\r\n */\n\n\nWallet.prototype.load = function (password, keyName) {\n  /* eslint-disable-next-line no-undef */\n  let keystore = localStorage.getItem(keyName || this.defaultKeyName);\n\n  if (keystore) {\n    try {\n      keystore = JSON.parse(keystore);\n    } catch (e) {}\n  }\n\n  return this.decrypt(keystore || [], password);\n};\n\nif (!storageAvailable('localStorage')) {\n  delete Wallet.prototype.save;\n  delete Wallet.prototype.load;\n}\n/**\r\n * Checks whether a storage type is available or not\r\n * For more info on how this works, please refer to MDN documentation\r\n * https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API#Feature-detecting_localStorage\r\n *\r\n * @method storageAvailable\r\n * @param {String} type the type of storage ('localStorage', 'sessionStorage')\r\n * @returns {Boolean} a boolean indicating whether the specified storage is available or not\r\n */\n\n\nfunction storageAvailable(type) {\n  let storage;\n\n  try {\n    // eslint-disable-next-line no-undef\n    storage = window[type];\n    const x = '__storage_test__';\n    storage.setItem(x, x);\n    storage.removeItem(x);\n    return true;\n  } catch (e) {\n    return e && ( // everything except Firefox\n    e.code === 22 || // Firefox\n    e.code === 1014 || // test name field too, because code might not be present\n    // everything except Firefox\n    e.name === 'QuotaExceededError' || // Firefox\n    e.name === 'NS_ERROR_DOM_QUOTA_REACHED') && // acknowledge QuotaExceededError only if there's something already stored\n    storage && storage.length !== 0;\n  }\n}\n\nWallet.prototype.getKlaytnWalletKey = function (addressOrIndex) {\n  const account = this[addressOrIndex];\n  if (!account) throw new Error('Failed to find account');\n  return genKlaytnWalletKeyStringFromAccount(account);\n};\n\nWallet.prototype.getAccount = function (input) {\n  if (_.isNumber(input)) {\n    if (this.length <= input) {\n      throw new Error(`The index(${input}) is out of range(Wallet length : ${this.length}).`);\n    }\n\n    return this[input];\n  }\n\n  if (!_.isString(input)) {\n    throw new Error(`Accounts in the Wallet can be searched by only index or address. :${input}`);\n  }\n\n  if (!utils.isAddress(input)) {\n    throw new Error(`Failed to getAccount from Wallet: invalid address(${input})`);\n  }\n\n  return this[input.toLowerCase()];\n};\n\nfunction genKlaytnWalletKeyStringFromAccount(account) {\n  if (account.accountKeyType !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) {\n    throw new Error('The account cannot be exported in KlaytnWalletKey format. Use caver.klay.accounts.encrypt or account.encrypt.');\n  }\n\n  let addressString = account.address;\n  let {\n    privateKey\n  } = account;\n  privateKey = privateKey.slice(0, 2) === '0x' ? privateKey : `0x${privateKey}`;\n  addressString = addressString.slice(0, 2) === '0x' ? addressString : `0x${addressString}`;\n  return `${privateKey}0x00${addressString}`;\n}\n\nmodule.exports = Accounts;","map":{"version":3,"names":["_","require","Promise","AccountLib","Hash","RLP","Nat","Bytes","cryp","global","uuid","elliptic","scrypt","utils","helpers","Method","core","encodeRLPByTxType","makeRawTransaction","getSenderTxHash","decodeFromRawTransaction","splitFeePayer","extractSignatures","secp256k1","ec","AccountKeyPublic","AccountKeyMultiSig","AccountKeyRoleBased","AccountKeyEnum","Account","AccountForUpdate","rpc","isNot","value","isUndefined","isNull","coverInitialTxValue","tx","Error","senderRawTransaction","type","includes","to","data","addHexPrefix","chainId","numberToHex","resolveArgsForSignTransaction","args","length","privateKey","callback","isObject","isString","isFunction","isArray","resolveArgsForFeePayerSignTransaction","feePayer","isAddress","resolveArgsForSignTransactionWithHash","hash","privateKeys","isValidHashStrict","Array","isNumber","encryptKey","password","options","encryptedArray","privateKeyArray","i","salt","randomBytes","iv","derivedKey","kdf","kdfparams","dklen","toString","c","prf","pbkdf2Sync","Buffer","from","n","r","p","syncScrypt","cipher","createCipheriv","slice","ciphertext","update","replace","final","mac","sha3","push","cipherparams","Accounts","_this","packageInit","BatchRequest","extend","_klaytnCall","getChainId","getGasPrice","getTransactionCount","getHeader","each","method","attachToObject","setRequestManager","_requestManager","wallet","Wallet","prototype","_addAccountFunctions","account","signTransaction","roleKey","_getRoleKey","feePayerSignTransaction","address","feePayerKey","sign","encrypt","keys","getKlaytnWalletKey","genKlaytnWalletKeyStringFromAccount","_determineAddress","legacyAccount","addressFromKey","userInputAddress","key","updateKey","transactionKey","_suggestGasPrice","gasPrice","create","entropy","fromObject","randomHex","createAccountKey","accountKey","isAccountKey","createAccountKeyPublic","createAccountKeyMultiSig","createAccountKeyRoleBased","parsed","parsePrivateKey","isValidPrivateKey","keyObject","accountKeyToPublicKey","toPublicKey","privateKeyToPublicKey","createWithAccountKey","createWithAccountKeyPublic","ACCOUNT_KEY_PUBLIC","createWithAccountKeyMultiSig","ACCOUNT_KEY_MULTISIG","createWithAccountKeyRoleBased","ACCOUNT_KEY_ROLEBASED","privateKeyToAccount","klaytnWalletKeyAddress","getLegacyAccount","toLowerCase","createAccountForUpdate","legacyOrFail","Object","map","role","publicKey","undefined","assign","createAccountForUpdateWithPublicKey","keyForUpdate","createAccountForUpdateWithLegacyKey","createAccountForUpdateWithFailKey","isDecoupled","actualAddress","fromPrivate","isLegacy","isFeePayer","existedSenderSignatures","existedFeePayerSignatures","result","handleError","e","reject","resolved","arguments","error","validateFunction","validateParams","feePayerSignatures","concat","signatures","getAccount","signed","txObject","formatters","inputCallFormatter","transaction","rlpEncoded","messageHash","keccak256","sigs","signature","makeSigner","toNumber","v","s","decodeSignature","sig","makeEven","trimLeadingZero","rawTransaction","txHash","senderTxHash","nonce","resolve","all","then","JSON","stringify","signTransactionWithHash","signWithHash","transactionHash","prvKeys","chain","callbackFunc","transformSignaturesToObject","id","getRawTransactionWithSignatures","decoded","isEmptySig","combineSignatures","rawTransactions","decodedTx","senders","feePayers","raw","senderSignatures","decodedTransaction","isSame","parsedTxObject","recoverTransaction","rawTx","getTxTypeStringFromRawTransaction","values","decode","arr","unshift","encodeSignature","recovery","extraData","fromNumber","signingData","signingDataHex","encode","recover","hashMessage","message","isHexStrict","hexToBytes","messageBuffer","preamble","preambleBuffer","klayMessage","preFixed","apply","isBoolean","decrypt","v3Keystore","nonStrict","json","cloneDeep","parse","version","console","warn","crypto","keyring","decryptKey","decryptedArray","encrypted","decipher","createDecipheriv","accountKeyType","v4","random","encryptV3","notSupportedType","compressed","buffer","ecKey","keyFromPrivate","getPublic","setAccounts","accounts","clear","add","_accounts","defaultKeyName","lastIndex","_findSafeIndex","pointer","has","_findSafeLastIndex","_currentIndexes","indexes","parseInt","filter","numberOfAccounts","accountForWallet","index","toUpperCase","toChecksumAddress","updatePrivateKey","accountExists","newAccountKeyPublic","updateAccountKey","remove","addressOrIndex","forEach","encryptedWallet","keystore","exist","save","keyName","localStorage","setItem","load","getItem","storageAvailable","storage","window","x","removeItem","code","name","input","addressString","module","exports"],"sources":["C:/Users/User/Documents/clone-starter-kit-08/node_modules/caver-js/packages/caver-klay/caver-klay-accounts/src/index.js"],"sourcesContent":["/*\r\n    Modifications copyright 2018 The caver-js Authors\r\n    This file is part of web3.js.\r\n\r\n    web3.js is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    web3.js is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n    This file is derived from web3.js/packages/web3-eth-accounts/src/index.js (2019/06/12).\r\n    Modified and improved for the caver-js development.\r\n*/\r\n/**\r\n * @file accounts.js\r\n * @author Fabian Vogelsteller <fabian@ethereum.org>\r\n * @date 2017\r\n */\r\n\r\nconst _ = require('lodash')\r\nconst Promise = require('any-promise')\r\n// account, hash, rlp, nat, bytes library will be used from 'eth-lib' temporarily.\r\nconst AccountLib = require('eth-lib/lib/account')\r\nconst Hash = require('eth-lib/lib/hash')\r\nconst RLP = require('eth-lib/lib/rlp')\r\nconst Nat = require('eth-lib/lib/nat')\r\nconst Bytes = require('eth-lib/lib/bytes')\r\nconst cryp = typeof global === 'undefined' ? require('crypto-browserify') : require('crypto')\r\nconst uuid = require('uuid')\r\nconst elliptic = require('elliptic')\r\nconst scrypt = require('scrypt-js')\r\nconst utils = require('../../../caver-utils')\r\nconst helpers = require('../../../caver-core-helpers')\r\n\r\nconst Method = require('../../../caver-core-method')\r\nconst core = require('../../../caver-core')\r\nconst {\r\n    encodeRLPByTxType,\r\n    makeRawTransaction,\r\n    getSenderTxHash,\r\n    decodeFromRawTransaction,\r\n    splitFeePayer,\r\n    extractSignatures,\r\n} = require('./makeRawTransaction')\r\n\r\nconst secp256k1 = new elliptic.ec('secp256k1')\r\n\r\nconst AccountKeyPublic = require('./accountKey/accountKeyPublic')\r\nconst AccountKeyMultiSig = require('./accountKey/accountKeyMultiSig')\r\nconst AccountKeyRoleBased = require('./accountKey/accountKeyRoleBased')\r\nconst { AccountKeyEnum } = require('./accountKey/accountKeyEnum')\r\n\r\nconst Account = require('./account/account')\r\nconst AccountForUpdate = require('./account/accountForUpdate')\r\n\r\nconst { rpc } = require('../../../caver-rtm')\r\n\r\nconst isNot = function(value) {\r\n    return _.isUndefined(value) || _.isNull(value)\r\n}\r\n\r\nfunction coverInitialTxValue(tx) {\r\n    if (typeof tx !== 'object') throw new Error('Invalid transaction')\r\n    if (!tx.senderRawTransaction && (!tx.type || tx.type === 'LEGACY' || tx.type.includes('SMART_CONTRACT_DEPLOY'))) {\r\n        tx.to = tx.to || '0x'\r\n        tx.data = utils.addHexPrefix(tx.data || '0x')\r\n    }\r\n    tx.chainId = utils.numberToHex(tx.chainId)\r\n    return tx\r\n}\r\n\r\n/**\r\n * resolveArgsForSignTransaction parse arguments for signTransaction.\r\n *\r\n * @method resolveArgsForSignTransaction\r\n * @param {Object} args Parameters of signTransaction.\r\n * @return {Object}\r\n */\r\nfunction resolveArgsForSignTransaction(args) {\r\n    if (args.length === 0 || args.length > 3) {\r\n        throw new Error('Invalid parameter: The number of parameters is invalid.')\r\n    }\r\n\r\n    // privateKey and callback are optional parameter\r\n    // \"args.length === 2\" means that user sent parameter privateKey or callback\r\n    const tx = args[0]\r\n    let privateKey\r\n    let callback\r\n\r\n    if (!tx || (!_.isObject(tx) && !_.isString(tx))) {\r\n        throw new Error('Invalid parameter: The transaction must be defined as an object or RLP encoded string')\r\n    }\r\n\r\n    if (args.length === 2) {\r\n        if (_.isFunction(args[1])) {\r\n            callback = args[1]\r\n        } else {\r\n            privateKey = args[1]\r\n        }\r\n    } else if (args.length === 3) {\r\n        if (args[1] && typeof args[1] !== 'string' && !_.isArray(args[1])) {\r\n            throw new Error('Invalid parameter: The parameter for the private key is invalid')\r\n        }\r\n        privateKey = args[1]\r\n        callback = args[2]\r\n    }\r\n\r\n    // For handling when callback is undefined.\r\n    callback = callback || function() {}\r\n\r\n    return { tx, privateKey, callback }\r\n}\r\n\r\n/**\r\n * resolveArgsForFeePayerSignTransaction parse arguments for feePayerSignTransaction.\r\n *\r\n * @method resolveArgsForFeePayerSignTransaction\r\n * @param {Object} args Parameters of feePayerSignTransaction.\r\n * @return {Object}\r\n */\r\nfunction resolveArgsForFeePayerSignTransaction(args) {\r\n    if (args.length === 0 || args.length > 4) {\r\n        throw new Error('Invalid parameter: The number of parameters is invalid.')\r\n    }\r\n\r\n    // privateKey and callback are optional parameter\r\n    // \"args.length === 3\" means that user sent parameter privateKey or callback\r\n    const tx = args[0]\r\n    const feePayer = args[1]\r\n    let privateKey\r\n    let callback\r\n\r\n    if (!tx || (!_.isObject(tx) && !_.isString(tx))) {\r\n        throw new Error('Invalid parameter: The transaction must be defined as an object or RLP encoded string')\r\n    }\r\n\r\n    if (!utils.isAddress(feePayer)) {\r\n        throw new Error(`Invalid fee payer address : ${feePayer}`)\r\n    }\r\n\r\n    if (args.length === 3) {\r\n        if (_.isFunction(args[2])) {\r\n            callback = args[2]\r\n        } else {\r\n            privateKey = args[2]\r\n        }\r\n    } else if (args.length === 4) {\r\n        if (args[2] && typeof args[2] !== 'string' && !_.isArray(args[2])) {\r\n            throw new Error('Invalid parameter: The parameter for the private key is invalid')\r\n        }\r\n        privateKey = args[2]\r\n        callback = args[3]\r\n    }\r\n\r\n    // For handling when callback is undefined.\r\n    callback = callback || function() {}\r\n\r\n    return { tx, privateKey, feePayer, callback }\r\n}\r\n\r\n/**\r\n * resolveArgsForSignTransactionWithHash parse arguments for signTransactionWithHash.\r\n *\r\n * @method resolveArgsForSignTransactionWithHash\r\n * @param {Object} args Parameters of signTransactionWithHash.\r\n * @return {Object}\r\n */\r\nfunction resolveArgsForSignTransactionWithHash(args) {\r\n    if (args.length < 2 || args.length > 4) {\r\n        throw new Error('Invalid parameter: The number of parameters is invalid.')\r\n    }\r\n\r\n    const hash = args[0]\r\n    const privateKeys = args[1]\r\n    let chainId\r\n    let callback\r\n\r\n    if (!hash) {\r\n        throw new Error('Invalid parameter: The hash of transaction must be defined as a parameter.')\r\n    }\r\n\r\n    if (!utils.isValidHashStrict(hash)) {\r\n        throw new Error('Invalid parameter: The hash of transaction must be 0x-hex prefixed string format.')\r\n    }\r\n\r\n    if (!privateKeys || (!Array.isArray(privateKeys) && !_.isString(privateKeys))) {\r\n        throw new Error(`Invalid parameter: The private key should be a private key string or an array of private keys.`)\r\n    }\r\n\r\n    if (args.length === 3) {\r\n        if (_.isFunction(args[2])) {\r\n            callback = args[2]\r\n        } else {\r\n            chainId = args[2]\r\n        }\r\n    } else if (args.length === 4) {\r\n        if (args[2] && !_.isString(args[2]) && !_.isNumber(args[2])) {\r\n            throw new Error('Invalid parameter: The parameter for the chain id is invalid.')\r\n        }\r\n        chainId = args[2]\r\n        callback = args[3]\r\n    }\r\n\r\n    // For handling when callback is undefined.\r\n    callback = callback || function() {}\r\n\r\n    return { hash, privateKeys, chainId, callback }\r\n}\r\n\r\nfunction encryptKey(privateKey, password, options) {\r\n    const encryptedArray = []\r\n\r\n    if (!privateKey) return encryptedArray\r\n\r\n    const privateKeyArray = _.isArray(privateKey) ? privateKey : [privateKey]\r\n\r\n    for (let i = 0; i < privateKeyArray.length; i++) {\r\n        const salt = options.salt || cryp.randomBytes(32)\r\n        const iv = options.iv || cryp.randomBytes(16)\r\n\r\n        let derivedKey\r\n        const kdf = options.kdf || 'scrypt'\r\n        const kdfparams = {\r\n            dklen: options.dklen || 32,\r\n            salt: salt.toString('hex'),\r\n        }\r\n\r\n        /**\r\n         * Supported kdf modules are the following:\r\n         * 1) pbkdf2\r\n         * 2) scrypt - default\r\n         */\r\n        if (kdf === 'pbkdf2') {\r\n            kdfparams.c = options.c || 262144\r\n            kdfparams.prf = 'hmac-sha256'\r\n            derivedKey = cryp.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256')\r\n        } else if (kdf === 'scrypt') {\r\n            // FIXME: support progress reporting callback\r\n            kdfparams.n = options.n || 4096 // 2048 4096 8192 16384\r\n            kdfparams.r = options.r || 8\r\n            kdfparams.p = options.p || 1\r\n            derivedKey = scrypt.syncScrypt(\r\n                Buffer.from(password),\r\n                Buffer.from(kdfparams.salt, 'hex'),\r\n                kdfparams.n,\r\n                kdfparams.r,\r\n                kdfparams.p,\r\n                kdfparams.dklen\r\n            )\r\n        } else {\r\n            throw new Error('Unsupported kdf')\r\n        }\r\n\r\n        const cipher = cryp.createCipheriv(options.cipher || 'aes-128-ctr', derivedKey.slice(0, 16), iv)\r\n        if (!cipher) {\r\n            throw new Error('Unsupported cipher')\r\n        }\r\n\r\n        const ciphertext = Buffer.from([...cipher.update(Buffer.from(privateKeyArray[i].replace('0x', ''), 'hex')), ...cipher.final()])\r\n\r\n        const mac = utils.sha3(Buffer.from([...derivedKey.slice(16, 32), ...ciphertext])).replace('0x', '')\r\n\r\n        encryptedArray.push({\r\n            ciphertext: ciphertext.toString('hex'),\r\n            cipherparams: {\r\n                iv: iv.toString('hex'),\r\n            },\r\n            cipher: options.cipher || 'aes-128-ctr',\r\n            kdf,\r\n            kdfparams,\r\n            mac: mac.toString('hex'),\r\n        })\r\n    }\r\n\r\n    return encryptedArray\r\n}\r\n\r\nconst Accounts = function Accounts(...args) {\r\n    const _this = this\r\n\r\n    // sets _requestmanager\r\n    core.packageInit(this, args)\r\n\r\n    // remove unecessary core functions\r\n    delete this.BatchRequest\r\n    delete this.extend\r\n\r\n    const _klaytnCall = [rpc.getChainId, rpc.getGasPrice, rpc.getTransactionCount, rpc.getHeader]\r\n    // attach methods to this._klaytnCall\r\n    this._klaytnCall = {}\r\n    _.each(_klaytnCall, function(method) {\r\n        method = new Method(method)\r\n        method.attachToObject(_this._klaytnCall)\r\n        method.setRequestManager(_this._requestManager)\r\n    })\r\n\r\n    this.wallet = new Wallet(this)\r\n}\r\n\r\nAccounts.prototype._addAccountFunctions = function(account) {\r\n    const _this = this\r\n\r\n    // add sign functions\r\n    account.signTransaction = function signTransaction(tx, callback) {\r\n        const roleKey = _this._getRoleKey(tx, account)\r\n        return _this.signTransaction(tx, roleKey, callback)\r\n    }\r\n\r\n    account.feePayerSignTransaction = function feePayerSignTransaction(tx, callback) {\r\n        return _this.feePayerSignTransaction(tx, account.address, account.feePayerKey, callback)\r\n    }\r\n\r\n    account.sign = function sign(data) {\r\n        return _this.sign(data, account.privateKey)\r\n    }\r\n\r\n    account.encrypt = function encrypt(password, options = {}) {\r\n        options.address = account.address\r\n        return _this.encrypt(account.keys, password, options)\r\n    }\r\n\r\n    account.getKlaytnWalletKey = function getKlaytnWalletKey() {\r\n        return genKlaytnWalletKeyStringFromAccount(account)\r\n    }\r\n\r\n    return account\r\n}\r\n\r\n/**\r\n * _determineAddress determines the priority of the parameters entered and returns the address that should be used for the account.\r\n *\r\n * @method _determineAddress\r\n * @param {Object} legacyAccount Account with a legacy account key extracted from private key to be used for address determination.\r\n * @param {String} addressFromKey Address extracted from key.\r\n * @param {String} userInputAddress Address passed as parameter by user.\r\n * @return {String}\r\n */\r\nAccounts.prototype._determineAddress = function _determineAddress(legacyAccount, addressFromKey, userInputAddress) {\r\n    if (userInputAddress) {\r\n        if (addressFromKey && addressFromKey !== userInputAddress) {\r\n            throw new Error('The address extracted from the private key does not match the address received as the input value.')\r\n        }\r\n\r\n        if (!utils.isAddress(userInputAddress)) {\r\n            throw new Error('The address received as the input value is invalid.')\r\n        }\r\n        return userInputAddress\r\n    }\r\n    if (addressFromKey) {\r\n        if (!utils.isAddress(addressFromKey)) {\r\n            throw new Error('The address extracted from the private key is invalid.')\r\n        }\r\n        // If userInputAddress is undefined and address which is came from private is existed, set address in account.\r\n        return addressFromKey\r\n    }\r\n    return legacyAccount.address\r\n}\r\n\r\n/**\r\n * _getRoleKey returns a key that matches the role that should be used according to the transaction.\r\n *\r\n * @method _getRoleKey\r\n * @param {Object} tx transaction object to be sign.\r\n * @param {Object} account Account to be used for signing.\r\n * @return {String|Array}\r\n */\r\nAccounts.prototype._getRoleKey = function _getRoleKey(tx, account) {\r\n    let key\r\n\r\n    if (!account) {\r\n        throw new Error('The account to be used for signing is not defined.')\r\n    }\r\n\r\n    if (tx.senderRawTransaction && tx.feePayer) {\r\n        key = account.feePayerKey\r\n    } else if (tx.type && tx.type.includes('ACCOUNT_UPDATE')) {\r\n        key = account.updateKey\r\n    } else {\r\n        key = account.transactionKey\r\n    }\r\n\r\n    if (!key) {\r\n        throw new Error('The key corresponding to the role used for signing is not defined.')\r\n    }\r\n\r\n    return key\r\n}\r\n\r\n/**\r\n * _suggestGasPrice suggests a gas price.\r\n * This function will be used to set gasPrice field if that is omitted.\r\n * Before common architecture does not support newly added transaction types.\r\n *\r\n * @method _suggestGasPrice\r\n * @return {string}\r\n */\r\nAccounts.prototype._suggestGasPrice = async function _suggestGasPrice() {\r\n    const gasPrice = await this._klaytnCall.getGasPrice()\r\n    return gasPrice\r\n}\r\n\r\n/**\r\n * create function creates random account with entropy.\r\n *\r\n * @method create\r\n * @param {Object} entropy A random string to increase entropy.\r\n * @return {Object}\r\n */\r\nAccounts.prototype.create = function create(entropy) {\r\n    return this._addAccountFunctions(Account.fromObject(AccountLib.create(entropy || utils.randomHex(32))))\r\n}\r\n\r\n/**\r\n * createAccountKey creates AccountKeyPublic, AccountKeyMultiSig or AccountKeyRoleBased instance with parameter.\r\n *\r\n * @method createAccountKey\r\n * @param {String|Array|Object} accountKey Parameters to be used when creating the AccountKey.\r\n * @return {Object}\r\n */\r\nAccounts.prototype.createAccountKey = function createAccountKey(accountKey) {\r\n    if (Account.isAccountKey(accountKey)) accountKey = accountKey.keys\r\n\r\n    if (_.isString(accountKey)) {\r\n        accountKey = this.createAccountKeyPublic(accountKey)\r\n    } else if (_.isArray(accountKey)) {\r\n        accountKey = this.createAccountKeyMultiSig(accountKey)\r\n    } else if (_.isObject(accountKey)) {\r\n        accountKey = this.createAccountKeyRoleBased(accountKey)\r\n    } else {\r\n        throw new Error(`Invalid accountKey type: ${typeof accountKey}`)\r\n    }\r\n    return accountKey\r\n}\r\n\r\n/**\r\n * createAccountKeyPublic creates AccountKeyPublic with a string of private key.\r\n *\r\n * @method createAccountKeyPublic\r\n * @param {String} privateKey Private key string that will be used to create AccountKeyPublic.\r\n * @return {Object}\r\n */\r\nAccounts.prototype.createAccountKeyPublic = function createAccountKeyPublic(privateKey) {\r\n    if (privateKey instanceof AccountKeyPublic) return privateKey\r\n\r\n    if (!_.isString(privateKey)) {\r\n        throw new Error('Creating a AccountKeyPublic requires a private key string.')\r\n    }\r\n\r\n    const parsed = utils.parsePrivateKey(privateKey)\r\n    privateKey = parsed.privateKey\r\n\r\n    if (!utils.isValidPrivateKey(privateKey)) {\r\n        throw new Error(`Failed to create AccountKeyPublic. Invalid private key : ${privateKey}`)\r\n    }\r\n\r\n    return new AccountKeyPublic(privateKey)\r\n}\r\n\r\n/**\r\n * createAccountKeyMultiSig creates AccountKeyMultiSig with an array of private keys.\r\n *\r\n * @method createAccountKeyMultiSig\r\n * @param {Array} privateKeys An Array of private key strings that will be used to create AccountKeyMultiSig.\r\n * @return {Object}\r\n */\r\nAccounts.prototype.createAccountKeyMultiSig = function createAccountKeyMultiSig(privateKeys) {\r\n    if (privateKeys instanceof AccountKeyMultiSig) return privateKeys\r\n\r\n    if (!_.isArray(privateKeys)) {\r\n        throw new Error('Creating a AccountKeyMultiSig requires an array of private key string.')\r\n    }\r\n\r\n    for (let i = 0; i < privateKeys.length; i++) {\r\n        const parsed = utils.parsePrivateKey(privateKeys[i])\r\n        const p = parsed.privateKey\r\n        if (!utils.isValidPrivateKey(p)) {\r\n            throw new Error(`Failed to create AccountKeyMultiSig. Invalid private key : ${p}`)\r\n        }\r\n    }\r\n\r\n    return new AccountKeyMultiSig(privateKeys)\r\n}\r\n\r\n/**\r\n * createAccountKeyRoleBased creates AccountKeyRoleBased with an object of key.\r\n *\r\n * @method createAccountKeyRoleBased\r\n * @param {Object} keyObject Object that defines key for each role to use when creating AccountKeyRoleBased.\r\n * @return {Object}\r\n */\r\nAccounts.prototype.createAccountKeyRoleBased = function createAccountKeyRoleBased(keyObject) {\r\n    if (keyObject instanceof AccountKeyRoleBased) return keyObject\r\n\r\n    if (!_.isObject(keyObject) || _.isArray(keyObject)) {\r\n        throw new Error('Creating a AccountKeyRoleBased requires an object.')\r\n    }\r\n\r\n    return new AccountKeyRoleBased(keyObject)\r\n}\r\n\r\n/**\r\n * accountKeyToPublicKey creates public key format with AccountKey.\r\n *\r\n * @method accountKeyToPublicKey\r\n * @param {Object} accountKey AccountKey instance for which you want to generate a public key format.\r\n * @return {String|Array|Object}\r\n */\r\nAccounts.prototype.accountKeyToPublicKey = function accountKeyToPublicKey(accountKey) {\r\n    accountKey = this.createAccountKey(accountKey)\r\n    return accountKey.toPublicKey(this.privateKeyToPublicKey)\r\n}\r\n\r\n/**\r\n * createWithAccountKey creates Account instance with AccountKey.\r\n *\r\n * @method createWithAccountKey\r\n * @param {String} address The address of account.\r\n * @param {String|Array|Object} accountKey The accountKey of account.\r\n * @return {Object}\r\n */\r\nAccounts.prototype.createWithAccountKey = function createWithAccountKey(address, accountKey) {\r\n    const account = new Account(address, this.createAccountKey(accountKey))\r\n    return this._addAccountFunctions(account)\r\n}\r\n\r\n/**\r\n * createWithAccountKeyPublic create an account with AccountKeyPublic.\r\n *\r\n * @method createWithAccountKeyPublic\r\n * @param {String} address An address of account.\r\n * @param {String|Object} key Key of account.\r\n * @return {Object}\r\n */\r\nAccounts.prototype.createWithAccountKeyPublic = function createWithAccountKeyPublic(address, key) {\r\n    if (!Account.isAccountKey(key)) key = this.createAccountKeyPublic(key)\r\n\r\n    if (key.type !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) {\r\n        throw new Error(`Failed to create account with AccountKeyPublic. Invalid account key : ${key.type}`)\r\n    }\r\n\r\n    const account = new Account(address, key)\r\n    return this._addAccountFunctions(account)\r\n}\r\n\r\n/**\r\n * createWithAccountKeyMultiSig create an account with AccountKeyMultiSig.\r\n *\r\n * @method createWithAccountKeyMultiSig\r\n * @param {String} address An address of account.\r\n * @param {String|Object} keys Key of account.\r\n * @return {Object}\r\n */\r\nAccounts.prototype.createWithAccountKeyMultiSig = function createWithAccountKeyMultiSig(address, keys) {\r\n    if (!Account.isAccountKey(keys)) keys = this.createAccountKeyMultiSig(keys)\r\n\r\n    if (keys.type !== AccountKeyEnum.ACCOUNT_KEY_MULTISIG) {\r\n        throw new Error(`Failed to create account with AccountKeyMultiSig. Invalid account key : ${keys.type}`)\r\n    }\r\n\r\n    const account = new Account(address, keys)\r\n    return this._addAccountFunctions(account)\r\n}\r\n\r\n/**\r\n * createWithAccountKeyRoleBased create an account with AccountKeyRoleBased.\r\n *\r\n * @method createWithAccountKeyRoleBased\r\n * @param {String} address An address of account.\r\n * @param {String|Object} keyObject Key of account.\r\n * @return {Object}\r\n */\r\nAccounts.prototype.createWithAccountKeyRoleBased = function createWithAccountKeyRoleBased(address, keyObject) {\r\n    if (!Account.isAccountKey(keyObject)) {\r\n        keyObject = this.createAccountKeyRoleBased(keyObject)\r\n    }\r\n\r\n    if (keyObject.type !== AccountKeyEnum.ACCOUNT_KEY_ROLEBASED) {\r\n        throw new Error(`Failed to create account with AccountKeyRoleBased. Invalid account key : ${keyObject.type}`)\r\n    }\r\n\r\n    const account = new Account(address, keyObject)\r\n    return this._addAccountFunctions(account)\r\n}\r\n\r\n/**\r\n * privateKeyToAccount creates and returns an Account through the input passed as parameters.\r\n *\r\n * @method privateKeyToAccount\r\n * @param {String} key The key parameter can be either normal private key or KlaytnWalletKey format.\r\n * @param {String} userInputAddress The address entered by the user for use in creating an account.\r\n * @return {Object}\r\n */\r\nAccounts.prototype.privateKeyToAccount = function privateKeyToAccount(key, userInputAddress) {\r\n    const { legacyAccount: account, klaytnWalletKeyAddress } = this.getLegacyAccount(key)\r\n\r\n    account.address = this._determineAddress(account, klaytnWalletKeyAddress, userInputAddress)\r\n    account.address = account.address.toLowerCase()\r\n    account.address = utils.addHexPrefix(account.address)\r\n\r\n    return account\r\n}\r\n\r\n/**\r\n * createAccountForUpdate creates an AccountForUpdate instance.\r\n * The AccountForUpdate returned as a result of this function contains only the address and public key used to update the account.\r\n *\r\n * @method createAccountForUpdate\r\n * @param {String} address The address value of AccountForUpdate, a structure that contains data for updating an account.\r\n * @param {String|Array|Object} accountKey Private key or AccountKey to update account.\r\n * @param {Object} options Options to use for setting threshold and weight for multiSig.\r\n * @return {Object}\r\n */\r\nAccounts.prototype.createAccountForUpdate = function createAccountForUpdate(address, accountKey, options) {\r\n    let legacyOrFail\r\n\r\n    // Logic for handling cases where legacyKey or failKey is set inside AccountKeyRoleBased object.\r\n    if (!_.isArray(accountKey) && _.isObject(accountKey)) {\r\n        legacyOrFail = {}\r\n        Object.keys(accountKey).map(role => {\r\n            if (accountKey[role] === 'legacyKey' || accountKey[role] === 'failKey') {\r\n                legacyOrFail[role] = accountKey[role]\r\n                delete accountKey[role]\r\n            }\r\n        })\r\n        if (Object.keys(accountKey).length === 0) {\r\n            return new AccountForUpdate(address, legacyOrFail, options)\r\n        }\r\n    }\r\n\r\n    const publicKey = this.accountKeyToPublicKey(accountKey)\r\n\r\n    if (legacyOrFail !== undefined) {\r\n        Object.assign(publicKey, legacyOrFail)\r\n    }\r\n\r\n    return new AccountForUpdate(address, publicKey, options)\r\n}\r\n\r\n/**\r\n * createAccountForUpdateWithPublicKey creates AccountForUpdate instance with public key format.\r\n *\r\n * @method createAccountForUpdateWithPublicKey\r\n * @param {String} address The address value of AccountForUpdate, a structure that contains data for updating an account.\r\n * @param {String|Array|Object} keyForUpdate Public key to update.\r\n * @param {Object} options Options to use for setting threshold and weight for multiSig.\r\n * @return {Object}\r\n */\r\nAccounts.prototype.createAccountForUpdateWithPublicKey = function createAccountForUpdateWithPublicKey(address, keyForUpdate, options) {\r\n    return new AccountForUpdate(address, keyForUpdate, options)\r\n}\r\n\r\n/**\r\n * createAccountForUpdateWithLegacyKey creates AccountForUpdate instance with legacyKey.\r\n *\r\n * @method createAccountForUpdateWithLegacyKey\r\n * @param {String} address The address of account to update with the legacy key.\r\n * @return {Object}\r\n */\r\nAccounts.prototype.createAccountForUpdateWithLegacyKey = function createAccountForUpdateWithLegacyKey(address) {\r\n    return new AccountForUpdate(address, 'legacyKey')\r\n}\r\n\r\n/**\r\n * createAccountForUpdateWithFailKey creates AccountForUpdate instance with failKey.\r\n *\r\n * @method createAccountForUpdateWithFailKey\r\n * @param {String} address The address of account to update with the fail key.\r\n * @return {Object}\r\n */\r\nAccounts.prototype.createAccountForUpdateWithFailKey = function createAccountForUpdateWithFailKey(address) {\r\n    return new AccountForUpdate(address, 'failKey')\r\n}\r\n\r\n/**\r\n * isDecoupled determines whether or not it is decoupled based on the input value.\r\n *\r\n * @method isDecoupled\r\n * @param {String} key The key parameter can be either normal private key or KlaytnWalletKey format.\r\n * @param {String} userInputAddress The address to use when determining whether it is decoupled.\r\n * @return {Boolean}\r\n */\r\nAccounts.prototype.isDecoupled = function isDecoupled(key, userInputAddress) {\r\n    const { legacyAccount, klaytnWalletKeyAddress } = this.getLegacyAccount(key)\r\n    const actualAddress = this._determineAddress(legacyAccount, klaytnWalletKeyAddress, userInputAddress)\r\n\r\n    return legacyAccount.address.toLowerCase() !== actualAddress.toLowerCase()\r\n}\r\n\r\n/**\r\n * getLegacyAccount extracts the private key from the input key and returns an account with the corresponding legacy account key.\r\n * If the input key is KlaytnWalletKey format, it returns klaytnWalletKeyAddress, which is the address extracted from KlaytnWalletKey.\r\n *\r\n * @method getLegacyAccount\r\n * @param {String} key The key parameter can be either normal private key or KlaytnWalletKey format.\r\n * @return {Object}\r\n */\r\nAccounts.prototype.getLegacyAccount = function getLegacyAccount(key) {\r\n    const parsed = utils.parsePrivateKey(key)\r\n\r\n    if (!utils.isValidPrivateKey(parsed.privateKey)) {\r\n        throw new Error('Invalid private key')\r\n    }\r\n\r\n    const privateKey = utils.addHexPrefix(parsed.privateKey)\r\n\r\n    const account = this._addAccountFunctions(Account.fromObject(AccountLib.fromPrivate(privateKey)))\r\n\r\n    return { legacyAccount: account, klaytnWalletKeyAddress: parsed.address }\r\n}\r\n\r\n/**\r\n * signTransaction signs to transaction with private key.\r\n * If there are signatures(feePayerSignatures if the fee payer signs) in tx entered as a parameter,\r\n * the signatures(feePayerSignatures if the fee payer signs) are appended.\r\n *\r\n * @method signTransaction\r\n * @param {String|Object} tx The transaction to sign.\r\n * @param {String|Array} privateKey The private key to use for signing.\r\n * @param {Function} callback The callback function to call.\r\n * @return {Object}\r\n */\r\nAccounts.prototype.signTransaction = function signTransaction() {\r\n    const _this = this\r\n    let isLegacy = false\r\n    let isFeePayer = false\r\n    let existedSenderSignatures = []\r\n    let existedFeePayerSignatures = []\r\n    let result\r\n    let tx\r\n    let privateKey\r\n    let callback\r\n\r\n    const handleError = e => {\r\n        e = e instanceof Error ? e : new Error(e)\r\n        if (callback) callback(e)\r\n        return Promise.reject(e)\r\n    }\r\n\r\n    try {\r\n        const resolved = resolveArgsForSignTransaction(arguments)\r\n        tx = resolved.tx\r\n        privateKey = resolved.privateKey\r\n        callback = resolved.callback\r\n    } catch (e) {\r\n        return handleError(e)\r\n    }\r\n\r\n    // If the user signs an RLP encoded transaction, tx is of type string.\r\n    if (_.isString(tx)) {\r\n        tx = decodeFromRawTransaction(tx)\r\n    }\r\n\r\n    // Validate tx object\r\n    const error = helpers.validateFunction.validateParams(tx)\r\n    if (error) return handleError(error)\r\n\r\n    if (tx.senderRawTransaction) {\r\n        if (tx.feePayerSignatures) {\r\n            existedFeePayerSignatures = existedFeePayerSignatures.concat(tx.feePayerSignatures)\r\n        }\r\n\r\n        try {\r\n            // Decode senderRawTransaction to get signatures of fee payer\r\n            const { senderRawTransaction, feePayer, feePayerSignatures } = splitFeePayer(tx.senderRawTransaction)\r\n\r\n            // feePayer !== '0x' means that in senderRawTransaction there are feePayerSignatures\r\n            if (feePayer !== '0x' && feePayer !== '0x0000000000000000000000000000000000000000') {\r\n                // The feePayer inside the tx object does not match the feePayer information contained in the senderRawTransaction.\r\n                if (feePayer.toLowerCase() !== tx.feePayer.toLowerCase()) {\r\n                    return handleError(\r\n                        `Invalid feePayer: The fee payer(${feePayer}) included in the transaction does not match the fee payer(${tx.feePayer}) you want to sign.`\r\n                    )\r\n                }\r\n                existedFeePayerSignatures = existedFeePayerSignatures.concat(feePayerSignatures)\r\n            }\r\n\r\n            tx.senderRawTransaction = senderRawTransaction\r\n            isFeePayer = true\r\n        } catch (e) {\r\n            return handleError(e)\r\n        }\r\n    } else {\r\n        isLegacy = !!(tx.type === undefined || tx.type === 'LEGACY')\r\n\r\n        if (tx.signatures) {\r\n            // if there is existed signatures or feePayerSignatures, those should be preserved.\r\n            if (isLegacy) {\r\n                return handleError('Legacy transaction cannot be signed with multiple keys.')\r\n            }\r\n            existedSenderSignatures = existedSenderSignatures.concat(tx.signatures)\r\n        }\r\n    }\r\n\r\n    // When privateKey is undefined, find Account from Wallet.\r\n    if (privateKey === undefined) {\r\n        try {\r\n            const account = this.wallet.getAccount(isFeePayer ? tx.feePayer : tx.from)\r\n            if (!account) {\r\n                return handleError(\r\n                    'Failed to find get private key to sign. The account you want to use for signing must exist in caver.klay.accounts.wallet or you must pass the private key as a parameter.'\r\n                )\r\n            }\r\n            privateKey = this._getRoleKey(tx, account)\r\n        } catch (e) {\r\n            return handleError(e)\r\n        }\r\n    }\r\n\r\n    const privateKeys = _.isArray(privateKey) ? privateKey : [privateKey]\r\n\r\n    try {\r\n        for (let i = 0; i < privateKeys.length; i++) {\r\n            const parsed = utils.parsePrivateKey(privateKeys[i])\r\n            privateKeys[i] = parsed.privateKey\r\n            privateKeys[i] = utils.addHexPrefix(privateKeys[i])\r\n\r\n            if (!utils.isValidPrivateKey(privateKeys[i])) {\r\n                return handleError('Invalid private key')\r\n            }\r\n        }\r\n    } catch (e) {\r\n        return handleError(e)\r\n    }\r\n\r\n    // Attempting to sign with a decoupled account into a legacy type transaction should be rejected.\r\n    if (isLegacy) {\r\n        if (privateKeys.length > 1) {\r\n            return handleError('Legacy transaction cannot signed with multiple keys')\r\n        }\r\n        if (_this.isDecoupled(privateKeys[0], tx.from)) {\r\n            return handleError('A legacy transaction must be with a legacy account key')\r\n        }\r\n    }\r\n\r\n    function signed(txObject) {\r\n        try {\r\n            // Guarantee all property in transaction is hex.\r\n            txObject = helpers.formatters.inputCallFormatter(txObject)\r\n\r\n            const transaction = coverInitialTxValue(txObject)\r\n\r\n            const rlpEncoded = encodeRLPByTxType(transaction)\r\n\r\n            const messageHash = Hash.keccak256(rlpEncoded)\r\n\r\n            const sigs = isFeePayer ? existedFeePayerSignatures : existedSenderSignatures\r\n\r\n            for (const p of privateKeys) {\r\n                const signature = AccountLib.makeSigner(Nat.toNumber(transaction.chainId || '0x1') * 2 + 35)(messageHash, p)\r\n                const [v, r, s] = AccountLib.decodeSignature(signature).map(sig => utils.makeEven(utils.trimLeadingZero(sig)))\r\n                sigs.push([v, r, s])\r\n            }\r\n            // makeRawTransaction will return signatures and feePayerSignatures with duplicates removed.\r\n            const { rawTransaction, signatures, feePayerSignatures } = makeRawTransaction(rlpEncoded, sigs, transaction)\r\n\r\n            result = {\r\n                messageHash,\r\n                v: sigs[0][0],\r\n                r: sigs[0][1],\r\n                s: sigs[0][2],\r\n                rawTransaction,\r\n                txHash: Hash.keccak256(rawTransaction),\r\n                senderTxHash: getSenderTxHash(rawTransaction),\r\n            }\r\n\r\n            if (isFeePayer) {\r\n                result.feePayerSignatures = feePayerSignatures\r\n            } else {\r\n                result.signatures = signatures\r\n            }\r\n        } catch (e) {\r\n            callback(e)\r\n            return Promise.reject(e)\r\n        }\r\n\r\n        callback(null, result)\r\n        return result\r\n    }\r\n\r\n    if (tx.nonce !== undefined && tx.chainId !== undefined && tx.gasPrice !== undefined) {\r\n        return Promise.resolve(signed(tx))\r\n    }\r\n\r\n    // When the feePayer signs a transaction, required information is only chainId.\r\n    if (isFeePayer) {\r\n        return Promise.all([isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId]).then(function(args) {\r\n            if (isNot(args[0])) {\r\n                throw new Error(`\"chainId\" couldn't be fetched: ${JSON.stringify(args)}`)\r\n            }\r\n            return signed(_.extend(tx, { chainId: args[0] }))\r\n        })\r\n    }\r\n\r\n    // Otherwise, get the missing info from the Klaytn Node\r\n    return Promise.all([\r\n        isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId,\r\n        isNot(tx.gasPrice) ? _this._suggestGasPrice() : tx.gasPrice,\r\n        isNot(tx.nonce) ? _this._klaytnCall.getTransactionCount(tx.from, 'pending') : tx.nonce,\r\n    ]).then(function(args) {\r\n        if (isNot(args[0]) || isNot(args[1]) || isNot(args[2])) {\r\n            throw new Error(`One of the values \"chainId\", \"gasPrice\", or \"nonce\" couldn't be fetched: ${JSON.stringify(args)}`)\r\n        }\r\n        return signed(\r\n            _.extend(tx, {\r\n                chainId: args[0],\r\n                gasPrice: args[1],\r\n                nonce: args[2],\r\n            })\r\n        )\r\n    })\r\n}\r\n\r\n/**\r\n * feePayerSignTransaction calls signTransaction, creating a format for feePayer to sign the transaction.\r\n * If there are feePayerSignatures in tx entered as a parameter, the signatures for fee payer are appended.\r\n *\r\n * @method feePayerSignTransaction\r\n * @param {Object|String} tx The transaction to sign.\r\n * @param {String} feePayer The address of fee payer.\r\n * @param {String|Array} privateKey The private key to use for signing.\r\n * @param {Function} callback The callback function to call.\r\n * @return {Object}\r\n */\r\nAccounts.prototype.feePayerSignTransaction = function feePayerSignTransaction() {\r\n    const _this = this\r\n    let tx\r\n    let feePayer\r\n    let privateKey\r\n    let callback\r\n\r\n    const handleError = e => {\r\n        e = e instanceof Error ? e : new Error(e)\r\n        if (callback) callback(e)\r\n        return Promise.reject(e)\r\n    }\r\n\r\n    try {\r\n        const resolved = resolveArgsForFeePayerSignTransaction(arguments)\r\n        tx = resolved.tx\r\n        feePayer = resolved.feePayer\r\n        privateKey = resolved.privateKey\r\n        callback = resolved.callback\r\n    } catch (e) {\r\n        return handleError(e)\r\n    }\r\n\r\n    if (_.isString(tx)) {\r\n        return this.signTransaction({ senderRawTransaction: tx, feePayer }, privateKey, callback)\r\n    }\r\n\r\n    if (!tx.feePayer || tx.feePayer === '0x' || tx.feePayer === '0x0000000000000000000000000000000000000000') {\r\n        tx.feePayer = feePayer\r\n    }\r\n\r\n    if (!tx.senderRawTransaction) {\r\n        if (!tx.type || !tx.type.includes('FEE_DELEGATED')) {\r\n            return handleError(`Failed to sign transaction with fee payer: invalid transaction type(${tx.type ? tx.type : 'LEGACY'})`)\r\n        }\r\n    }\r\n\r\n    const e = helpers.validateFunction.validateParams(tx)\r\n    if (e) {\r\n        return handleError(e)\r\n    }\r\n\r\n    if (tx.feePayer.toLowerCase() !== feePayer.toLowerCase()) {\r\n        return handleError('Invalid parameter: The address of fee payer does not match.')\r\n    }\r\n\r\n    if (tx.senderRawTransaction) {\r\n        return this.signTransaction(tx, privateKey, callback)\r\n    }\r\n\r\n    return Promise.all([\r\n        isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId,\r\n        isNot(tx.gasPrice) ? _this._klaytnCall.getGasPrice() : tx.gasPrice,\r\n        isNot(tx.nonce) ? _this._klaytnCall.getTransactionCount(tx.from, 'pending') : tx.nonce,\r\n    ]).then(function(args) {\r\n        const chainId = args[0]\r\n        const gasPrice = args[1]\r\n        const nonce = args[2]\r\n\r\n        if (isNot(chainId) || isNot(gasPrice) || isNot(nonce)) {\r\n            throw new Error(`One of the values \"chainId\", \"gasPrice\", or \"nonce\" couldn't be fetched: ${JSON.stringify(args)}`)\r\n        }\r\n        let transaction = _.extend(tx, { chainId, gasPrice, nonce })\r\n\r\n        transaction = helpers.formatters.inputCallFormatter(transaction)\r\n        transaction = coverInitialTxValue(transaction)\r\n\r\n        const rlpEncoded = encodeRLPByTxType(transaction)\r\n        const sig = transaction.signatures ? transaction.signatures : [['0x01', '0x', '0x']]\r\n        const { rawTransaction } = makeRawTransaction(rlpEncoded, sig, transaction)\r\n\r\n        return _this.signTransaction({ senderRawTransaction: rawTransaction, feePayer, chainId }, privateKey, callback)\r\n    })\r\n}\r\n\r\n/**\r\n * signTransactionWithHash signs to transaction hash with private key(s).\r\n *\r\n * @method signTransactionWithHash\r\n * @param {String} hash The hash of transaction to sign.\r\n * @param {String|Array} privateKeys The private key(s) to use for signing.\r\n * @param {String|Number} chainId The chain id of the network.\r\n * @param {Function} callback The callback function to call.\r\n * @return {Array}\r\n */\r\nAccounts.prototype.signTransactionWithHash = function signTransactionWithHash() {\r\n    const _this = this\r\n    let hash\r\n    let privateKeys\r\n    let chainId\r\n    let callback\r\n\r\n    const handleError = e => {\r\n        e = e instanceof Error ? e : new Error(e)\r\n        if (callback) callback(e)\r\n        return Promise.reject(e)\r\n    }\r\n\r\n    try {\r\n        const resolved = resolveArgsForSignTransactionWithHash(arguments)\r\n        hash = resolved.hash\r\n        chainId = resolved.chainId\r\n        privateKeys = resolved.privateKeys\r\n        callback = resolved.callback\r\n    } catch (e) {\r\n        return handleError(e)\r\n    }\r\n\r\n    privateKeys = Array.isArray(privateKeys) ? privateKeys : [privateKeys]\r\n\r\n    function signWithHash(transactionHash, prvKeys, chain, callbackFunc) {\r\n        const result = []\r\n        chain = utils.numberToHex(chain)\r\n\r\n        try {\r\n            for (const privateKey of prvKeys) {\r\n                const p = utils.addHexPrefix(utils.parsePrivateKey(privateKey).privateKey)\r\n                if (!utils.isValidPrivateKey(p)) {\r\n                    return handleError(`Failed to sign transaction with hash: Invalid private key ${privateKey}`)\r\n                }\r\n\r\n                const signature = AccountLib.makeSigner(Nat.toNumber(chain || '0x1') * 2 + 35)(transactionHash, p)\r\n                const [v, r, s] = AccountLib.decodeSignature(signature).map(sig => utils.makeEven(utils.trimLeadingZero(sig)))\r\n\r\n                result.push(utils.transformSignaturesToObject([v, r, s]))\r\n            }\r\n        } catch (e) {\r\n            callbackFunc(e)\r\n            return Promise.reject(e)\r\n        }\r\n\r\n        callbackFunc(null, result)\r\n        return result\r\n    }\r\n\r\n    return Promise.resolve(isNot(chainId) ? _this._klaytnCall.getChainId() : chainId).then(id => {\r\n        return signWithHash(hash, privateKeys, id, callback)\r\n    })\r\n}\r\n\r\n/**\r\n * getRawTransactionWithSignatures returns object which contains rawTransaction.\r\n *\r\n * @method getRawTransactionWithSignatures\r\n * @param {Object} tx The transaction object which contains signatures or feePayerSignatures.\r\n * @param {Function} callback The callback function to call.\r\n * @return {Object}\r\n */\r\nAccounts.prototype.getRawTransactionWithSignatures = function getRawTransactionWithSignatures(tx, callback) {\r\n    const _this = this\r\n    let result\r\n\r\n    callback = callback || function() {}\r\n\r\n    const handleError = e => {\r\n        e = e instanceof Error ? e : new Error(e)\r\n        if (callback) callback(e)\r\n        return Promise.reject(e)\r\n    }\r\n\r\n    if (!tx || !_.isObject(tx)) {\r\n        return handleError('Invalid parameter: The transaction must be defined as an object')\r\n    }\r\n    if (!tx.signatures && !tx.feePayerSignatures) {\r\n        return handleError('There are no signatures or feePayerSignatures defined in the transaction object.')\r\n    }\r\n\r\n    const error = helpers.validateFunction.validateParams(tx)\r\n    if (error) return handleError(error)\r\n\r\n    if (tx.senderRawTransaction) {\r\n        tx.feePayerSignatures = tx.feePayerSignatures || [['0x01', '0x', '0x']]\r\n\r\n        const decoded = decodeFromRawTransaction(tx.senderRawTransaction)\r\n        // feePayer !== '0x' means that in senderRawTransaction there are feePayerSignatures\r\n        if (\r\n            decoded.feePayer !== '0x' &&\r\n            decoded.feePayer !== '0x0000000000000000000000000000000000000000' &&\r\n            !utils.isEmptySig(decoded.feePayerSignatures)\r\n        ) {\r\n            if (decoded.feePayer.toLowerCase() !== tx.feePayer.toLowerCase()) {\r\n                return handleError('Invalid feePayer')\r\n            }\r\n            tx.feePayerSignatures = tx.feePayerSignatures.concat(decoded.feePayerSignatures)\r\n        }\r\n\r\n        decoded.feePayer = tx.feePayer\r\n        decoded.feePayerSignatures = tx.feePayerSignatures\r\n\r\n        if (tx.signatures) {\r\n            decoded.signatures = decoded.signatures.concat(tx.signatures)\r\n        }\r\n        tx = decoded\r\n    }\r\n\r\n    function signed(txObject) {\r\n        try {\r\n            // Guarantee all property in transaction is hex.\r\n            txObject = helpers.formatters.inputCallFormatter(txObject)\r\n\r\n            const transaction = coverInitialTxValue(txObject)\r\n\r\n            const rlpEncoded = encodeRLPByTxType(transaction)\r\n\r\n            let sigs = transaction.signatures ? transaction.signatures : ['0x01', '0x', '0x']\r\n\r\n            if (!_.isArray(sigs[0])) sigs = [sigs]\r\n\r\n            const { rawTransaction, signatures, feePayerSignatures } = makeRawTransaction(rlpEncoded, sigs, transaction)\r\n\r\n            result = {\r\n                rawTransaction,\r\n                txHash: Hash.keccak256(rawTransaction),\r\n                senderTxHash: getSenderTxHash(rawTransaction),\r\n            }\r\n\r\n            if (signatures && !utils.isEmptySig(signatures)) {\r\n                result.signatures = signatures\r\n            }\r\n\r\n            if (feePayerSignatures && !utils.isEmptySig(feePayerSignatures)) {\r\n                result.feePayerSignatures = feePayerSignatures\r\n            }\r\n        } catch (e) {\r\n            callback(e)\r\n            return Promise.reject(e)\r\n        }\r\n\r\n        callback(null, result)\r\n        return result\r\n    }\r\n\r\n    if (tx.nonce !== undefined && tx.chainId !== undefined && tx.gasPrice !== undefined) {\r\n        return Promise.resolve(signed(tx))\r\n    }\r\n\r\n    // Otherwise, get the missing info from the Klaytn Node\r\n    return Promise.all([\r\n        isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId,\r\n        isNot(tx.gasPrice) ? _this._klaytnCall.getGasPrice() : tx.gasPrice,\r\n        isNot(tx.nonce) ? _this._klaytnCall.getTransactionCount(tx.from, 'pending') : tx.nonce,\r\n    ]).then(function(args) {\r\n        if (isNot(args[0]) || isNot(args[1]) || isNot(args[2])) {\r\n            throw new Error(`One of the values \"chainId\", \"gasPrice\", or \"nonce\" couldn't be fetched: ${JSON.stringify(args)}`)\r\n        }\r\n        return signed(\r\n            _.extend(tx, {\r\n                chainId: args[0],\r\n                gasPrice: args[1],\r\n                nonce: args[2],\r\n            })\r\n        )\r\n    })\r\n}\r\n\r\n/**\r\n * combineSignatures combines RLP encoded raw transaction strings.\r\n * combineSignatures compares transaction before combining, and if values in field are not same, this throws error.\r\n * The comparison allows that the address of the fee payer is '0x0000000000000000000000000000000000000000'(default value) for some transactions while the other transactions have a specific fee payer. This is for the use case that some transactions do not have the fee payer's information.\r\n * In this case, feePayer field doesn't have to be compared with other transaction.\r\n *\r\n * @method combineSignatures\r\n * @param {Array} rawTransactions The array of raw transaction string to combine.\r\n * @param {Function} callback The callback function to call.\r\n * @return {Object}\r\n */\r\nAccounts.prototype.combineSignatures = function combineSignatures(rawTransactions, callback) {\r\n    let decodedTx\r\n    let senders = []\r\n    let feePayers = []\r\n    let feePayer\r\n\r\n    callback = callback || function() {}\r\n\r\n    const handleError = e => {\r\n        e = e instanceof Error ? e : new Error(e)\r\n        if (callback) callback(e)\r\n        return Promise.reject(e)\r\n    }\r\n\r\n    if (!_.isArray(rawTransactions)) {\r\n        return handleError('The parameter of the combineSignatures function must be an array of RLP encoded transaction strings.')\r\n    }\r\n\r\n    for (const raw of rawTransactions) {\r\n        const { senderSignatures, feePayerSignatures, decodedTransaction } = extractSignatures(raw)\r\n\r\n        senders = senders.concat(senderSignatures)\r\n        feePayers = feePayers.concat(feePayerSignatures)\r\n\r\n        if (decodedTx) {\r\n            let isSame = true\r\n            const keys = Object.keys(decodedTx)\r\n            for (const key of keys) {\r\n                if (\r\n                    key === 'v' ||\r\n                    key === 'r' ||\r\n                    key === 's' ||\r\n                    key === 'signatures' ||\r\n                    key === 'payerV' ||\r\n                    key === 'payerR' ||\r\n                    key === 'payerS' ||\r\n                    key === 'feePayerSignatures'\r\n                ) {\r\n                    continue\r\n                }\r\n\r\n                // feePayer field can be '0x' or '0x0000000000000000000000000000000000000000' when after sender signs to trasnaction.\r\n                // For handling this, if feePayer is '0x' or '0x0000000000000000000000000000000000000000', don't compare with other transaction\r\n                if (key === 'feePayer') {\r\n                    if (decodedTransaction[key] === '0x' || decodedTransaction[key] === '0x0000000000000000000000000000000000000000') {\r\n                        continue\r\n                    } else {\r\n                        // set feePayer letiable with valid feePayer address(not '0x' and '0x0000000000000000000000000000000000000000')\r\n                        feePayer = decodedTransaction[key]\r\n                        if (decodedTx[key] === '0x' || decodedTx[key] === '0x0000000000000000000000000000000000000000') {\r\n                            // set feePayer field to decodedTx for comparing feePayer address with other transactions\r\n                            decodedTx[key] = decodedTransaction[key]\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (decodedTransaction[key] === undefined || decodedTx[key] !== decodedTransaction[key]) {\r\n                    isSame = false\r\n                    break\r\n                }\r\n            }\r\n            if (!isSame) {\r\n                return handleError('Failed to combineSignatures: Signatures that sign to different transaction cannot be combined.')\r\n            }\r\n        } else {\r\n            decodedTx = decodedTransaction\r\n        }\r\n    }\r\n\r\n    const parsedTxObject = decodeFromRawTransaction(rawTransactions[0])\r\n    parsedTxObject.signatures = senders\r\n\r\n    if (feePayer) {\r\n        parsedTxObject.feePayer = feePayer\r\n        if (feePayers.length > 0) {\r\n            parsedTxObject.feePayerSignatures = feePayers\r\n        }\r\n    }\r\n    return this.getRawTransactionWithSignatures(parsedTxObject, callback)\r\n}\r\n\r\n/**\r\n * cav.klay.accounts.recoverTransaction('0xf86180808401ef364594f0109fc8df283027b6285cc889f5aa624eac1f5580801ca031573280d608f75137e33fc14655f097867d691d5c4c44ebe5ae186070ac3d5ea0524410802cdc025034daefcdfa08e7d2ee3f0b9d9ae184b2001fe0aff07603d9');\r\n * > \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\"\r\n */\r\nAccounts.prototype.recoverTransaction = function recoverTransaction(rawTx) {\r\n    if (utils.getTxTypeStringFromRawTransaction(rawTx) !== undefined) {\r\n        throw new Error('recoverTransaction only supports transactions of type \"LEGACY\".')\r\n    }\r\n\r\n    const values = RLP.decode(rawTx)\r\n\r\n    // If the leading zero is trimmed, it will be filled with a valid length of '0'.\r\n    const arr = values.slice(7, 9).map(sig => {\r\n        sig = sig.replace('0x', '')\r\n        while (sig.length < 64) {\r\n            sig = `0${sig}`\r\n        }\r\n        return `0x${sig}`\r\n    })\r\n    arr.unshift(values[6])\r\n\r\n    const signature = AccountLib.encodeSignature(arr)\r\n    const recovery = Bytes.toNumber(values[6])\r\n    const extraData = recovery < 35 ? [] : [Bytes.fromNumber((recovery - 35) >> 1), '0x', '0x']\r\n    const signingData = values.slice(0, 6).concat(extraData)\r\n    const signingDataHex = RLP.encode(signingData)\r\n\r\n    return AccountLib.recover(Hash.keccak256(signingDataHex), signature)\r\n}\r\n\r\n/**\r\n * Hashes the given message to be passed cav.klay.accounts.recover() function.\r\n * The data will be UTF-8 HEX decoded and enveloped as follows:\r\n * \"\\x19Klaytn Signed Message:\\n\" + message.length + message and hashed using keccak256.\r\n *\r\n * cav.klay.accounts.hashMessage(\"Hello World\")\r\n * > \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\"\r\n * // the below results in the same hash\r\n * cav.klay.accounts.hashMessage(caver.utils.utf8ToHex(\"Hello World\"))\r\n * > \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\"\r\n */\r\nAccounts.prototype.hashMessage = function hashMessage(data) {\r\n    const message = utils.isHexStrict(data) ? utils.hexToBytes(data) : data\r\n    const messageBuffer = Buffer.from(message)\r\n    const preamble = `\\x19Klaytn Signed Message:\\n${message.length}`\r\n    const preambleBuffer = Buffer.from(preamble)\r\n    // klayMessage is concatenated buffer (preambleBuffer + messageBuffer)\r\n    const klayMessage = Buffer.concat([preambleBuffer, messageBuffer])\r\n    // Finally, run keccak256 on klayMessage.\r\n    return Hash.keccak256(klayMessage)\r\n}\r\n\r\n/**\r\n * Signs arbitrary data.\r\n * This data is before UTF-8 HEX decoded and enveloped as follows:\r\n * \"\\x19Klaytn Signed Message:\\n\" + message.length + message.\r\n *\r\n * cav.klay.accounts.sign('Some data', '0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318');\r\n * > {\r\n *     message: 'Some data',\r\n *     messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655',\r\n *     v: '0x1c',\r\n *     r: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd',\r\n *     s: '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029',\r\n *     signature: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a0291c'\r\n *   }\r\n */\r\nAccounts.prototype.sign = function sign(data, privateKey) {\r\n    const parsed = utils.parsePrivateKey(privateKey)\r\n    privateKey = parsed.privateKey\r\n    if (!utils.isValidPrivateKey(privateKey)) {\r\n        throw new Error('Invalid private key')\r\n    }\r\n\r\n    const messageHash = this.hashMessage(data)\r\n    const signature = AccountLib.sign(messageHash, privateKey)\r\n    const [v, r, s] = AccountLib.decodeSignature(signature)\r\n    return {\r\n        message: data,\r\n        messageHash,\r\n        v,\r\n        r,\r\n        s,\r\n        signature,\r\n    }\r\n}\r\n\r\n/**\r\n * preFixed - Boolean (optional, default: false):\r\n * If the last parameter is true,\r\n * the given message will NOT automatically be prefixed with \"\\x19Klaytn Signed Message:\\n\" + message.length + message,\r\n * and assumed to be already prefixed.\r\n */\r\nAccounts.prototype.recover = function recover(message, signature, preFixed) {\r\n    const args = [].slice.apply(arguments)\r\n\r\n    if (_.isObject(message)) {\r\n        return this.recover(message.messageHash, AccountLib.encodeSignature([message.v, message.r, message.s]), true)\r\n    }\r\n\r\n    if (!preFixed) {\r\n        message = this.hashMessage(message)\r\n    }\r\n\r\n    if (args.length >= 4) {\r\n        preFixed = args.slice(-1)[0]\r\n        preFixed = _.isBoolean(preFixed) ? !!preFixed : false\r\n\r\n        return this.recover(message, AccountLib.encodeSignature(args.slice(1, 4)), preFixed) // v, r, s\r\n    }\r\n    /**\r\n     * recover in Account module\r\n     * const recover = (hash, signature) => {\r\n     *   const vals = decodeSignature(signature);\r\n     *   const vrs = { v: Bytes.toNumber(vals[0]), r: vals[1].slice(2), s: vals[2].slice(2) };\r\n     *   const ecPublicKey = secp256k1.recoverPubKey(Buffer.from(hash.slice(2), 'hex'), vrs, vrs.v < 2 ? vrs.v : 1 - vrs.v % 2); // because odd vals mean v=0... sadly that means v=0 means v=1... I hate that\r\n     *   const publicKey = \"0x\" + ecPublicKey.encode('hex', false).slice(2);\r\n     *   const publicHash = keccak256(publicKey);\r\n     *   const address = toChecksum(\"0x\" + publicHash.slice(-40));\r\n     *   return address;\r\n     * };\r\n     */\r\n    return AccountLib.recover(message, signature)\r\n}\r\n\r\n// Taken from https://github.com/ethereumjs/ethereumjs-wallet\r\nAccounts.prototype.decrypt = function(v3Keystore, password, nonStrict) {\r\n    if (!_.isString(password)) {\r\n        throw new Error('No password given.')\r\n    }\r\n\r\n    // To deep copy an object, using JSON.parse and JSON.stringify (object -> string -> object)\r\n    const json = _.isObject(v3Keystore) ? _.cloneDeep(v3Keystore) : JSON.parse(nonStrict ? v3Keystore.toLowerCase() : v3Keystore)\r\n\r\n    if (json.version !== 3 && json.version !== 4) {\r\n        console.warn('This is not a V3 or V4 wallet.')\r\n        // throw new Error('Not a valid V3 wallet');\r\n    }\r\n\r\n    if (json.version === 3 && !json.crypto) {\r\n        // crypto field should be existed in keystore version 3\r\n        throw new Error(\"Invalid keystore V3 format: 'crypto' is not defined.\")\r\n    }\r\n\r\n    if (json.crypto) {\r\n        if (json.keyring) {\r\n            throw new Error(\"Invalid key store format: 'crypto' can not be with 'keyring'\")\r\n        }\r\n        json.keyring = [json.crypto]\r\n        delete json.crypto\r\n    }\r\n\r\n    if (_.isArray(json.keyring[0]) && json.keyring.length > 3) {\r\n        throw new Error('Invalid key store format')\r\n    }\r\n\r\n    let accountKey = {}\r\n\r\n    // AccountKeyRoleBased format\r\n    if (_.isArray(json.keyring[0])) {\r\n        const transactionKey = decryptKey(json.keyring[0])\r\n        if (transactionKey) accountKey.transactionKey = transactionKey\r\n\r\n        const updateKey = decryptKey(json.keyring[1])\r\n        if (updateKey) accountKey.updateKey = updateKey\r\n\r\n        const feePayerKey = decryptKey(json.keyring[2])\r\n        if (feePayerKey) accountKey.feePayerKey = feePayerKey\r\n    } else {\r\n        accountKey = decryptKey(json.keyring)\r\n    }\r\n\r\n    function decryptKey(encryptedArray) {\r\n        if (!encryptedArray || encryptedArray.length === 0) return undefined\r\n\r\n        const decryptedArray = []\r\n        for (const encrypted of encryptedArray) {\r\n            let derivedKey\r\n            let kdfparams\r\n            /**\r\n             * Supported kdf modules are the following:\r\n             * 1) pbkdf2\r\n             * 2) scrypt\r\n             */\r\n            if (encrypted.kdf === 'scrypt') {\r\n                kdfparams = encrypted.kdfparams\r\n\r\n                // FIXME: support progress reporting callback\r\n                derivedKey = scrypt.syncScrypt(\r\n                    Buffer.from(password),\r\n                    Buffer.from(kdfparams.salt, 'hex'),\r\n                    kdfparams.n,\r\n                    kdfparams.r,\r\n                    kdfparams.p,\r\n                    kdfparams.dklen\r\n                )\r\n            } else if (encrypted.kdf === 'pbkdf2') {\r\n                kdfparams = encrypted.kdfparams\r\n\r\n                if (kdfparams.prf !== 'hmac-sha256') {\r\n                    throw new Error('Unsupported parameters to PBKDF2')\r\n                }\r\n\r\n                derivedKey = cryp.pbkdf2Sync(\r\n                    Buffer.from(password),\r\n                    Buffer.from(kdfparams.salt, 'hex'),\r\n                    kdfparams.c,\r\n                    kdfparams.dklen,\r\n                    'sha256'\r\n                )\r\n            } else {\r\n                throw new Error('Unsupported key derivation scheme')\r\n            }\r\n\r\n            const ciphertext = Buffer.from(encrypted.ciphertext, 'hex')\r\n\r\n            const mac = utils.sha3(Buffer.from([...derivedKey.slice(16, 32), ...ciphertext])).replace('0x', '')\r\n            if (mac !== encrypted.mac) {\r\n                throw new Error('Key derivation failed - possibly wrong password')\r\n            }\r\n\r\n            const decipher = cryp.createDecipheriv(encrypted.cipher, derivedKey.slice(0, 16), Buffer.from(encrypted.cipherparams.iv, 'hex'))\r\n            decryptedArray.push(`0x${Buffer.from([...decipher.update(ciphertext), ...decipher.final()]).toString('hex')}`)\r\n        }\r\n        return decryptedArray.length === 1 ? decryptedArray[0] : decryptedArray\r\n    }\r\n\r\n    return this.createWithAccountKey(json.address, accountKey)\r\n}\r\n\r\n/*\r\n    The fields of kdfparams are described below.\r\n\r\n    `dklen` is the desired length of the derived key\r\n    `salt` - A string of characters that modifies the hash to protect against Rainbow table attacks\r\n    `n` - CPU/memory cost parameter\r\n    `r` - The blocksize parameter, which fine-tunes sequential memory read size and performance. 8 is commonly used.\r\n    `p` - Parallelization parameter\r\n    `c` - the number of iterations desired\r\n */\r\n/**\r\n * encrypt encrypts an account and returns a key store v4 object.\r\n *\r\n * @method encrypt\r\n * @param {String} key The key parameter can be a raw key format(private key string, KlaytnWalletKey, array of private keys or object with keys by roles) or an instance of Account or AccountKey.\r\n * @param {String} password The password to be used for account encryption. The encrypted key store can be decrypted with this password.\r\n * @param {Object} options The options to use when encrypt an account.\r\n * @return {Object}\r\n */\r\nAccounts.prototype.encrypt = function(key, password, options) {\r\n    /**\r\n     * options can include below\r\n     * {\r\n     *   salt: ...,\r\n     *   iv: ...,\r\n     *   kdf: ...,\r\n     *   dklen: ...,\r\n     *   c: ...,\r\n     *   n: ...,\r\n     *   r: ...,\r\n     *   p: ...,\r\n     *   cipher: ...,\r\n     *   uuid: ...,\r\n     *   cipher: ...,\r\n     * }\r\n     */\r\n    options = options || {}\r\n\r\n    let address\r\n    let account\r\n\r\n    if (key instanceof Account) {\r\n        if (options.address && options.address !== key.address) {\r\n            throw new Error('Address in account is not matched with address in options object')\r\n        }\r\n        address = key.address\r\n        account = key\r\n    } else if (_.isString(key)) {\r\n        account = this.privateKeyToAccount(key, options.address)\r\n        address = account.address\r\n    } else {\r\n        if (!options.address) {\r\n            throw new Error('The address must be defined inside the options object.')\r\n        }\r\n        address = options.address\r\n    }\r\n\r\n    if (!account) account = this.createWithAccountKey(address, key)\r\n\r\n    let keyring\r\n    let transactionKey\r\n    let updateKey\r\n    let feePayerKey\r\n\r\n    switch (account.accountKeyType) {\r\n        case AccountKeyEnum.ACCOUNT_KEY_PUBLIC:\r\n        case AccountKeyEnum.ACCOUNT_KEY_MULTISIG:\r\n            keyring = encryptKey(account.keys, password, options)\r\n            break\r\n        case AccountKeyEnum.ACCOUNT_KEY_ROLEBASED:\r\n            keyring = []\r\n            transactionKey = encryptKey(account.transactionKey, password, options)\r\n            updateKey = encryptKey(account.updateKey, password, options)\r\n            feePayerKey = encryptKey(account.feePayerKey, password, options)\r\n            keyring.push(transactionKey)\r\n            keyring.push(updateKey)\r\n            keyring.push(feePayerKey)\r\n            for (let i = keyring.length - 1; i >= 0; i--) {\r\n                if (keyring[i].length !== 0) break\r\n                keyring = keyring.slice(0, i)\r\n            }\r\n            break\r\n        default:\r\n            throw new Error(`Unsupported account key type: ${account.accountKeyType}`)\r\n    }\r\n\r\n    return {\r\n        version: 4,\r\n        id: uuid.v4({ random: options.uuid || cryp.randomBytes(16) }),\r\n        address: account.address.toLowerCase(),\r\n        keyring,\r\n    }\r\n}\r\n\r\n/**\r\n * encryptV3 encrypts an account and returns a key store v3 object.\r\n *\r\n * @method encryptV3\r\n * @param {String} key The key parameter can be a normal private key(KlaytnWalletKey format also supported) or an instance of Account or AccountKeyPublic.\r\n * @param {String} password The password to be used for account encryption. The encrypted key store can be decrypted with this password.\r\n * @param {Object} options The options to use when encrypt an account.\r\n * @return {Object}\r\n */\r\nAccounts.prototype.encryptV3 = function(key, password, options) {\r\n    options = options || {}\r\n\r\n    let address\r\n    let account\r\n    const notSupportedType =\r\n        'Invalid parameter: encryptV3 only supports a single private key (also supports KlantnWalletKey format), or an instance of Account or AccountKeyPublic as a parameter. If you want to encrypt multiple keys, use caver.klay.accounts.encrypt which encrypts to keystore v4.'\r\n\r\n    if (key instanceof Account) {\r\n        if (options.address && options.address !== key.address) {\r\n            throw new Error('Address in account is not matched with address in options object')\r\n        }\r\n        if (key.accountKeyType !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) throw new Error(notSupportedType)\r\n\r\n        address = key.address\r\n        account = key\r\n    } else if (_.isString(key)) {\r\n        account = this.privateKeyToAccount(key, options.address)\r\n        address = account.address\r\n    } else if (Account.isAccountKey(key)) {\r\n        if (key.type !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) throw new Error(notSupportedType)\r\n        if (!options.address) {\r\n            throw new Error('The address must be defined inside the options object.')\r\n        }\r\n\r\n        address = options.address\r\n    } else {\r\n        throw new Error(notSupportedType)\r\n    }\r\n\r\n    if (!account) account = this.createWithAccountKey(address, key)\r\n\r\n    const crypto = encryptKey(account.keys, password, options)\r\n\r\n    return {\r\n        version: 3,\r\n        id: uuid.v4({ random: options.uuid || cryp.randomBytes(16) }),\r\n        address: account.address.toLowerCase(),\r\n        crypto: crypto[0],\r\n    }\r\n}\r\n\r\nAccounts.prototype.privateKeyToPublicKey = function(privateKey, compressed = false) {\r\n    const parsed = utils.parsePrivateKey(privateKey)\r\n    privateKey = parsed.privateKey\r\n    privateKey = privateKey.slice(0, 2) === '0x' ? privateKey.slice(2) : privateKey\r\n\r\n    if (privateKey.length !== 64) {\r\n        throw new Error('Received a invalid privateKey. The length of privateKey should be 64.')\r\n    }\r\n    const buffer = Buffer.from(privateKey, 'hex')\r\n    const ecKey = secp256k1.keyFromPrivate(buffer)\r\n\r\n    let publicKey\r\n\r\n    if (!compressed) {\r\n        publicKey = `0x${ecKey.getPublic(false, 'hex').slice(2)}`\r\n    } else {\r\n        publicKey = `0x${ecKey.getPublic(true, 'hex')}`\r\n    }\r\n\r\n    return publicKey\r\n}\r\n\r\nAccounts.prototype.encodeRLPByTxType = encodeRLPByTxType\r\n\r\nAccounts.prototype.setAccounts = function(accounts) {\r\n    this.wallet.clear()\r\n\r\n    for (let i = 0; i < accounts.wallet.length; i++) {\r\n        this.wallet.add(accounts.wallet[i])\r\n    }\r\n\r\n    return this\r\n}\r\n\r\n/* eslint-enable complexity */\r\n\r\n// Note: this is trying to follow closely the specs on\r\n\r\n/**\r\n  > Wallet {\r\n      0: {...}, // account by index\r\n      \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\": {...},  // same account by address\r\n      \"0xf0109fc8df283027b6285cc889f5aa624eac1f55\": {...},  // same account by address lowercase\r\n      1: {...},\r\n      \"0xD0122fC8DF283027b6285cc889F5aA624EaC1d23\": {...},\r\n      \"0xd0122fc8df283027b6285cc889f5aa624eac1d23\": {...},\r\n\r\n      add: function(){},\r\n      remove: function(){},\r\n      save: function(){},\r\n      load: function(){},\r\n      clear: function(){},\r\n\r\n      length: 2,\r\n  }\r\n *\r\n * Contains an in memory wallet with multiple accounts.\r\n * These accounts can be used when using cav.klay.sendTransaction().\r\n */\r\nfunction Wallet(accounts) {\r\n    this._accounts = accounts\r\n    this.length = 0\r\n    this.defaultKeyName = 'caverjs_wallet'\r\n    this.lastIndex = -1\r\n}\r\n\r\nWallet.prototype._findSafeIndex = function(pointer) {\r\n    pointer = pointer || 0\r\n    while (this.lastIndex >= pointer) {\r\n        if (!_.has(this, pointer)) {\r\n            break\r\n        }\r\n        pointer++\r\n    }\r\n    if (this.lastIndex < pointer) {\r\n        this.lastIndex = pointer\r\n    }\r\n    return pointer\r\n}\r\n\r\nWallet.prototype._findSafeLastIndex = function(pointer) {\r\n    pointer = this.lastIndex\r\n    while (pointer >= 0) {\r\n        if (_.has(this, pointer)) {\r\n            break\r\n        }\r\n        pointer--\r\n    }\r\n    return pointer\r\n}\r\n\r\nWallet.prototype._currentIndexes = function() {\r\n    const keys = Object.keys(this)\r\n    const indexes = keys\r\n        .map(function(key) {\r\n            return parseInt(key)\r\n        })\r\n        .filter(function(n) {\r\n            return n < 9e20\r\n        })\r\n\r\n    return indexes\r\n}\r\n\r\nWallet.prototype.create = function(numberOfAccounts, entropy) {\r\n    for (let i = 0; i < numberOfAccounts; ++i) {\r\n        this.add(this._accounts.create(entropy).privateKey)\r\n    }\r\n    return this\r\n}\r\n\r\n/**\r\n * Adds an account using a private key or account object to the wallet.\r\n *\r\n * cav.klay.accounts.wallet.add({\r\n    privateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\r\n    address: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01'\r\n    });\r\n    > {\r\n        index: 0,\r\n        address: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01',\r\n        privateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\r\n        signTransaction: function(tx){...},\r\n        sign: function(data){...},\r\n        encrypt: function(password){...}\r\n    }\r\n */\r\nWallet.prototype.add = function(account, userInputAddress) {\r\n    let accountForWallet\r\n    /**\r\n     * cav.klay.accounts.wallet.add('0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318');\r\n     *\r\n     * cav.klay.accounts.wallet.add({\r\n     *   privateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\r\n     *   address: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01'\r\n     * });\r\n     */\r\n    if (Account.isAccountKey(account)) {\r\n        if (!userInputAddress) {\r\n            throw new Error('Address is not defined. Address cannot be determined from AccountKey')\r\n        }\r\n        accountForWallet = this._accounts.createWithAccountKey(userInputAddress, account)\r\n    } else if (account instanceof Account) {\r\n        accountForWallet = this._accounts.createWithAccountKey(account.address, account.accountKey)\r\n        accountForWallet.address = userInputAddress || account.address\r\n    } else if (_.isObject(account) && account.address && account.privateKey) {\r\n        accountForWallet = this._accounts.privateKeyToAccount(account.privateKey, userInputAddress || account.address)\r\n    } else if (_.isString(account)) {\r\n        accountForWallet = this._accounts.privateKeyToAccount(account, userInputAddress)\r\n    } else {\r\n        const accountKey = this._accounts.createAccountKey(account)\r\n        if (!userInputAddress) {\r\n            throw new Error('Address is not defined. Address cannot be determined from AccountKey format')\r\n        }\r\n        accountForWallet = this._accounts.createWithAccountKey(userInputAddress, accountKey)\r\n    }\r\n\r\n    if (this[accountForWallet.address]) {\r\n        throw new Error(`Account exists with ${accountForWallet.address}`)\r\n    }\r\n\r\n    accountForWallet.index = this._findSafeIndex()\r\n    this[accountForWallet.index] = accountForWallet\r\n\r\n    this[accountForWallet.address] = accountForWallet\r\n    this[accountForWallet.address.toLowerCase()] = accountForWallet\r\n    this[accountForWallet.address.toUpperCase()] = accountForWallet\r\n    try {\r\n        this[utils.toChecksumAddress(accountForWallet.address)] = accountForWallet\r\n    } catch (e) {}\r\n\r\n    this.length++\r\n\r\n    return accountForWallet\r\n}\r\n\r\nWallet.prototype.updatePrivateKey = function(privateKey, address) {\r\n    if (privateKey === undefined || address === undefined) {\r\n        throw new Error('To update the privatKey in wallet, need to set both privateKey and address.')\r\n    }\r\n\r\n    // If privateKey parameter is not string type, return error\r\n    if (!_.isString(privateKey)) {\r\n        throw new Error('The private key used for the update is not a valid string.')\r\n    }\r\n\r\n    if (!utils.isAddress(address)) {\r\n        throw new Error(`Invalid address : ${address}`)\r\n    }\r\n\r\n    // If failed to find account through address, return error\r\n    const accountExists = !!this[address]\r\n    if (!accountExists) throw new Error(`Failed to find account with ${address}`)\r\n\r\n    const account = this[address]\r\n\r\n    if (account.accountKeyType !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) {\r\n        throw new Error(\r\n            'Account using AccountKeyMultiSig or AccountKeyRoleBased must be updated using the caver.klay.accounts.updateAccountKey function.'\r\n        )\r\n    }\r\n\r\n    const parsed = utils.parsePrivateKey(privateKey)\r\n    if (!utils.isValidPrivateKey(parsed.privateKey)) {\r\n        throw new Error('Invalid private key')\r\n    }\r\n\r\n    if (parsed.address && parsed.address !== account.address) {\r\n        throw new Error('The address extracted from the private key does not match the address received as the input value.')\r\n    }\r\n\r\n    const newAccountKeyPublic = new AccountKeyPublic(parsed.privateKey)\r\n    this[account.index].accountKey = newAccountKeyPublic\r\n    this[account.address].accountKey = newAccountKeyPublic\r\n    this[account.address.toLowerCase()].accountKey = newAccountKeyPublic\r\n    this[account.address.toUpperCase()].accountKey = newAccountKeyPublic\r\n\r\n    try {\r\n        this[utils.toChecksumAddress(account.address)].accountKey = newAccountKeyPublic\r\n    } catch (e) {}\r\n\r\n    return account\r\n}\r\n\r\nWallet.prototype.updateAccountKey = function updateAccountKey(address, accountKey) {\r\n    if (address === undefined || accountKey === undefined) {\r\n        throw new Error('To update the accountKey in wallet, need to set both address and accountKey.')\r\n    }\r\n\r\n    if (!Account.isAccountKey(accountKey)) {\r\n        accountKey = this._accounts.createAccountKey(accountKey)\r\n    }\r\n\r\n    if (!utils.isAddress(address)) {\r\n        throw new Error(`Invalid address : ${address}`)\r\n    }\r\n\r\n    // If failed to find account through address, return error\r\n    const accountExists = !!this[address]\r\n    if (!accountExists) throw new Error(`Failed to find account with ${address}`)\r\n\r\n    const account = this[address]\r\n\r\n    this[account.index].accountKey = accountKey\r\n    this[account.address].accountKey = accountKey\r\n    this[account.address.toLowerCase()].accountKey = accountKey\r\n    this[account.address.toUpperCase()].accountKey = accountKey\r\n\r\n    try {\r\n        this[utils.toChecksumAddress(account.address)].accountKey = accountKey\r\n    } catch (e) {}\r\n\r\n    return account\r\n}\r\n\r\nWallet.prototype.remove = function(addressOrIndex) {\r\n    const account = this[addressOrIndex]\r\n\r\n    if (account && account.address) {\r\n        // address\r\n        this[account.address].accountKey = null\r\n        delete this[account.address]\r\n\r\n        if (this[account.address.toLowerCase()]) {\r\n            // address lowercase\r\n            this[account.address.toLowerCase()].accountKey = null\r\n            delete this[account.address.toLowerCase()]\r\n        }\r\n\r\n        if (this[account.address.toUpperCase()]) {\r\n            // address uppercase\r\n            this[account.address.toUpperCase()].accountKey = null\r\n            delete this[account.address.toUpperCase()]\r\n        }\r\n\r\n        try {\r\n            this[utils.toChecksumAddress(account.address)].accountKey = null\r\n            delete this[utils.toChecksumAddress(account.address)]\r\n        } catch (e) {}\r\n\r\n        // index\r\n        this[account.index].accountKey = null\r\n        delete this[account.index]\r\n\r\n        this.length--\r\n\r\n        // Update last index\r\n        if (account.index === this.lastIndex) {\r\n            this.lastIndex = this._findSafeLastIndex()\r\n        }\r\n\r\n        return true\r\n    }\r\n    return false\r\n}\r\n\r\nWallet.prototype.clear = function() {\r\n    const _this = this\r\n    const indexes = this._currentIndexes()\r\n\r\n    indexes.forEach(function(index) {\r\n        _this.remove(index)\r\n    })\r\n\r\n    return this\r\n}\r\n\r\n/**\r\n * cav.klay.accounts.wallet.encrypt('test');\r\n    > [ { version: 3,\r\n        id: 'dcf8ab05-a314-4e37-b972-bf9b86f91372',\r\n        address: '06f702337909c06c82b09b7a22f0a2f0855d1f68',\r\n        crypto:\r\n         { ciphertext: '0de804dc63940820f6b3334e5a4bfc8214e27fb30bb7e9b7b74b25cd7eb5c604',\r\n           cipherparams: [Object],\r\n           cipher: 'aes-128-ctr',\r\n           kdf: 'scrypt',\r\n           kdfparams: [Object],\r\n           mac: 'b2aac1485bd6ee1928665642bf8eae9ddfbc039c3a673658933d320bac6952e3' } },\r\n      { version: 3,\r\n        id: '9e1c7d24-b919-4428-b10e-0f3ef79f7cf0',\r\n        address: 'b5d89661b59a9af0b34f58d19138baa2de48baaf',\r\n        crypto:\r\n         { ciphertext: 'd705ebed2a136d9e4db7e5ae70ed1f69d6a57370d5fbe06281eb07615f404410',\r\n           cipherparams: [Object],\r\n           cipher: 'aes-128-ctr',\r\n           kdf: 'scrypt',\r\n           kdfparams: [Object],\r\n           mac: 'af9eca5eb01b0f70e909f824f0e7cdb90c350a802f04a9f6afe056602b92272b' } }\r\n    ]\r\n */\r\nWallet.prototype.encrypt = function(password, options) {\r\n    const _this = this\r\n    const indexes = this._currentIndexes()\r\n\r\n    const accounts = indexes.map(function(index) {\r\n        return _this[index].encrypt(password, options)\r\n    })\r\n\r\n    return accounts\r\n}\r\n\r\n/**\r\n * cav.klay.accounts.wallet.decrypt([\r\n    { version: 3,\r\n    id: '83191a81-aaca-451f-b63d-0c5f3b849289',\r\n    address: '06f702337909c06c82b09b7a22f0a2f0855d1f68',\r\n    crypto:\r\n     { ciphertext: '7d34deae112841fba86e3e6cf08f5398dda323a8e4d29332621534e2c4069e8d',\r\n       cipherparams: { iv: '497f4d26997a84d570778eae874b2333' },\r\n       cipher: 'aes-128-ctr',\r\n       kdf: 'scrypt',\r\n       kdfparams:\r\n        { dklen: 32,\r\n          salt: '208dd732a27aa4803bb760228dff18515d5313fd085bbce60594a3919ae2d88d',\r\n          n: 262144,\r\n          r: 8,\r\n          p: 1 },\r\n       mac: '0062a853de302513c57bfe3108ab493733034bf3cb313326f42cf26ea2619cf9' } },\r\n     { version: 3,\r\n    id: '7d6b91fa-3611-407b-b16b-396efb28f97e',\r\n    address: 'b5d89661b59a9af0b34f58d19138baa2de48baaf',\r\n    crypto:\r\n     { ciphertext: 'cb9712d1982ff89f571fa5dbef447f14b7e5f142232bd2a913aac833730eeb43',\r\n       cipherparams: { iv: '8cccb91cb84e435437f7282ec2ffd2db' },\r\n       cipher: 'aes-128-ctr',\r\n       kdf: 'scrypt',\r\n       kdfparams:\r\n        { dklen: 32,\r\n          salt: '08ba6736363c5586434cd5b895e6fe41ea7db4785bd9b901dedce77a1514e8b8',\r\n          n: 262144,\r\n          r: 8,\r\n          p: 1 },\r\n       mac: 'd2eb068b37e2df55f56fa97a2bf4f55e072bef0dd703bfd917717d9dc54510f0' } }\r\n  ], 'test');\r\n  > Wallet {\r\n      0: {...},\r\n      1: {...},\r\n      \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\": {...},\r\n      \"0xD0122fC8DF283027b6285cc889F5aA624EaC1d23\": {...}\r\n      ...\r\n  }\r\n */\r\nWallet.prototype.decrypt = function(encryptedWallet, password) {\r\n    const _this = this\r\n\r\n    encryptedWallet.forEach(function(keystore) {\r\n        const account = _this._accounts.decrypt(keystore, password)\r\n\r\n        if (!account) {\r\n            throw new Error(\"Couldn't decrypt the keystore. Maybe wrong password?\")\r\n        }\r\n\r\n        const exist = !!_this[account.address]\r\n        if (!exist) {\r\n            _this.add(account)\r\n        }\r\n    })\r\n\r\n    return this\r\n}\r\n\r\nWallet.prototype.save = function(password, keyName) {\r\n    /* eslint-disable-next-line no-undef */\r\n    localStorage.setItem(keyName || this.defaultKeyName, JSON.stringify(this.encrypt(password)))\r\n\r\n    return true\r\n}\r\n\r\n/**\r\n * cav.klay.accounts.wallet.load('test#!$', 'myWalletKey' || 'web3js_wallet');\r\n    > Wallet {\r\n        0: {...},\r\n        1: {...},\r\n        \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\": {...},\r\n        \"0xD0122fC8DF283027b6285cc889F5aA624EaC1d23\": {...}\r\n        ...\r\n    }\r\n */\r\nWallet.prototype.load = function(password, keyName) {\r\n    /* eslint-disable-next-line no-undef */\r\n    let keystore = localStorage.getItem(keyName || this.defaultKeyName)\r\n\r\n    if (keystore) {\r\n        try {\r\n            keystore = JSON.parse(keystore)\r\n        } catch (e) {}\r\n    }\r\n\r\n    return this.decrypt(keystore || [], password)\r\n}\r\n\r\nif (!storageAvailable('localStorage')) {\r\n    delete Wallet.prototype.save\r\n    delete Wallet.prototype.load\r\n}\r\n\r\n/**\r\n * Checks whether a storage type is available or not\r\n * For more info on how this works, please refer to MDN documentation\r\n * https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API#Feature-detecting_localStorage\r\n *\r\n * @method storageAvailable\r\n * @param {String} type the type of storage ('localStorage', 'sessionStorage')\r\n * @returns {Boolean} a boolean indicating whether the specified storage is available or not\r\n */\r\nfunction storageAvailable(type) {\r\n    let storage\r\n    try {\r\n        // eslint-disable-next-line no-undef\r\n        storage = window[type]\r\n        const x = '__storage_test__'\r\n        storage.setItem(x, x)\r\n        storage.removeItem(x)\r\n        return true\r\n    } catch (e) {\r\n        return (\r\n            e &&\r\n            // everything except Firefox\r\n            (e.code === 22 ||\r\n                // Firefox\r\n                e.code === 1014 ||\r\n                // test name field too, because code might not be present\r\n                // everything except Firefox\r\n                e.name === 'QuotaExceededError' ||\r\n                // Firefox\r\n                e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\r\n            // acknowledge QuotaExceededError only if there's something already stored\r\n            (storage && storage.length !== 0)\r\n        )\r\n    }\r\n}\r\n\r\nWallet.prototype.getKlaytnWalletKey = function(addressOrIndex) {\r\n    const account = this[addressOrIndex]\r\n    if (!account) throw new Error('Failed to find account')\r\n\r\n    return genKlaytnWalletKeyStringFromAccount(account)\r\n}\r\n\r\nWallet.prototype.getAccount = function(input) {\r\n    if (_.isNumber(input)) {\r\n        if (this.length <= input) {\r\n            throw new Error(`The index(${input}) is out of range(Wallet length : ${this.length}).`)\r\n        }\r\n        return this[input]\r\n    }\r\n\r\n    if (!_.isString(input)) {\r\n        throw new Error(`Accounts in the Wallet can be searched by only index or address. :${input}`)\r\n    }\r\n\r\n    if (!utils.isAddress(input)) {\r\n        throw new Error(`Failed to getAccount from Wallet: invalid address(${input})`)\r\n    }\r\n\r\n    return this[input.toLowerCase()]\r\n}\r\n\r\nfunction genKlaytnWalletKeyStringFromAccount(account) {\r\n    if (account.accountKeyType !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) {\r\n        throw new Error('The account cannot be exported in KlaytnWalletKey format. Use caver.klay.accounts.encrypt or account.encrypt.')\r\n    }\r\n    let addressString = account.address\r\n    let { privateKey } = account\r\n\r\n    privateKey = privateKey.slice(0, 2) === '0x' ? privateKey : `0x${privateKey}`\r\n    addressString = addressString.slice(0, 2) === '0x' ? addressString : `0x${addressString}`\r\n\r\n    return `${privateKey}0x00${addressString}`\r\n}\r\n\r\nmodule.exports = Accounts\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}