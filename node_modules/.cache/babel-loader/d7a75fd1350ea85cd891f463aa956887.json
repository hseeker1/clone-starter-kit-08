{"ast":null,"code":"var _asyncToGenerator = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _createForOfIteratorHelper = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\n/*\r\n    Copyright 2020 The caver-js Authors\r\n    This file is part of the caver-js library.\r\n\r\n    The caver-js library is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    The caver-js library is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\r\n*/\nvar _ = require('lodash');\n\nvar Keyring = require('./keyring/keyringFactory');\n\nvar SingleKeyring = require('./keyring/singleKeyring');\n\nvar MultipleKeyring = require('./keyring/multipleKeyring');\n\nvar RoleBasedKeyring = require('./keyring/roleBasedKeyring');\n\nvar utils = require('../../caver-utils/src');\n/**\r\n * @typedef {SingleKeyring|MultipleKeyring|RoleBasedKeyring} KeyringContainer.Keyring\r\n */\n\n/**\r\n * representing a Keyring container which manages keyrings.\r\n *\r\n * @class\r\n * @hideconstructor\r\n */\n\n\nvar KeyringContainer = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\r\n   * Creates a keyringContainer.\r\n   * @param {Array.<KeyringContainer.Keyring>} keyrings - The keyrings to be managed in KeyringContainer.\r\n   */\n  function KeyringContainer(keyrings) {\n    _classCallCheck(this, KeyringContainer);\n\n    keyrings = keyrings || [];\n    this._addressKeyringMap = new Map(); // add keyrings to keyringContainer\n\n    var _iterator = _createForOfIteratorHelper(keyrings),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var keyring = _step.value;\n        this.add(keyring);\n      }\n      /** @type {KeyringFactory} */\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    this.keyring = Keyring;\n  }\n  /**\r\n   * @type {number}\r\n   */\n\n\n  _createClass(KeyringContainer, [{\n    key: \"length\",\n    get: function get() {\n      return this._addressKeyringMap.size;\n    }\n    /**\r\n     * Generates instances of {@link SingleKeyring} in the keyringContainer with randomly generated private keys.\r\n     *\r\n     * @example\r\n     * // without entropy\r\n     * const generated = caver.wallet.generate(3)\r\n     * // with entropy\r\n     * const generated = caver.wallet.generate(3, caver.utils.randomHex(32))\r\n     *\r\n     * @param {number} numberOfKeyrings The number of keyrings to create.\r\n     * @param {string} [entropy] A random string to increase entropy. If undefined, a random string will be generated using randomHex.\r\n     * @return {Array.<string>} An array containing the addresses of the generated.\r\n     */\n\n  }, {\n    key: \"generate\",\n    value: function generate(numberOfKeyrings, entropy) {\n      var addresses = [];\n\n      for (var i = 0; i < numberOfKeyrings; ++i) {\n        addresses.push(this.add(Keyring.generate(entropy)).address);\n      }\n\n      return addresses;\n    }\n    /**\r\n     * Creates a keyring instance with given parameters and adds it to the `caver.wallet`.\r\n     * KeyringContainer manages the Keyring instances using Map<string:{@link KeyringContainer.Keyring|Keyring}> which has address as key value.\r\n     *\r\n     * If `key` is a private key string, a {@link SingleKeyring} instance that uses a single private key is created.\r\n     * If `key` is an array containing private key strings, a {@link MultipleKeyring} instance that use multiple private keys is created.\r\n     * If `key` is a 2D array of which each element contains the private key(s) to be used for each role, a {@link RoleBasedKeyring} instance is created.\r\n     * The keyring created is added to `caver.wallet`.\r\n     *\r\n     * @example\r\n     * // Create a instance of SingleKeyring and add to caver.wallet\r\n     * const singleKeyring = caver.wallet.newKeyring('0x{address in hex}', '0x{private key}')\r\n     *\r\n     * // Create a instance of MultipleKeyring and add to caver.wallet\r\n     * const multipleKeyring = caver.wallet.newKeyring('0x{address in hex}', ['0x{private key1}', '0x{private key2}'])\r\n     *\r\n     * // Create a instance of RoleBasedKeyring and add to caver.wallet\r\n     * const roleBasedKeys = [\r\n     *     ['0x{private key1}', '0x{private key2}'],\r\n     *     ['0x{private key3}', '0x{private key4}'],\r\n     *     ['0x{private key5}', '0x{private key6}'],\r\n     * ]\r\n     * const roleBasedKeyring = caver.wallet.newKeyring('0x{address in hex}', roleBasedKeys)\r\n     *\r\n     * @param {string} address The address of the keyring.\r\n     * @param {string|Array.<string>|Array.<Array.<string>>} key The private key string, an array of private keys, or a 2D array of which each array element contains keys defined for each role.\r\n     * @return {KeyringContainer.Keyring} The keyring instance ({@link SingleKeyring}, {@link MultipleKeyring} or {@link RoleBasedKeyring}) added to `caver.wallet` is returned.\r\n     */\n\n  }, {\n    key: \"newKeyring\",\n    value: function newKeyring(address, key) {\n      // The format of key parameter can be\n      // 1. single private key string   => `0x{private key}`\n      // 2. multiple private key string =>[`0x{private key}`, `0x{private key}`, ...]\n      // 3. role based private keys     => [[`0x{private key}`, `0x{private key}`, ...], [], [`0x{private key}`]]\n      var keyring;\n      if (_.isString(key)) keyring = Keyring.createWithSingleKey(address, key);\n\n      if (_.isArray(key)) {\n        if (key.length === 0) throw new Error(\"Insufficient private key information: Empty array\");\n\n        if (_.isArray(key[0])) {\n          keyring = Keyring.createWithRoleBasedKey(address, key);\n        } else {\n          keyring = Keyring.createWithMultipleKey(address, key);\n        }\n      }\n\n      if (!(keyring instanceof SingleKeyring) && !(keyring instanceof MultipleKeyring) && !(keyring instanceof RoleBasedKeyring)) throw new Error(\"Unsupported type value: \".concat(key, \" (type:\").concat(typeof key, \")\"));\n      return this.add(keyring);\n    }\n    /**\r\n     * Updates the keyring inside the `caver.wallet`.\r\n     * When a new `keyring` instance ({@link SingleKeyring}, {@link MultipleKeyring} or {@link RoleBasedKeyring}) is passed as a parameter, the existing keyring stored in the `caver.wallet` that matches the `address` property of the given `keyring` instance is found and replaced with the given one.\r\n     * An error occurs when the matching `keyring` is not found.\r\n     *\r\n     * @example\r\n     * const updated = caver.wallet.updateKeyring(newKeyring)\r\n     *\r\n     * @param {KeyringContainer.Keyring} keyring The new keyring ({@link SingleKeyring}, {@link MultipleKeyring} or {@link RoleBasedKeyring}) to be stored in `caver.wallet`.\r\n     * @return {KeyringContainer.Keyring} The updated keyring ({@link SingleKeyring}, {@link MultipleKeyring} or {@link RoleBasedKeyring}) stored in `caver.wallet`.\r\n     */\n\n  }, {\n    key: \"updateKeyring\",\n    value: function updateKeyring(keyring) {\n      var founded = this._addressKeyringMap.get(keyring.address.toLowerCase());\n\n      if (founded === undefined) throw new Error(\"Failed to find keyring to update\");\n      this.remove(founded.address);\n      this.add(keyring);\n      return keyring;\n    }\n    /**\r\n     * Returns the keyring instance corresponding to the address in `caver.wallet`.\r\n     * If it fails to find a keyring that maps to the address, it returns `undefined`.\r\n     *\r\n     * @example\r\n     * const keyring = caver.wallet.getKeyring('0x{address in hex}')\r\n     *\r\n     * @param {string} address The address of keyring to query.\r\n     * @return {KeyringContainer.Keyring} The found keyring instance ({@link SingleKeyring}, {@link MultipleKeyring} or {@link RoleBasedKeyring}) stored in caver.wallet.\r\n     */\n\n  }, {\n    key: \"getKeyring\",\n    value: function getKeyring(address) {\n      if (!utils.isAddress(address)) throw new Error(\"Invalid address \".concat(address, \". To get keyring from wallet, you need to pass a valid address string as a parameter.\"));\n\n      var founded = this._addressKeyringMap.get(address.toLowerCase());\n\n      return founded;\n    }\n    /**\r\n     * Returns `true` if there is a keyring matching the address.\r\n     *\r\n     * @example\r\n     * const isExisted = caver.wallet.isExisted('0x{address in hex}')\r\n     *\r\n     * @param {string} address The address of keyring to check existence.\r\n     * @return {boolean} `true` means a keyring matching with the address is existed in the `caver.wallet`.\r\n     */\n\n  }, {\n    key: \"isExisted\",\n    value: function isExisted(address) {\n      return this.getKeyring(address) !== undefined;\n    }\n    /**\r\n     * Adds an instance of `keyring` to the `caver.wallet`.\r\n     * If the newly given `keyring` has the same address with one of the keyrings that already exist in `caver.wallet`, an error is returned.\r\n     * In this case, use {@link KeyringContainer#updateKeyring|updateKeyring} to update the existing keyring in `caver.wallet`.\r\n     *\r\n     * @example\r\n     * const added = caver.wallet.add(keyring)\r\n     *\r\n     * @param {KeyringContainer.Keyring} keyring A keyring instance ({@link SingleKeyring}, {@link MultipleKeyring} or {@link RoleBasedKeyring}) to add to `caver.wallet`.\r\n     * @return {KeyringContainer.Keyring} The added keyring ({@link SingleKeyring}, {@link MultipleKeyring} or {@link RoleBasedKeyring}) in `caver.wallet`.\r\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(keyring) {\n      if (this._addressKeyringMap.get(keyring.address.toLowerCase()) !== undefined) throw new Error(\"Duplicate Account \".concat(keyring.address, \". Please use updateKeyring() instead.\"));\n      var keyringToAdd = keyring.copy();\n\n      this._addressKeyringMap.set(keyringToAdd.address.toLowerCase(), keyringToAdd);\n\n      return keyringToAdd;\n    }\n    /**\r\n     * Deletes the keyring from `caver.wallet` whose address matches the address of the given keyring.\r\n     *\r\n     * @example\r\n     * const isDeleted = caver.wallet.remove('0x{address in hex}')\r\n     *\r\n     * @param {string} address An address of the keyring to be deleted in `caver.wallet`.\r\n     * @return {boolean} `true` if keyring is removed from `caver.wallet`.\r\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(address) {\n      var keyringToRemove;\n\n      if (utils.isAddress(address)) {\n        keyringToRemove = this.getKeyring(address);\n      } else {\n        throw new Error(\"To remove the keyring, the first parameter should be an address string.\");\n      }\n\n      if (keyringToRemove === undefined) return false; // deallocate keyring object created for keyringContainer\n\n      keyringToRemove.keys = null;\n\n      this._addressKeyringMap.delete(keyringToRemove.address.toLowerCase());\n\n      return true;\n    }\n    /**\r\n     * An object that includes signed message.\r\n     *\r\n     * @typedef {object} KeyringContainer.SignedMessage\r\n     * @property {string} messageHash - The hash of message with Klaytn-specific prefix.\r\n     * @property {Array.<SignatureData>} signatures - An array of {@link SignatureData}.\r\n     * @property {string} message - The message to sign.\r\n     */\n\n    /**\r\n     * Signs the message with Klaytn-specific prefix using keyring stored in `caver.wallet`.\r\n     *\r\n     * This calculates a Klaytn-specific signature with:\r\n     * `sign(keccak256(\"\\x19Klaytn Signed Message:\\n\" + len(message) + message)))`.\r\n     *\r\n     * If the user has not provided the `index` parameter, `caver.wallet.signMessage` signs message using all the private keys used by the role.\r\n     * If the `index` parameter is given, `caver.wallet.signMessage` signs message using only one private key at the given index.\r\n     * The role used in caver-js can be found from {@link KeyringFactory.role|caver.wallet.keyring.role}.\r\n     *\r\n     * @example\r\n     * const result = caver.wallet.signMessage('0x{address in hex}', 'message to sign', caver.wallet.keyring.role.roleTransactionKey)\r\n     * const result = caver.wallet.signMessage('0x{address in hex}', 'message to sign', caver.wallet.keyring.role.roleTransactionKey, 0)\r\n     *\r\n     * @param {string} address An address of keyring in keyringContainer.\r\n     * @param {string} message The message to sign.\r\n     * @param {number} role A number indicating the role of the key. You can use {@link KeyringFactory.role|caver.wallet.keyring.role}.\r\n     * @param {number} [index] The index of the private key you want to use. The index must be less than the length of the array of the private keys defined for each role. If an index is not defined, this method will use all the private keys.\r\n     * @return {KeyringContainer.SignedMessage} An object that includes the result of signing.\r\n     */\n\n  }, {\n    key: \"signMessage\",\n    value: function signMessage(address, message, role, index) {\n      var keyring = this.getKeyring(address);\n      if (keyring === undefined) throw new Error(\"Failed to find keyring from wallet with \".concat(address));\n      return keyring.signMessage(message, role, index);\n    }\n    /**\r\n     * Signs the transaction as a `sender` of the transaction and appends `signatures` in the transaction object using the keyring in `caver.wallet`.\r\n     *\r\n     * For {@link AccountUpdate|Account Update} transaction, use \"roleAccountUpdateKey\", or otherwise, use \"roleTransactionKey\" in {@link RoleBasedKeyring}.\r\n     * If the user has not defined an `index`, `transaction.sign` signs the transaction using \"all the private keys\" used by the role.\r\n     * If `index` is defined, the `transaction.sign` signs the transaction using \"only one private key\" at the given index.\r\n     *\r\n     * @example\r\n     * const signed = await caver.wallet.sign('0x{address in hex}', transaction)\r\n     * const signed = await caver.wallet.sign('0x{address in hex}', transaction, 0)\r\n     *\r\n     * @param {string} address An address of the keyring to be used.\r\n     * @param {module:Transaction.Transaction} transaction An instance of {@link module:Transaction.Transaction|Transaction}.\r\n     * @param {number} [index] The index of the private key you want to use. The index must be less than the length of the array of the private keys defined for each role. If an index is not defined, this method will use all the private keys.\r\n     * @param {function} [hasher] A hash function to get the transaction hash. If hasher is given as a parameter, it calculates the transaction hash instead of the default method for calculating transaction hash implemented in caver-js. See {@link https://docs.klaytn.com/klaytn/design/transactions/basic|Klaytn Docs} for details about the default method for transaction hash generation.\r\n     * @return {Promise<module:Transaction.Transaction>} The signed transaction.\r\n     */\n\n  }, {\n    key: \"sign\",\n    value: function () {\n      var _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(address, transaction, index, hasher) {\n        var keyring, signed;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                keyring = this.getKeyring(address);\n\n                if (!(keyring === undefined)) {\n                  _context.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Failed to find keyring from wallet with \".concat(address));\n\n              case 3:\n                _context.next = 5;\n                return transaction.sign(keyring, index, hasher);\n\n              case 5:\n                signed = _context.sent;\n                return _context.abrupt(\"return\", signed);\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function sign(_x, _x2, _x3, _x4) {\n        return _sign.apply(this, arguments);\n      }\n\n      return sign;\n    }()\n    /**\r\n     * Signs the transaction as fee payer of the transaction and appends `feePayerSignatures` in the transaction object using the keyring in `caver.wallet`.\r\n     *\r\n     * This will use \"roleFeePayerKey\" in {@link RoleBasedKeyring}.\r\n     * If the user has not defined an `index`, `transaction.signAsFeePayer` signs the transaction using \"all the private keys\" used by the role.\r\n     * If `index` is defined, the `transaction.signAsFeePayer` signs the transaction using \"only one private key\" at the given index.\r\n     *\r\n     * If the `transaction.feePayer` is not defined, the address of keyring which is founded from `caver.wallet` is assigned.\r\n     *\r\n     * @example\r\n     * const signed = await caver.wallet.signAsFeePayer('0x{address in hex}', transaction)\r\n     * const signed = await caver.wallet.signAsFeePayer('0x{address in hex}', transaction, 0)\r\n     *\r\n     * @param {string} address An address of the keyring to be used.\r\n     * @param {module:Transaction.FeeDelegatedTransaction} transaction An instance of {@link module:Transaction.FeeDelegatedTransaction|FeeDelegatedTransaction}.\r\n     * @param {number} [index] The index of the private key you want to use. The index must be less than the length of the array of the private keys defined for each role. If an index is not defined, this method will use all the private keys.\r\n     * @param {function} [hasher] A function to get the transaction hash. If hasher is defined as a parameter, this is used to get the transaction hash instead of a default implementation in caver-js.\r\n     * @return {Promise<module:Transaction.FeeDelegatedTransaction>} The fee payer signed transaction.\r\n     */\n\n  }, {\n    key: \"signAsFeePayer\",\n    value: function () {\n      var _signAsFeePayer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(address, transaction, index, hasher) {\n        var keyring, signed;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                keyring = this.getKeyring(address);\n\n                if (!(keyring === undefined)) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Failed to find keyring from wallet with \".concat(address));\n\n              case 3:\n                _context2.next = 5;\n                return transaction.signAsFeePayer(keyring, index, hasher);\n\n              case 5:\n                signed = _context2.sent;\n                return _context2.abrupt(\"return\", signed);\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function signAsFeePayer(_x5, _x6, _x7, _x8) {\n        return _signAsFeePayer.apply(this, arguments);\n      }\n\n      return signAsFeePayer;\n    }()\n  }]);\n\n  return KeyringContainer;\n}();\n\nmodule.exports = KeyringContainer;","map":{"version":3,"names":["_","require","Keyring","SingleKeyring","MultipleKeyring","RoleBasedKeyring","utils","KeyringContainer","keyrings","_addressKeyringMap","Map","keyring","add","size","numberOfKeyrings","entropy","addresses","i","push","generate","address","key","isString","createWithSingleKey","isArray","length","Error","createWithRoleBasedKey","createWithMultipleKey","founded","get","toLowerCase","undefined","remove","isAddress","getKeyring","keyringToAdd","copy","set","keyringToRemove","keys","delete","message","role","index","signMessage","transaction","hasher","sign","signed","signAsFeePayer","module","exports"],"sources":["C:/Users/User/Documents/clone-starter-kit-08/node_modules/caver-js/packages/caver-wallet/src/index.js"],"sourcesContent":["/*\r\n    Copyright 2020 The caver-js Authors\r\n    This file is part of the caver-js library.\r\n\r\n    The caver-js library is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    The caver-js library is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst _ = require('lodash')\r\nconst Keyring = require('./keyring/keyringFactory')\r\nconst SingleKeyring = require('./keyring/singleKeyring')\r\nconst MultipleKeyring = require('./keyring/multipleKeyring')\r\nconst RoleBasedKeyring = require('./keyring/roleBasedKeyring')\r\nconst utils = require('../../caver-utils/src')\r\n\r\n/**\r\n * @typedef {SingleKeyring|MultipleKeyring|RoleBasedKeyring} KeyringContainer.Keyring\r\n */\r\n\r\n/**\r\n * representing a Keyring container which manages keyrings.\r\n *\r\n * @class\r\n * @hideconstructor\r\n */\r\nclass KeyringContainer {\r\n    /**\r\n     * Creates a keyringContainer.\r\n     * @param {Array.<KeyringContainer.Keyring>} keyrings - The keyrings to be managed in KeyringContainer.\r\n     */\r\n    constructor(keyrings) {\r\n        keyrings = keyrings || []\r\n        this._addressKeyringMap = new Map()\r\n\r\n        // add keyrings to keyringContainer\r\n        for (const keyring of keyrings) {\r\n            this.add(keyring)\r\n        }\r\n\r\n        /** @type {KeyringFactory} */\r\n        this.keyring = Keyring\r\n    }\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    get length() {\r\n        return this._addressKeyringMap.size\r\n    }\r\n\r\n    /**\r\n     * Generates instances of {@link SingleKeyring} in the keyringContainer with randomly generated private keys.\r\n     *\r\n     * @example\r\n     * // without entropy\r\n     * const generated = caver.wallet.generate(3)\r\n     * // with entropy\r\n     * const generated = caver.wallet.generate(3, caver.utils.randomHex(32))\r\n     *\r\n     * @param {number} numberOfKeyrings The number of keyrings to create.\r\n     * @param {string} [entropy] A random string to increase entropy. If undefined, a random string will be generated using randomHex.\r\n     * @return {Array.<string>} An array containing the addresses of the generated.\r\n     */\r\n    generate(numberOfKeyrings, entropy) {\r\n        const addresses = []\r\n        for (let i = 0; i < numberOfKeyrings; ++i) {\r\n            addresses.push(this.add(Keyring.generate(entropy)).address)\r\n        }\r\n        return addresses\r\n    }\r\n\r\n    /**\r\n     * Creates a keyring instance with given parameters and adds it to the `caver.wallet`.\r\n     * KeyringContainer manages the Keyring instances using Map<string:{@link KeyringContainer.Keyring|Keyring}> which has address as key value.\r\n     *\r\n     * If `key` is a private key string, a {@link SingleKeyring} instance that uses a single private key is created.\r\n     * If `key` is an array containing private key strings, a {@link MultipleKeyring} instance that use multiple private keys is created.\r\n     * If `key` is a 2D array of which each element contains the private key(s) to be used for each role, a {@link RoleBasedKeyring} instance is created.\r\n     * The keyring created is added to `caver.wallet`.\r\n     *\r\n     * @example\r\n     * // Create a instance of SingleKeyring and add to caver.wallet\r\n     * const singleKeyring = caver.wallet.newKeyring('0x{address in hex}', '0x{private key}')\r\n     *\r\n     * // Create a instance of MultipleKeyring and add to caver.wallet\r\n     * const multipleKeyring = caver.wallet.newKeyring('0x{address in hex}', ['0x{private key1}', '0x{private key2}'])\r\n     *\r\n     * // Create a instance of RoleBasedKeyring and add to caver.wallet\r\n     * const roleBasedKeys = [\r\n     *     ['0x{private key1}', '0x{private key2}'],\r\n     *     ['0x{private key3}', '0x{private key4}'],\r\n     *     ['0x{private key5}', '0x{private key6}'],\r\n     * ]\r\n     * const roleBasedKeyring = caver.wallet.newKeyring('0x{address in hex}', roleBasedKeys)\r\n     *\r\n     * @param {string} address The address of the keyring.\r\n     * @param {string|Array.<string>|Array.<Array.<string>>} key The private key string, an array of private keys, or a 2D array of which each array element contains keys defined for each role.\r\n     * @return {KeyringContainer.Keyring} The keyring instance ({@link SingleKeyring}, {@link MultipleKeyring} or {@link RoleBasedKeyring}) added to `caver.wallet` is returned.\r\n     */\r\n    newKeyring(address, key) {\r\n        // The format of key parameter can be\r\n        // 1. single private key string   => `0x{private key}`\r\n        // 2. multiple private key string =>[`0x{private key}`, `0x{private key}`, ...]\r\n        // 3. role based private keys     => [[`0x{private key}`, `0x{private key}`, ...], [], [`0x{private key}`]]\r\n\r\n        let keyring\r\n\r\n        if (_.isString(key)) keyring = Keyring.createWithSingleKey(address, key)\r\n\r\n        if (_.isArray(key)) {\r\n            if (key.length === 0) throw new Error(`Insufficient private key information: Empty array`)\r\n            if (_.isArray(key[0])) {\r\n                keyring = Keyring.createWithRoleBasedKey(address, key)\r\n            } else {\r\n                keyring = Keyring.createWithMultipleKey(address, key)\r\n            }\r\n        }\r\n\r\n        if (!(keyring instanceof SingleKeyring) && !(keyring instanceof MultipleKeyring) && !(keyring instanceof RoleBasedKeyring))\r\n            throw new Error(`Unsupported type value: ${key} (type:${typeof key})`)\r\n\r\n        return this.add(keyring)\r\n    }\r\n\r\n    /**\r\n     * Updates the keyring inside the `caver.wallet`.\r\n     * When a new `keyring` instance ({@link SingleKeyring}, {@link MultipleKeyring} or {@link RoleBasedKeyring}) is passed as a parameter, the existing keyring stored in the `caver.wallet` that matches the `address` property of the given `keyring` instance is found and replaced with the given one.\r\n     * An error occurs when the matching `keyring` is not found.\r\n     *\r\n     * @example\r\n     * const updated = caver.wallet.updateKeyring(newKeyring)\r\n     *\r\n     * @param {KeyringContainer.Keyring} keyring The new keyring ({@link SingleKeyring}, {@link MultipleKeyring} or {@link RoleBasedKeyring}) to be stored in `caver.wallet`.\r\n     * @return {KeyringContainer.Keyring} The updated keyring ({@link SingleKeyring}, {@link MultipleKeyring} or {@link RoleBasedKeyring}) stored in `caver.wallet`.\r\n     */\r\n    updateKeyring(keyring) {\r\n        const founded = this._addressKeyringMap.get(keyring.address.toLowerCase())\r\n        if (founded === undefined) throw new Error(`Failed to find keyring to update`)\r\n\r\n        this.remove(founded.address)\r\n        this.add(keyring)\r\n\r\n        return keyring\r\n    }\r\n\r\n    /**\r\n     * Returns the keyring instance corresponding to the address in `caver.wallet`.\r\n     * If it fails to find a keyring that maps to the address, it returns `undefined`.\r\n     *\r\n     * @example\r\n     * const keyring = caver.wallet.getKeyring('0x{address in hex}')\r\n     *\r\n     * @param {string} address The address of keyring to query.\r\n     * @return {KeyringContainer.Keyring} The found keyring instance ({@link SingleKeyring}, {@link MultipleKeyring} or {@link RoleBasedKeyring}) stored in caver.wallet.\r\n     */\r\n    getKeyring(address) {\r\n        if (!utils.isAddress(address))\r\n            throw new Error(\r\n                `Invalid address ${address}. To get keyring from wallet, you need to pass a valid address string as a parameter.`\r\n            )\r\n\r\n        const founded = this._addressKeyringMap.get(address.toLowerCase())\r\n\r\n        return founded\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if there is a keyring matching the address.\r\n     *\r\n     * @example\r\n     * const isExisted = caver.wallet.isExisted('0x{address in hex}')\r\n     *\r\n     * @param {string} address The address of keyring to check existence.\r\n     * @return {boolean} `true` means a keyring matching with the address is existed in the `caver.wallet`.\r\n     */\r\n    isExisted(address) {\r\n        return this.getKeyring(address) !== undefined\r\n    }\r\n\r\n    /**\r\n     * Adds an instance of `keyring` to the `caver.wallet`.\r\n     * If the newly given `keyring` has the same address with one of the keyrings that already exist in `caver.wallet`, an error is returned.\r\n     * In this case, use {@link KeyringContainer#updateKeyring|updateKeyring} to update the existing keyring in `caver.wallet`.\r\n     *\r\n     * @example\r\n     * const added = caver.wallet.add(keyring)\r\n     *\r\n     * @param {KeyringContainer.Keyring} keyring A keyring instance ({@link SingleKeyring}, {@link MultipleKeyring} or {@link RoleBasedKeyring}) to add to `caver.wallet`.\r\n     * @return {KeyringContainer.Keyring} The added keyring ({@link SingleKeyring}, {@link MultipleKeyring} or {@link RoleBasedKeyring}) in `caver.wallet`.\r\n     */\r\n    add(keyring) {\r\n        if (this._addressKeyringMap.get(keyring.address.toLowerCase()) !== undefined)\r\n            throw new Error(`Duplicate Account ${keyring.address}. Please use updateKeyring() instead.`)\r\n\r\n        const keyringToAdd = keyring.copy()\r\n\r\n        this._addressKeyringMap.set(keyringToAdd.address.toLowerCase(), keyringToAdd)\r\n\r\n        return keyringToAdd\r\n    }\r\n\r\n    /**\r\n     * Deletes the keyring from `caver.wallet` whose address matches the address of the given keyring.\r\n     *\r\n     * @example\r\n     * const isDeleted = caver.wallet.remove('0x{address in hex}')\r\n     *\r\n     * @param {string} address An address of the keyring to be deleted in `caver.wallet`.\r\n     * @return {boolean} `true` if keyring is removed from `caver.wallet`.\r\n     */\r\n    remove(address) {\r\n        let keyringToRemove\r\n        if (utils.isAddress(address)) {\r\n            keyringToRemove = this.getKeyring(address)\r\n        } else {\r\n            throw new Error(`To remove the keyring, the first parameter should be an address string.`)\r\n        }\r\n\r\n        if (keyringToRemove === undefined) return false\r\n\r\n        // deallocate keyring object created for keyringContainer\r\n        keyringToRemove.keys = null\r\n        this._addressKeyringMap.delete(keyringToRemove.address.toLowerCase())\r\n\r\n        return true\r\n    }\r\n\r\n    /**\r\n     * An object that includes signed message.\r\n     *\r\n     * @typedef {object} KeyringContainer.SignedMessage\r\n     * @property {string} messageHash - The hash of message with Klaytn-specific prefix.\r\n     * @property {Array.<SignatureData>} signatures - An array of {@link SignatureData}.\r\n     * @property {string} message - The message to sign.\r\n     */\r\n    /**\r\n     * Signs the message with Klaytn-specific prefix using keyring stored in `caver.wallet`.\r\n     *\r\n     * This calculates a Klaytn-specific signature with:\r\n     * `sign(keccak256(\"\\x19Klaytn Signed Message:\\n\" + len(message) + message)))`.\r\n     *\r\n     * If the user has not provided the `index` parameter, `caver.wallet.signMessage` signs message using all the private keys used by the role.\r\n     * If the `index` parameter is given, `caver.wallet.signMessage` signs message using only one private key at the given index.\r\n     * The role used in caver-js can be found from {@link KeyringFactory.role|caver.wallet.keyring.role}.\r\n     *\r\n     * @example\r\n     * const result = caver.wallet.signMessage('0x{address in hex}', 'message to sign', caver.wallet.keyring.role.roleTransactionKey)\r\n     * const result = caver.wallet.signMessage('0x{address in hex}', 'message to sign', caver.wallet.keyring.role.roleTransactionKey, 0)\r\n     *\r\n     * @param {string} address An address of keyring in keyringContainer.\r\n     * @param {string} message The message to sign.\r\n     * @param {number} role A number indicating the role of the key. You can use {@link KeyringFactory.role|caver.wallet.keyring.role}.\r\n     * @param {number} [index] The index of the private key you want to use. The index must be less than the length of the array of the private keys defined for each role. If an index is not defined, this method will use all the private keys.\r\n     * @return {KeyringContainer.SignedMessage} An object that includes the result of signing.\r\n     */\r\n    signMessage(address, message, role, index) {\r\n        const keyring = this.getKeyring(address)\r\n        if (keyring === undefined) throw new Error(`Failed to find keyring from wallet with ${address}`)\r\n        return keyring.signMessage(message, role, index)\r\n    }\r\n\r\n    /**\r\n     * Signs the transaction as a `sender` of the transaction and appends `signatures` in the transaction object using the keyring in `caver.wallet`.\r\n     *\r\n     * For {@link AccountUpdate|Account Update} transaction, use \"roleAccountUpdateKey\", or otherwise, use \"roleTransactionKey\" in {@link RoleBasedKeyring}.\r\n     * If the user has not defined an `index`, `transaction.sign` signs the transaction using \"all the private keys\" used by the role.\r\n     * If `index` is defined, the `transaction.sign` signs the transaction using \"only one private key\" at the given index.\r\n     *\r\n     * @example\r\n     * const signed = await caver.wallet.sign('0x{address in hex}', transaction)\r\n     * const signed = await caver.wallet.sign('0x{address in hex}', transaction, 0)\r\n     *\r\n     * @param {string} address An address of the keyring to be used.\r\n     * @param {module:Transaction.Transaction} transaction An instance of {@link module:Transaction.Transaction|Transaction}.\r\n     * @param {number} [index] The index of the private key you want to use. The index must be less than the length of the array of the private keys defined for each role. If an index is not defined, this method will use all the private keys.\r\n     * @param {function} [hasher] A hash function to get the transaction hash. If hasher is given as a parameter, it calculates the transaction hash instead of the default method for calculating transaction hash implemented in caver-js. See {@link https://docs.klaytn.com/klaytn/design/transactions/basic|Klaytn Docs} for details about the default method for transaction hash generation.\r\n     * @return {Promise<module:Transaction.Transaction>} The signed transaction.\r\n     */\r\n    async sign(address, transaction, index, hasher) {\r\n        const keyring = this.getKeyring(address)\r\n        if (keyring === undefined) throw new Error(`Failed to find keyring from wallet with ${address}`)\r\n        const signed = await transaction.sign(keyring, index, hasher)\r\n\r\n        return signed\r\n    }\r\n\r\n    /**\r\n     * Signs the transaction as fee payer of the transaction and appends `feePayerSignatures` in the transaction object using the keyring in `caver.wallet`.\r\n     *\r\n     * This will use \"roleFeePayerKey\" in {@link RoleBasedKeyring}.\r\n     * If the user has not defined an `index`, `transaction.signAsFeePayer` signs the transaction using \"all the private keys\" used by the role.\r\n     * If `index` is defined, the `transaction.signAsFeePayer` signs the transaction using \"only one private key\" at the given index.\r\n     *\r\n     * If the `transaction.feePayer` is not defined, the address of keyring which is founded from `caver.wallet` is assigned.\r\n     *\r\n     * @example\r\n     * const signed = await caver.wallet.signAsFeePayer('0x{address in hex}', transaction)\r\n     * const signed = await caver.wallet.signAsFeePayer('0x{address in hex}', transaction, 0)\r\n     *\r\n     * @param {string} address An address of the keyring to be used.\r\n     * @param {module:Transaction.FeeDelegatedTransaction} transaction An instance of {@link module:Transaction.FeeDelegatedTransaction|FeeDelegatedTransaction}.\r\n     * @param {number} [index] The index of the private key you want to use. The index must be less than the length of the array of the private keys defined for each role. If an index is not defined, this method will use all the private keys.\r\n     * @param {function} [hasher] A function to get the transaction hash. If hasher is defined as a parameter, this is used to get the transaction hash instead of a default implementation in caver-js.\r\n     * @return {Promise<module:Transaction.FeeDelegatedTransaction>} The fee payer signed transaction.\r\n     */\r\n    async signAsFeePayer(address, transaction, index, hasher) {\r\n        const keyring = this.getKeyring(address)\r\n        if (keyring === undefined) throw new Error(`Failed to find keyring from wallet with ${address}`)\r\n        const signed = await transaction.signAsFeePayer(keyring, index, hasher)\r\n\r\n        return signed\r\n    }\r\n}\r\n\r\nmodule.exports = KeyringContainer\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}