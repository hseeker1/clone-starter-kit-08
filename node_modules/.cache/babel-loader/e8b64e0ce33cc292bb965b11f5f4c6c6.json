{"ast":null,"code":"var _createForOfIteratorHelper = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\n/*\r\n    Copyright 2020 The caver-js Authors\r\n    This file is part of the caver-js library.\r\n\r\n    The caver-js library is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    The caver-js library is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\r\n*/\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable class-methods-use-this */\nvar _ = require('lodash');\n\nvar utils = require('../../../caver-utils');\n\nvar PrivateKey = require('./privateKey');\n\nvar _require = require('./keyringHelper'),\n    KEY_ROLE = _require.KEY_ROLE,\n    MAXIMUM_KEY_NUM = _require.MAXIMUM_KEY_NUM,\n    isMultipleKeysFormat = _require.isMultipleKeysFormat,\n    isRoleBasedKeysFormat = _require.isRoleBasedKeysFormat;\n\nvar Account = require('../../../caver-account');\n\nvar _require2 = require('../../../caver-account/src/accountKey/accountKeyHelper'),\n    fillWeightedMultiSigOptionsForRoleBased = _require2.fillWeightedMultiSigOptionsForRoleBased;\n\nvar _require3 = require('./keyringHelper'),\n    validateForSigning = _require3.validateForSigning,\n    validateIndexWithKeys = _require3.validateIndexWithKeys,\n    encryptKey = _require3.encryptKey,\n    formatEncrypted = _require3.formatEncrypted;\n/**\r\n * `RoleBasedKeyring` is a class that stores the address of the account and the private keys to be used for each role in the form of an array.\r\n *\r\n * `RoleBasedKeyring` defines keys which is implemented as a two-dimensional array (empty keys looks like `[ [], [], [] ]`) that can include multiple keys for each role.\r\n * The first array element defines the private key(s) for `roleTransactionKey`, the second defines private key(s) for `roleAccountUpdateKey`, and the third defines the private key(s) for `roleFeePayerKey`.\r\n *\r\n * @class\r\n * @hideconstructor\r\n */\n\n\nvar RoleBasedKeyring = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\r\n   * creates a RoleBasedKeyring.\r\n   * @param {string} address - The address of keyring.\r\n   * @param {Array.<Array<string>>|Array.<Array<PrivateKey>>} keys - The keys to use in RoleBasedKeyring.\r\n   */\n  function RoleBasedKeyring(address, keys) {\n    _classCallCheck(this, RoleBasedKeyring);\n\n    this.address = address;\n    this.keys = keys;\n  }\n  /**\r\n   * @type {string}\r\n   */\n\n\n  _createClass(RoleBasedKeyring, [{\n    key: \"type\",\n    get: function get() {\n      return 'RoleBasedKeyring';\n    },\n    set: function set(t) {\n      throw new Error(\"keyring type cannot be set.\");\n    }\n    /**\r\n     * @type {string}\r\n     */\n\n  }, {\n    key: \"address\",\n    get: function get() {\n      return this._address;\n    },\n    set: function set(addressInput) {\n      if (!utils.isAddress(addressInput)) throw new Error(\"Invalid address : \".concat(addressInput));\n      this._address = utils.addHexPrefix(addressInput).toLowerCase();\n    }\n    /**\r\n     * @type {Array.<Array.<PrivateKey>>}\r\n     */\n\n  }, {\n    key: \"keys\",\n    get: function get() {\n      return this._keys;\n    },\n    set: function set(keyInput) {\n      if (keyInput === null) {\n        this._key = null;\n        return;\n      }\n\n      this._keys = formattingForKeyInKeyring(keyInput);\n    }\n    /**\r\n     * @type {Array.<PrivateKey>}\r\n     */\n\n  }, {\n    key: \"roleTransactionKey\",\n    get: function get() {\n      return this.getKeyByRole(KEY_ROLE.roleTransactionKey);\n    }\n    /**\r\n     * @type {Array.<PrivateKey>}\r\n     */\n\n  }, {\n    key: \"roleAccountUpdateKey\",\n    get: function get() {\n      return this.getKeyByRole(KEY_ROLE.roleAccountUpdateKey);\n    }\n    /**\r\n     * @type {Array.<PrivateKey>}\r\n     */\n\n  }, {\n    key: \"roleFeePayerKey\",\n    get: function get() {\n      return this.getKeyByRole(KEY_ROLE.roleFeePayerKey);\n    }\n    /**\r\n     * Returns public key strings for each roles.\r\n     *\r\n     * @example\r\n     * const publicKeys = keyring.getPublicKey()\r\n     *\r\n     * @param {boolean} [compressed] Whether in compressed format or not.\r\n     * @return {Array.<Array<string>>} The public keys of the keyring.\r\n     */\n\n  }, {\n    key: \"getPublicKey\",\n    value: function getPublicKey() {\n      var compressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var publicKeys = generateKeysFormat();\n\n      for (var i = 0; i < KEY_ROLE.roleLast; i++) {\n        var _iterator = _createForOfIteratorHelper(this._keys[i]),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var k = _step.value;\n            publicKeys[i].push(k.getPublicKey(compressed));\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      return publicKeys;\n    }\n    /**\r\n     * Returns a copied RoleBasedKeyring instance.\r\n     *\r\n     * @example\r\n     * const copied = keyring.copy()\r\n     *\r\n     * @return {RoleBasedKeyring} A copied RoleBasedKeyring instance.\r\n     */\n\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      return new RoleBasedKeyring(this.address, this.keys);\n    }\n    /**\r\n     * Signs with transactionHash with the private keys and returns signatures.\r\n     *\r\n     * If you want to define an `index` when using RoleBasedKeyring, the `index` must be less than the length of the specific role key.\r\n     * And `RoleBasedKeyring` has the private key(s) defined by {@link KeyringFactory.role|caver.wallet.keyring.role}, so signs using the key(s) defined in the role.\r\n     *\r\n     * If the user has not defined an `index` parameter, `keyring.sign` signs transaction using all the private keys used by the role.\r\n     * If `index` is defined, the `keyring.sign` signs transaction using only one private key at the index.\r\n     * The role used in caver-js can be checked through {@link KeyringFactory.role|caver.wallet.keyring.role}.\r\n     *\r\n     * @param {string} transactionHash The hash of transaction.\r\n     * @param {string|number} chainId The chainId specific to the network.\r\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\r\n     * @param {number} [index] The index of the key to be used. If index is undefined, all private keys in keyring will be used.\r\n     * @return {SignatureData|Array.<SignatureData>} A {@link SignatureData} when `index` is deinfed, otherwise an array of {@link SignatureData}.\r\n     */\n\n  }, {\n    key: \"sign\",\n    value: function sign(transactionHash, chainId, role, index) {\n      validateForSigning(transactionHash, chainId);\n      var keys = this.getKeyByRole(role);\n\n      if (index !== undefined) {\n        validateIndexWithKeys(index, keys.length);\n        return keys[index].sign(transactionHash, chainId);\n      }\n\n      var signatures = [];\n\n      var _iterator2 = _createForOfIteratorHelper(keys),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var k = _step2.value;\n          signatures.push(k.sign(transactionHash, chainId));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return signatures;\n    }\n    /**\r\n     * Signs with transactionHash with the private keys and returns signatures which V is 0 or 1 (parity of the y-value of a secp256k1 signature).\r\n     *\r\n     * If you want to define an `index` when using RoleBasedKeyring, the `index` must be less than the length of the specific role key.\r\n     * And `RoleBasedKeyring` has the private key(s) defined by {@link KeyringFactory.role|caver.wallet.keyring.role}, so signs using the key(s) defined in the role.\r\n     *\r\n     * If the user has not defined an `index` parameter, `keyring.sign` signs transaction using all the private keys used by the role.\r\n     * If `index` is defined, the `keyring.sign` signs transaction using only one private key at the index.\r\n     * The role used in caver-js can be checked through {@link KeyringFactory.role|caver.wallet.keyring.role}.\r\n     *\r\n     * @example\r\n     * const signed = keyring.ecsign('0xe9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550', caver.wallet.keyring.role.roleTransactionKey)\r\n     * const signed = keyring.ecsign('0xe9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550', caver.wallet.keyring.role.roleAccountUpdateKey, 1)\r\n     *\r\n     * @param {string} hash The hashed data to sign.\r\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\r\n     * @param {number} [index] The index of the key to be used. If index is undefined, all private keys in keyring will be used.\r\n     * @return {SignatureData|Array.<SignatureData>} A {@link SignatureData} when `index` is deinfed, otherwise an array of {@link SignatureData}.\r\n     */\n\n  }, {\n    key: \"ecsign\",\n    value: function ecsign(hash, role, index) {\n      if (!utils.isValidHashStrict(hash)) throw new Error(\"Invalid hash: \".concat(hash));\n      var keys = this.getKeyByRole(role);\n\n      if (index !== undefined) {\n        validateIndexWithKeys(index, keys.length);\n        return keys[index].ecsign(hash);\n      }\n\n      var signatures = [];\n\n      var _iterator3 = _createForOfIteratorHelper(keys),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var k = _step3.value;\n          signatures.push(k.ecsign(hash));\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return signatures;\n    }\n    /**\r\n     * Signs message with Klaytn-specific prefix.\r\n     *\r\n     * This calculates a Klaytn-specific signature with:\r\n     * `sign(keccak256(\"\\x19Klaytn Signed Message:\\n\" + len(message) + message)))`.\r\n     *\r\n     * If you want to define an `index` when using RoleBasedKeyring, the `index` must be less than the length of the specific role key.\r\n     * And `RoleBasedKeyring` has the private key(s) defined by {@link KeyringFactory.role|caver.wallet.keyring.role}, so signs using the key(s) defined in the role.\r\n     *\r\n     * If the user has not provided the `index` parameter, `caver.wallet.signMessage` signs message using all the private keys used by the role.\r\n     * If the `index` parameter is given, `caver.wallet.signMessage` signs message using only one private key at the given index.\r\n     * The role used in caver-js can be found from {@link KeyringFactory.role|caver.wallet.keyring.role}.\r\n     *\r\n     * @example\r\n     * const signed = keyring.signMessage('message to sign', caver.wallet.keyring.role.roleTransactionKey)\r\n     *\r\n     * @param {string} message The message string to sign.\r\n     * @param {number} role A number indicating the role of the key. You can use {@link KeyringFactory.role|caver.wallet.keyring.role}.\r\n     * @param {number} [index] The index of the key to be used.\r\n     * @return {KeyringContainer.SignedMessage} An object that includes the result of signing.\r\n     */\n\n  }, {\n    key: \"signMessage\",\n    value: function signMessage(message, role, index) {\n      if (role === undefined) throw new Error(\"role should be defined for signMessage. Please use 'caver.wallet.keyring.role'.\");\n      var messageHash = utils.hashMessage(message);\n      var keys = this.getKeyByRole(role);\n      var signatures = [];\n\n      if (index !== undefined) {\n        validateIndexWithKeys(index, keys.length);\n        signatures.push(keys[index].signMessage(messageHash));\n      } else {\n        var _iterator4 = _createForOfIteratorHelper(keys),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var k = _step4.value;\n            signatures.push(k.signMessage(messageHash));\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n\n      return {\n        messageHash: messageHash,\n        signatures: signatures,\n        message: message\n      };\n    }\n    /**\r\n     * Returns the private key(s) used by the role entered as a parameter.\r\n     *\r\n     * @example\r\n     * const key = keyring.getKeyByRole(caver.wallet.keyring.role.roleTransactionKey)\r\n     *\r\n     * @param {number} role A number indicating the role of the key. You can use {@link KeyringFactory.role|caver.wallet.keyring.role}.\r\n     * @return {Array.<PrivateKey>} An instance of PrivateKey.\r\n     */\n\n  }, {\n    key: \"getKeyByRole\",\n    value: function getKeyByRole(role) {\n      if (role === undefined) throw new Error(\"role should be defined.\");\n      if (role >= KEY_ROLE.roleLast || role < 0) throw new Error(\"Invalid role number: \".concat(role));\n      var key = this._keys[role];\n\n      if (key.length === 0 && role > KEY_ROLE.roleTransactionKey) {\n        if (this._keys[KEY_ROLE.roleTransactionKey].length === 0) {\n          throw new Error(\"The key with \".concat(KEY_ROLE[role], \" role does not exist. The \").concat(KEY_ROLE[0], \" for the default role is also empty.\"));\n        }\n\n        key = this._keys[KEY_ROLE.roleTransactionKey];\n      }\n\n      return key;\n    }\n    /**\r\n     * Returns the {@link Account} instance for updating the {@link Account.AccountKey|AccountKey} of the Klaytn accounts.\r\n     * The {@link Account} instance has an {@link Account.AccountKey|AccountKey} instance that can contain public key(s) inside, which will be sent to Klaytn Network and used for validating transactions.\r\n     * Please note that if you update the AccountKey of the Account stored in the Klaytn, the old private key(s) cannot be used anymore.\r\n     *\r\n     * `RoleBasedKeyring` returns an {@link Account} instance that includes the address in the keyring and an instance of {@link AccountKeyRoleBased}.\r\n     *\r\n     * @example\r\n     * const account = keyring.toAccount()\r\n     *\r\n     * @param {Array.<WeightedMultiSigOptions>} [options] An array of the `WeightedMultiSigOptions` instances containing information that should be defined when updating your existing account to the one with a number of private keys. The `RoleBasedKeyring` uses different private keys for each role, a `WeightedMultiSigOptions` instance must be defined for each role in an array. If multiple keys are used and `options` are not defined for specific role, defualt WeightedMultiSigOptions (`{ threshold: 1, weights: [1, 1...}}`) is used.\r\n     * @return {Account} An Account instance to be used when a user updates AccountKey for their account in the Klaytn. Note that if you want to replace the existing keyring (or the existing private key) with a new keyring (or a new private key) for your account, you must update your AccountKey by sending an Account Update transaction to Klaytn beforehand.\r\n     */\n\n  }, {\n    key: \"toAccount\",\n    value: function toAccount(options) {\n      if (options !== undefined && !_.isArray(options)) throw new Error(\"options for an account should define threshold and weight for each roles in an array format\");\n      var lengths = [];\n\n      var _iterator5 = _createForOfIteratorHelper(this.keys),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var k = _step5.value;\n          lengths.push(k.length);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      options = fillWeightedMultiSigOptionsForRoleBased(lengths, options);\n      var publicKeysByRole = this.getPublicKey();\n      return Account.createWithAccountKeyRoleBased(this.address, publicKeysByRole, options);\n    }\n    /**\r\n     * Encrypts a keyring and returns a keystore v4 standard.\r\n     * For more information, please refer to {@link https://kips.klaytn.com/KIPs/kip-3|KIP-3}.\r\n     *\r\n     * `options` can include below:\r\n     * {\r\n     *   salt: ...,\r\n     *   iv: ...,\r\n     *   kdf: ...,\r\n     *   dklen: ...,\r\n     *   c: ...,\r\n     *   n: ...,\r\n     *   r: ...,\r\n     *   p: ...,\r\n     *   cipher: ...,\r\n     *   uuid: ...,\r\n     *   cipher: ...,\r\n     * }\r\n     *\r\n     * @example\r\n     * const encrypted = keyring.encrypt('password')\r\n     *\r\n     * @param {string} password The password to be used for encryption. The encrypted key store can be decrypted with this password.\r\n     * @param {object} [options] The options parameter allows you to specify the values to use when using encrypt.\r\n     * @return {KeyringFactory.Keystore} The encrypted keystore v4.\r\n     */\n\n  }, {\n    key: \"encrypt\",\n    value: function encrypt(password) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var keyring = [];\n\n      for (var i = KEY_ROLE.roleTransactionKey; i < KEY_ROLE.roleLast; i++) {\n        var roledKey = this._keys[i];\n        keyring.push(encryptKey(roledKey, password, options));\n      }\n\n      return formatEncrypted(4, this._address, keyring, options);\n    }\n    /**\r\n     * Returns the {@link https://docs.klaytn.com/klaytn/design/accounts#klaytn-wallet-key-format|KlaytnWalletKey} string for the keyring.\r\n     * This function will throw error because `MultipleKeyring` uses more than one private key.\r\n     *\r\n     * @example\r\n     * const klaytnWalletKey = keyring.getKlaytnWalletKey()\r\n     *\r\n     * @ignore\r\n     * @return {string}\r\n     */\n\n  }, {\n    key: \"getKlaytnWalletKey\",\n    value: function getKlaytnWalletKey() {\n      throw new Error(\"Not supported for this class.\");\n    }\n    /**\r\n     * Encrypts a keyring and returns a keystore v3 object.\r\n     *\r\n     * Note that {@link MultipleKeyring} and {@link RoleBasedKeyring} cannot use encryptV3.\r\n     * In this case, please use {@link MultipleKeyring#encrypt|keyring.encrypt} with a keystore V4 standard.\r\n     *\r\n     * @example\r\n     * const encrypted = keyring.encryptV3('password')\r\n     *\r\n     * @ignore\r\n     * @param {string} password The password to be used for keyring encryption. The encrypted key store can be decrypted with this password.\r\n     * @param {object} [options] The options to use when encrypt a keyring. See `keyring.encrypt` for more detail about options.\r\n     * @return {object}\r\n     */\n\n  }, {\n    key: \"encryptV3\",\n    value: function encryptV3(password, options) {\n      throw new Error(\"Not supported for this class. Use 'keyring.encrypt(password)'.\");\n    }\n    /**\r\n     * Returns `true` if keyring has decoupled key.\r\n     *\r\n     * @example\r\n     * const isDecupled = keyring.isDecoupled()\r\n     *\r\n     * @return {boolean} `true` if keyring has decoupled key.\r\n     */\n\n  }, {\n    key: \"isDecoupled\",\n    value: function isDecoupled() {\n      return true;\n    }\n  }]);\n\n  return RoleBasedKeyring;\n}();\n\nmodule.exports = RoleBasedKeyring;\n/**\r\n * Format the key parameters passed by the user to create a keyring instance into a two-dimensional array containing PrivateKey instances.\r\n *\r\n * The cases of the parameter that the user passes to the function is as follows, and this function formats it as a two-dimensional array.\r\n * PrivateKey instance: PrivateKey{}\r\n * single private key string: `0x{private key}`\r\n * multiple private key strings: [`0x{private key}`, `0x{private key}`]\r\n * multiple PrivateKey instances: [PrivateKey{}, PrivateKey{}]\r\n * role-based private key strings: [[`0x{private key}`], [`0x{private key}`, `0x{private key}`], [`0x{private key}`]]\r\n * role-based PrivateKey instances: [[PrivateKey{}], [PrivateKey{}, PrivateKey{}], [PrivateKey{}]]\r\n *\r\n * @param {string|PrivateKey|Array.<string|PrivateKey>|Array.<Array.<string|PrivateKey>>} keyInput The input parameter for key variable in Keyring.\r\n * @return {Array.<Array.<PrivateKey>>}\r\n */\n\nfunction formattingForKeyInKeyring(keyInput) {\n  if (keyInput === null) {\n    return keyInput;\n  }\n\n  if (keyInput instanceof PrivateKey || _.isString(keyInput)) {\n    keyInput = [[keyInput], [], []];\n  } else if (isMultipleKeysFormat(keyInput)) {\n    // [`0x{private key}`, `0x{private key}`, `0x{private key}`]\n    keyInput = [keyInput, [], []];\n  } else if (!isRoleBasedKeysFormat(keyInput)) {\n    throw new Error(\"Invalid format for key variable in keyring\");\n  }\n\n  var keys = generateKeysFormat();\n\n  for (var i = 0; i < KEY_ROLE.roleLast; i++) {\n    fillRoleKey(keys, i, keyInput[i]);\n  }\n\n  return keys;\n}\n\nfunction generateKeysFormat() {\n  return Array(KEY_ROLE.roleLast).fill(null).map(function () {\n    return [];\n  });\n}\n\nfunction fillRoleKey(keys, role, keyToAdd) {\n  if (keyToAdd === undefined) return;\n  keyToAdd = Array.isArray(keyToAdd) ? keyToAdd : [keyToAdd];\n  if (keyToAdd.length > MAXIMUM_KEY_NUM) throw new Error(\"The maximum number of private keys that can be used in keyring is \".concat(MAXIMUM_KEY_NUM, \".\"));\n  if (role >= KEY_ROLE.roleLast) throw new Error(\"Unsupported role number. The role number should be less than \".concat(KEY_ROLE.roleLast, \". Please use 'caver.wallet.keyring.role'\"));\n\n  var _iterator6 = _createForOfIteratorHelper(keyToAdd),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var keyString = _step6.value;\n      var key = keyString instanceof PrivateKey ? keyString : new PrivateKey(keyString);\n      keys[role].push(key);\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n}","map":{"version":3,"names":["_","require","utils","PrivateKey","KEY_ROLE","MAXIMUM_KEY_NUM","isMultipleKeysFormat","isRoleBasedKeysFormat","Account","fillWeightedMultiSigOptionsForRoleBased","validateForSigning","validateIndexWithKeys","encryptKey","formatEncrypted","RoleBasedKeyring","address","keys","t","Error","_address","addressInput","isAddress","addHexPrefix","toLowerCase","_keys","keyInput","_key","formattingForKeyInKeyring","getKeyByRole","roleTransactionKey","roleAccountUpdateKey","roleFeePayerKey","compressed","publicKeys","generateKeysFormat","i","roleLast","k","push","getPublicKey","transactionHash","chainId","role","index","undefined","length","sign","signatures","hash","isValidHashStrict","ecsign","message","messageHash","hashMessage","signMessage","key","options","isArray","lengths","publicKeysByRole","createWithAccountKeyRoleBased","password","keyring","roledKey","module","exports","isString","fillRoleKey","Array","fill","map","keyToAdd","keyString"],"sources":["C:/Users/User/Documents/clone-starter-kit-08/node_modules/caver-js/packages/caver-wallet/src/keyring/roleBasedKeyring.js"],"sourcesContent":["/*\r\n    Copyright 2020 The caver-js Authors\r\n    This file is part of the caver-js library.\r\n\r\n    The caver-js library is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    The caver-js library is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n/* eslint-disable no-unused-vars */\r\n/* eslint-disable class-methods-use-this */\r\n\r\nconst _ = require('lodash')\r\n\r\nconst utils = require('../../../caver-utils')\r\nconst PrivateKey = require('./privateKey')\r\nconst { KEY_ROLE, MAXIMUM_KEY_NUM, isMultipleKeysFormat, isRoleBasedKeysFormat } = require('./keyringHelper')\r\nconst Account = require('../../../caver-account')\r\nconst { fillWeightedMultiSigOptionsForRoleBased } = require('../../../caver-account/src/accountKey/accountKeyHelper')\r\nconst { validateForSigning, validateIndexWithKeys, encryptKey, formatEncrypted } = require('./keyringHelper')\r\n\r\n/**\r\n * `RoleBasedKeyring` is a class that stores the address of the account and the private keys to be used for each role in the form of an array.\r\n *\r\n * `RoleBasedKeyring` defines keys which is implemented as a two-dimensional array (empty keys looks like `[ [], [], [] ]`) that can include multiple keys for each role.\r\n * The first array element defines the private key(s) for `roleTransactionKey`, the second defines private key(s) for `roleAccountUpdateKey`, and the third defines the private key(s) for `roleFeePayerKey`.\r\n *\r\n * @class\r\n * @hideconstructor\r\n */\r\nclass RoleBasedKeyring {\r\n    /**\r\n     * creates a RoleBasedKeyring.\r\n     * @param {string} address - The address of keyring.\r\n     * @param {Array.<Array<string>>|Array.<Array<PrivateKey>>} keys - The keys to use in RoleBasedKeyring.\r\n     */\r\n    constructor(address, keys) {\r\n        this.address = address\r\n        this.keys = keys\r\n    }\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    get type() {\r\n        return 'RoleBasedKeyring'\r\n    }\r\n\r\n    set type(t) {\r\n        throw new Error(`keyring type cannot be set.`)\r\n    }\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    get address() {\r\n        return this._address\r\n    }\r\n\r\n    set address(addressInput) {\r\n        if (!utils.isAddress(addressInput)) throw new Error(`Invalid address : ${addressInput}`)\r\n\r\n        this._address = utils.addHexPrefix(addressInput).toLowerCase()\r\n    }\r\n\r\n    /**\r\n     * @type {Array.<Array.<PrivateKey>>}\r\n     */\r\n    get keys() {\r\n        return this._keys\r\n    }\r\n\r\n    set keys(keyInput) {\r\n        if (keyInput === null) {\r\n            this._key = null\r\n            return\r\n        }\r\n\r\n        this._keys = formattingForKeyInKeyring(keyInput)\r\n    }\r\n\r\n    /**\r\n     * @type {Array.<PrivateKey>}\r\n     */\r\n    get roleTransactionKey() {\r\n        return this.getKeyByRole(KEY_ROLE.roleTransactionKey)\r\n    }\r\n\r\n    /**\r\n     * @type {Array.<PrivateKey>}\r\n     */\r\n    get roleAccountUpdateKey() {\r\n        return this.getKeyByRole(KEY_ROLE.roleAccountUpdateKey)\r\n    }\r\n\r\n    /**\r\n     * @type {Array.<PrivateKey>}\r\n     */\r\n    get roleFeePayerKey() {\r\n        return this.getKeyByRole(KEY_ROLE.roleFeePayerKey)\r\n    }\r\n\r\n    /**\r\n     * Returns public key strings for each roles.\r\n     *\r\n     * @example\r\n     * const publicKeys = keyring.getPublicKey()\r\n     *\r\n     * @param {boolean} [compressed] Whether in compressed format or not.\r\n     * @return {Array.<Array<string>>} The public keys of the keyring.\r\n     */\r\n    getPublicKey(compressed = false) {\r\n        const publicKeys = generateKeysFormat()\r\n        for (let i = 0; i < KEY_ROLE.roleLast; i++) {\r\n            for (const k of this._keys[i]) {\r\n                publicKeys[i].push(k.getPublicKey(compressed))\r\n            }\r\n        }\r\n        return publicKeys\r\n    }\r\n\r\n    /**\r\n     * Returns a copied RoleBasedKeyring instance.\r\n     *\r\n     * @example\r\n     * const copied = keyring.copy()\r\n     *\r\n     * @return {RoleBasedKeyring} A copied RoleBasedKeyring instance.\r\n     */\r\n    copy() {\r\n        return new RoleBasedKeyring(this.address, this.keys)\r\n    }\r\n\r\n    /**\r\n     * Signs with transactionHash with the private keys and returns signatures.\r\n     *\r\n     * If you want to define an `index` when using RoleBasedKeyring, the `index` must be less than the length of the specific role key.\r\n     * And `RoleBasedKeyring` has the private key(s) defined by {@link KeyringFactory.role|caver.wallet.keyring.role}, so signs using the key(s) defined in the role.\r\n     *\r\n     * If the user has not defined an `index` parameter, `keyring.sign` signs transaction using all the private keys used by the role.\r\n     * If `index` is defined, the `keyring.sign` signs transaction using only one private key at the index.\r\n     * The role used in caver-js can be checked through {@link KeyringFactory.role|caver.wallet.keyring.role}.\r\n     *\r\n     * @param {string} transactionHash The hash of transaction.\r\n     * @param {string|number} chainId The chainId specific to the network.\r\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\r\n     * @param {number} [index] The index of the key to be used. If index is undefined, all private keys in keyring will be used.\r\n     * @return {SignatureData|Array.<SignatureData>} A {@link SignatureData} when `index` is deinfed, otherwise an array of {@link SignatureData}.\r\n     */\r\n    sign(transactionHash, chainId, role, index) {\r\n        validateForSigning(transactionHash, chainId)\r\n\r\n        const keys = this.getKeyByRole(role)\r\n\r\n        if (index !== undefined) {\r\n            validateIndexWithKeys(index, keys.length)\r\n            return keys[index].sign(transactionHash, chainId)\r\n        }\r\n\r\n        const signatures = []\r\n        for (const k of keys) {\r\n            signatures.push(k.sign(transactionHash, chainId))\r\n        }\r\n        return signatures\r\n    }\r\n\r\n    /**\r\n     * Signs with transactionHash with the private keys and returns signatures which V is 0 or 1 (parity of the y-value of a secp256k1 signature).\r\n     *\r\n     * If you want to define an `index` when using RoleBasedKeyring, the `index` must be less than the length of the specific role key.\r\n     * And `RoleBasedKeyring` has the private key(s) defined by {@link KeyringFactory.role|caver.wallet.keyring.role}, so signs using the key(s) defined in the role.\r\n     *\r\n     * If the user has not defined an `index` parameter, `keyring.sign` signs transaction using all the private keys used by the role.\r\n     * If `index` is defined, the `keyring.sign` signs transaction using only one private key at the index.\r\n     * The role used in caver-js can be checked through {@link KeyringFactory.role|caver.wallet.keyring.role}.\r\n     *\r\n     * @example\r\n     * const signed = keyring.ecsign('0xe9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550', caver.wallet.keyring.role.roleTransactionKey)\r\n     * const signed = keyring.ecsign('0xe9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550', caver.wallet.keyring.role.roleAccountUpdateKey, 1)\r\n     *\r\n     * @param {string} hash The hashed data to sign.\r\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\r\n     * @param {number} [index] The index of the key to be used. If index is undefined, all private keys in keyring will be used.\r\n     * @return {SignatureData|Array.<SignatureData>} A {@link SignatureData} when `index` is deinfed, otherwise an array of {@link SignatureData}.\r\n     */\r\n    ecsign(hash, role, index) {\r\n        if (!utils.isValidHashStrict(hash)) throw new Error(`Invalid hash: ${hash}`)\r\n\r\n        const keys = this.getKeyByRole(role)\r\n\r\n        if (index !== undefined) {\r\n            validateIndexWithKeys(index, keys.length)\r\n            return keys[index].ecsign(hash)\r\n        }\r\n\r\n        const signatures = []\r\n        for (const k of keys) {\r\n            signatures.push(k.ecsign(hash))\r\n        }\r\n        return signatures\r\n    }\r\n\r\n    /**\r\n     * Signs message with Klaytn-specific prefix.\r\n     *\r\n     * This calculates a Klaytn-specific signature with:\r\n     * `sign(keccak256(\"\\x19Klaytn Signed Message:\\n\" + len(message) + message)))`.\r\n     *\r\n     * If you want to define an `index` when using RoleBasedKeyring, the `index` must be less than the length of the specific role key.\r\n     * And `RoleBasedKeyring` has the private key(s) defined by {@link KeyringFactory.role|caver.wallet.keyring.role}, so signs using the key(s) defined in the role.\r\n     *\r\n     * If the user has not provided the `index` parameter, `caver.wallet.signMessage` signs message using all the private keys used by the role.\r\n     * If the `index` parameter is given, `caver.wallet.signMessage` signs message using only one private key at the given index.\r\n     * The role used in caver-js can be found from {@link KeyringFactory.role|caver.wallet.keyring.role}.\r\n     *\r\n     * @example\r\n     * const signed = keyring.signMessage('message to sign', caver.wallet.keyring.role.roleTransactionKey)\r\n     *\r\n     * @param {string} message The message string to sign.\r\n     * @param {number} role A number indicating the role of the key. You can use {@link KeyringFactory.role|caver.wallet.keyring.role}.\r\n     * @param {number} [index] The index of the key to be used.\r\n     * @return {KeyringContainer.SignedMessage} An object that includes the result of signing.\r\n     */\r\n    signMessage(message, role, index) {\r\n        if (role === undefined) throw new Error(`role should be defined for signMessage. Please use 'caver.wallet.keyring.role'.`)\r\n        const messageHash = utils.hashMessage(message)\r\n\r\n        const keys = this.getKeyByRole(role)\r\n\r\n        const signatures = []\r\n        if (index !== undefined) {\r\n            validateIndexWithKeys(index, keys.length)\r\n            signatures.push(keys[index].signMessage(messageHash))\r\n        } else {\r\n            for (const k of keys) {\r\n                signatures.push(k.signMessage(messageHash))\r\n            }\r\n        }\r\n        return {\r\n            messageHash,\r\n            signatures,\r\n            message,\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the private key(s) used by the role entered as a parameter.\r\n     *\r\n     * @example\r\n     * const key = keyring.getKeyByRole(caver.wallet.keyring.role.roleTransactionKey)\r\n     *\r\n     * @param {number} role A number indicating the role of the key. You can use {@link KeyringFactory.role|caver.wallet.keyring.role}.\r\n     * @return {Array.<PrivateKey>} An instance of PrivateKey.\r\n     */\r\n    getKeyByRole(role) {\r\n        if (role === undefined) throw new Error(`role should be defined.`)\r\n        if (role >= KEY_ROLE.roleLast || role < 0) throw new Error(`Invalid role number: ${role}`)\r\n        let key = this._keys[role]\r\n        if (key.length === 0 && role > KEY_ROLE.roleTransactionKey) {\r\n            if (this._keys[KEY_ROLE.roleTransactionKey].length === 0) {\r\n                throw new Error(\r\n                    `The key with ${KEY_ROLE[role]} role does not exist. The ${KEY_ROLE[0]} for the default role is also empty.`\r\n                )\r\n            }\r\n\r\n            key = this._keys[KEY_ROLE.roleTransactionKey]\r\n        }\r\n        return key\r\n    }\r\n\r\n    /**\r\n     * Returns the {@link Account} instance for updating the {@link Account.AccountKey|AccountKey} of the Klaytn accounts.\r\n     * The {@link Account} instance has an {@link Account.AccountKey|AccountKey} instance that can contain public key(s) inside, which will be sent to Klaytn Network and used for validating transactions.\r\n     * Please note that if you update the AccountKey of the Account stored in the Klaytn, the old private key(s) cannot be used anymore.\r\n     *\r\n     * `RoleBasedKeyring` returns an {@link Account} instance that includes the address in the keyring and an instance of {@link AccountKeyRoleBased}.\r\n     *\r\n     * @example\r\n     * const account = keyring.toAccount()\r\n     *\r\n     * @param {Array.<WeightedMultiSigOptions>} [options] An array of the `WeightedMultiSigOptions` instances containing information that should be defined when updating your existing account to the one with a number of private keys. The `RoleBasedKeyring` uses different private keys for each role, a `WeightedMultiSigOptions` instance must be defined for each role in an array. If multiple keys are used and `options` are not defined for specific role, defualt WeightedMultiSigOptions (`{ threshold: 1, weights: [1, 1...}}`) is used.\r\n     * @return {Account} An Account instance to be used when a user updates AccountKey for their account in the Klaytn. Note that if you want to replace the existing keyring (or the existing private key) with a new keyring (or a new private key) for your account, you must update your AccountKey by sending an Account Update transaction to Klaytn beforehand.\r\n     */\r\n    toAccount(options) {\r\n        if (options !== undefined && !_.isArray(options))\r\n            throw new Error(`options for an account should define threshold and weight for each roles in an array format`)\r\n\r\n        const lengths = []\r\n        for (const k of this.keys) lengths.push(k.length)\r\n        options = fillWeightedMultiSigOptionsForRoleBased(lengths, options)\r\n\r\n        const publicKeysByRole = this.getPublicKey()\r\n        return Account.createWithAccountKeyRoleBased(this.address, publicKeysByRole, options)\r\n    }\r\n\r\n    /**\r\n     * Encrypts a keyring and returns a keystore v4 standard.\r\n     * For more information, please refer to {@link https://kips.klaytn.com/KIPs/kip-3|KIP-3}.\r\n     *\r\n     * `options` can include below:\r\n     * {\r\n     *   salt: ...,\r\n     *   iv: ...,\r\n     *   kdf: ...,\r\n     *   dklen: ...,\r\n     *   c: ...,\r\n     *   n: ...,\r\n     *   r: ...,\r\n     *   p: ...,\r\n     *   cipher: ...,\r\n     *   uuid: ...,\r\n     *   cipher: ...,\r\n     * }\r\n     *\r\n     * @example\r\n     * const encrypted = keyring.encrypt('password')\r\n     *\r\n     * @param {string} password The password to be used for encryption. The encrypted key store can be decrypted with this password.\r\n     * @param {object} [options] The options parameter allows you to specify the values to use when using encrypt.\r\n     * @return {KeyringFactory.Keystore} The encrypted keystore v4.\r\n     */\r\n    encrypt(password, options = {}) {\r\n        const keyring = []\r\n\r\n        for (let i = KEY_ROLE.roleTransactionKey; i < KEY_ROLE.roleLast; i++) {\r\n            const roledKey = this._keys[i]\r\n            keyring.push(encryptKey(roledKey, password, options))\r\n        }\r\n\r\n        return formatEncrypted(4, this._address, keyring, options)\r\n    }\r\n\r\n    /**\r\n     * Returns the {@link https://docs.klaytn.com/klaytn/design/accounts#klaytn-wallet-key-format|KlaytnWalletKey} string for the keyring.\r\n     * This function will throw error because `MultipleKeyring` uses more than one private key.\r\n     *\r\n     * @example\r\n     * const klaytnWalletKey = keyring.getKlaytnWalletKey()\r\n     *\r\n     * @ignore\r\n     * @return {string}\r\n     */\r\n    getKlaytnWalletKey() {\r\n        throw new Error(`Not supported for this class.`)\r\n    }\r\n\r\n    /**\r\n     * Encrypts a keyring and returns a keystore v3 object.\r\n     *\r\n     * Note that {@link MultipleKeyring} and {@link RoleBasedKeyring} cannot use encryptV3.\r\n     * In this case, please use {@link MultipleKeyring#encrypt|keyring.encrypt} with a keystore V4 standard.\r\n     *\r\n     * @example\r\n     * const encrypted = keyring.encryptV3('password')\r\n     *\r\n     * @ignore\r\n     * @param {string} password The password to be used for keyring encryption. The encrypted key store can be decrypted with this password.\r\n     * @param {object} [options] The options to use when encrypt a keyring. See `keyring.encrypt` for more detail about options.\r\n     * @return {object}\r\n     */\r\n    encryptV3(password, options) {\r\n        throw new Error(`Not supported for this class. Use 'keyring.encrypt(password)'.`)\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if keyring has decoupled key.\r\n     *\r\n     * @example\r\n     * const isDecupled = keyring.isDecoupled()\r\n     *\r\n     * @return {boolean} `true` if keyring has decoupled key.\r\n     */\r\n    isDecoupled() {\r\n        return true\r\n    }\r\n}\r\n\r\nmodule.exports = RoleBasedKeyring\r\n\r\n/**\r\n * Format the key parameters passed by the user to create a keyring instance into a two-dimensional array containing PrivateKey instances.\r\n *\r\n * The cases of the parameter that the user passes to the function is as follows, and this function formats it as a two-dimensional array.\r\n * PrivateKey instance: PrivateKey{}\r\n * single private key string: `0x{private key}`\r\n * multiple private key strings: [`0x{private key}`, `0x{private key}`]\r\n * multiple PrivateKey instances: [PrivateKey{}, PrivateKey{}]\r\n * role-based private key strings: [[`0x{private key}`], [`0x{private key}`, `0x{private key}`], [`0x{private key}`]]\r\n * role-based PrivateKey instances: [[PrivateKey{}], [PrivateKey{}, PrivateKey{}], [PrivateKey{}]]\r\n *\r\n * @param {string|PrivateKey|Array.<string|PrivateKey>|Array.<Array.<string|PrivateKey>>} keyInput The input parameter for key variable in Keyring.\r\n * @return {Array.<Array.<PrivateKey>>}\r\n */\r\nfunction formattingForKeyInKeyring(keyInput) {\r\n    if (keyInput === null) {\r\n        return keyInput\r\n    }\r\n\r\n    if (keyInput instanceof PrivateKey || _.isString(keyInput)) {\r\n        keyInput = [[keyInput], [], []]\r\n    } else if (isMultipleKeysFormat(keyInput)) {\r\n        // [`0x{private key}`, `0x{private key}`, `0x{private key}`]\r\n        keyInput = [keyInput, [], []]\r\n    } else if (!isRoleBasedKeysFormat(keyInput)) {\r\n        throw new Error(`Invalid format for key variable in keyring`)\r\n    }\r\n\r\n    const keys = generateKeysFormat()\r\n    for (let i = 0; i < KEY_ROLE.roleLast; i++) {\r\n        fillRoleKey(keys, i, keyInput[i])\r\n    }\r\n\r\n    return keys\r\n}\r\n\r\nfunction generateKeysFormat() {\r\n    return Array(KEY_ROLE.roleLast)\r\n        .fill(null)\r\n        .map(() => [])\r\n}\r\n\r\nfunction fillRoleKey(keys, role, keyToAdd) {\r\n    if (keyToAdd === undefined) return\r\n    keyToAdd = Array.isArray(keyToAdd) ? keyToAdd : [keyToAdd]\r\n\r\n    if (keyToAdd.length > MAXIMUM_KEY_NUM)\r\n        throw new Error(`The maximum number of private keys that can be used in keyring is ${MAXIMUM_KEY_NUM}.`)\r\n    if (role >= KEY_ROLE.roleLast)\r\n        throw new Error(\r\n            `Unsupported role number. The role number should be less than ${KEY_ROLE.roleLast}. Please use 'caver.wallet.keyring.role'`\r\n        )\r\n\r\n    for (const keyString of keyToAdd) {\r\n        const key = keyString instanceof PrivateKey ? keyString : new PrivateKey(keyString)\r\n        keys[role].push(key)\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}