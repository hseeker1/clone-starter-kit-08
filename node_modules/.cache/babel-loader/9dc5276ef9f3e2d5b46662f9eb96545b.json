{"ast":null,"code":"'use strict';\n/**\r\n * A CBOR tagged item, where the tag does not have semantics specified at the\r\n * moment, or those semantics threw an error during parsing. Typically this will\r\n * be an extension point you're not yet expecting.\r\n */\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar Tagged = /*#__PURE__*/function () {\n  /**\r\n   * Creates an instance of Tagged.\r\n   *\r\n   * @param {Number} tag - the number of the tag\r\n   * @param {any} value - the value inside the tag\r\n   * @param {Error} err - the error that was thrown parsing the tag, or null\r\n   */\n  function Tagged(tag, value, err) {\n    _classCallCheck(this, Tagged);\n\n    this.tag = tag;\n    this.value = value;\n    this.err = err;\n\n    if (typeof this.tag !== 'number') {\n      throw new Error('Invalid tag type (' + typeof this.tag + ')');\n    }\n\n    if (this.tag < 0 || (this.tag | 0) !== this.tag) {\n      throw new Error('Tag must be a positive integer: ' + this.tag);\n    }\n  }\n  /**\r\n   * Convert to a String\r\n   *\r\n   * @returns {String} string of the form '1(2)'\r\n   */\n\n\n  _createClass(Tagged, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.tag, \"(\").concat(JSON.stringify(this.value), \")\");\n    }\n    /**\r\n     * Push the simple value onto the CBOR stream\r\n     *\r\n     * @param {cbor.Encoder} gen The generator to push onto\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"encodeCBOR\",\n    value: function encodeCBOR(gen) {\n      gen._pushTag(this.tag);\n\n      return gen.pushAny(this.value);\n    }\n    /**\r\n     * If we have a converter for this type, do the conversion.  Some converters\r\n     * are built-in.  Additional ones can be passed in.  If you want to remove\r\n     * a built-in converter, pass a converter in whose value is 'null' instead\r\n     * of a function.\r\n     *\r\n     * @param {Object} converters - keys in the object are a tag number, the value\r\n     *   is a function that takes the decoded CBOR and returns a JavaScript value\r\n     *   of the appropriate type.  Throw an exception in the function on errors.\r\n     * @returns {any} - the converted item\r\n     */\n\n  }, {\n    key: \"convert\",\n    value: function convert(converters) {\n      var er, f;\n      f = converters != null ? converters[this.tag] : undefined;\n\n      if (typeof f !== 'function') {\n        f = Tagged['_tag' + this.tag];\n\n        if (typeof f !== 'function') {\n          return this;\n        }\n      }\n\n      try {\n        return f.call(Tagged, this.value);\n      } catch (error) {\n        er = error;\n        this.err = er;\n        return this;\n      }\n    }\n  }]);\n\n  return Tagged;\n}();\n\nmodule.exports = Tagged;","map":{"version":3,"names":["Tagged","tag","value","err","Error","JSON","stringify","gen","_pushTag","pushAny","converters","er","f","undefined","call","error","module","exports"],"sources":["C:/Users/User/Documents/clone-starter-kit-08/node_modules/borc/src/tagged.js"],"sourcesContent":["'use strict'\r\n\r\n/**\r\n * A CBOR tagged item, where the tag does not have semantics specified at the\r\n * moment, or those semantics threw an error during parsing. Typically this will\r\n * be an extension point you're not yet expecting.\r\n */\r\nclass Tagged {\r\n  /**\r\n   * Creates an instance of Tagged.\r\n   *\r\n   * @param {Number} tag - the number of the tag\r\n   * @param {any} value - the value inside the tag\r\n   * @param {Error} err - the error that was thrown parsing the tag, or null\r\n   */\r\n  constructor (tag, value, err) {\r\n    this.tag = tag\r\n    this.value = value\r\n    this.err = err\r\n    if (typeof this.tag !== 'number') {\r\n      throw new Error('Invalid tag type (' + (typeof this.tag) + ')')\r\n    }\r\n    if ((this.tag < 0) || ((this.tag | 0) !== this.tag)) {\r\n      throw new Error('Tag must be a positive integer: ' + this.tag)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert to a String\r\n   *\r\n   * @returns {String} string of the form '1(2)'\r\n   */\r\n  toString () {\r\n    return `${this.tag}(${JSON.stringify(this.value)})`\r\n  }\r\n\r\n  /**\r\n   * Push the simple value onto the CBOR stream\r\n   *\r\n   * @param {cbor.Encoder} gen The generator to push onto\r\n   * @returns {number}\r\n   */\r\n  encodeCBOR (gen) {\r\n    gen._pushTag(this.tag)\r\n    return gen.pushAny(this.value)\r\n  }\r\n\r\n  /**\r\n   * If we have a converter for this type, do the conversion.  Some converters\r\n   * are built-in.  Additional ones can be passed in.  If you want to remove\r\n   * a built-in converter, pass a converter in whose value is 'null' instead\r\n   * of a function.\r\n   *\r\n   * @param {Object} converters - keys in the object are a tag number, the value\r\n   *   is a function that takes the decoded CBOR and returns a JavaScript value\r\n   *   of the appropriate type.  Throw an exception in the function on errors.\r\n   * @returns {any} - the converted item\r\n   */\r\n  convert (converters) {\r\n    var er, f\r\n    f = converters != null ? converters[this.tag] : undefined\r\n    if (typeof f !== 'function') {\r\n      f = Tagged['_tag' + this.tag]\r\n      if (typeof f !== 'function') {\r\n        return this\r\n      }\r\n    }\r\n    try {\r\n      return f.call(Tagged, this.value)\r\n    } catch (error) {\r\n      er = error\r\n      this.err = er\r\n      return this\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Tagged\r\n"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AACA;;;;;;IACMA,M;EACJ;AACF;AACA;AACA;AACA;AACA;AACA;EACE,gBAAaC,GAAb,EAAkBC,KAAlB,EAAyBC,GAAzB,EAA8B;IAAA;;IAC5B,KAAKF,GAAL,GAAWA,GAAX;IACA,KAAKC,KAAL,GAAaA,KAAb;IACA,KAAKC,GAAL,GAAWA,GAAX;;IACA,IAAI,OAAO,KAAKF,GAAZ,KAAoB,QAAxB,EAAkC;MAChC,MAAM,IAAIG,KAAJ,CAAU,uBAAwB,OAAO,KAAKH,GAApC,GAA2C,GAArD,CAAN;IACD;;IACD,IAAK,KAAKA,GAAL,GAAW,CAAZ,IAAmB,CAAC,KAAKA,GAAL,GAAW,CAAZ,MAAmB,KAAKA,GAA/C,EAAqD;MACnD,MAAM,IAAIG,KAAJ,CAAU,qCAAqC,KAAKH,GAApD,CAAN;IACD;EACF;EAED;AACF;AACA;AACA;AACA;;;;;WACE,oBAAY;MACV,iBAAU,KAAKA,GAAf,cAAsBI,IAAI,CAACC,SAAL,CAAe,KAAKJ,KAApB,CAAtB;IACD;IAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,oBAAYK,GAAZ,EAAiB;MACfA,GAAG,CAACC,QAAJ,CAAa,KAAKP,GAAlB;;MACA,OAAOM,GAAG,CAACE,OAAJ,CAAY,KAAKP,KAAjB,CAAP;IACD;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,iBAASQ,UAAT,EAAqB;MACnB,IAAIC,EAAJ,EAAQC,CAAR;MACAA,CAAC,GAAGF,UAAU,IAAI,IAAd,GAAqBA,UAAU,CAAC,KAAKT,GAAN,CAA/B,GAA4CY,SAAhD;;MACA,IAAI,OAAOD,CAAP,KAAa,UAAjB,EAA6B;QAC3BA,CAAC,GAAGZ,MAAM,CAAC,SAAS,KAAKC,GAAf,CAAV;;QACA,IAAI,OAAOW,CAAP,KAAa,UAAjB,EAA6B;UAC3B,OAAO,IAAP;QACD;MACF;;MACD,IAAI;QACF,OAAOA,CAAC,CAACE,IAAF,CAAOd,MAAP,EAAe,KAAKE,KAApB,CAAP;MACD,CAFD,CAEE,OAAOa,KAAP,EAAc;QACdJ,EAAE,GAAGI,KAAL;QACA,KAAKZ,GAAL,GAAWQ,EAAX;QACA,OAAO,IAAP;MACD;IACF;;;;;;AAGHK,MAAM,CAACC,OAAP,GAAiBjB,MAAjB"},"metadata":{},"sourceType":"script"}