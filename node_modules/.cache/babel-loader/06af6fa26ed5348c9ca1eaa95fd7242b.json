{"ast":null,"code":"/* eslint-disable no-undef */\n'use strict';\n\nvar _defineProperty = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\nvar _objectSpread = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread2\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _awaitAsyncGenerator = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/wrapAsyncGenerator\");\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nfunction _asyncIterator(iterable) { var method, async, sync, retry = 2; for (\"undefined\" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = \"@@asyncIterator\", sync = \"@@iterator\"; } throw new TypeError(\"Object is not async iterable\"); }\n\nfunction AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function AsyncFromSyncIterator(s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function _return(value) { var ret = this.s.return; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, throw: function _throw(value) { var thr = this.s.return; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); }\n\nvar _require = require('./http/fetch'),\n    _fetch = _require.fetch,\n    Request = _require.Request,\n    Headers = _require.Headers;\n\nvar _require2 = require('./http/error'),\n    TimeoutError = _require2.TimeoutError,\n    HTTPError = _require2.HTTPError;\n\nvar merge = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nvar _require3 = require('iso-url'),\n    URL = _require3.URL,\n    URLSearchParams = _require3.URLSearchParams;\n\nvar _require4 = require('native-abort-controller'),\n    AbortController = _require4.AbortController;\n\nvar anySignal = require('any-signal');\n/**\r\n * @typedef {import('native-fetch').Response} Response\r\n * @typedef {import('stream').Readable} NodeReadableStream\r\n * @typedef {import('stream').Duplex} NodeDuplexStream\r\n * @typedef {import('./types').HTTPOptions} HTTPOptions\r\n */\n\n/**\r\n * @template TResponse\r\n * @param {Promise<TResponse>} promise\r\n * @param {number | undefined} ms\r\n * @param {AbortController} abortController\r\n * @returns {Promise<TResponse>}\r\n */\n\n\nvar timeout = function timeout(promise, ms, abortController) {\n  if (ms === undefined) {\n    return promise;\n  }\n\n  var start = Date.now();\n\n  var timedOut = function timedOut() {\n    var time = Date.now() - start;\n    return time >= ms;\n  };\n\n  return new Promise(function (resolve, reject) {\n    var timeoutID = setTimeout(function () {\n      if (timedOut()) {\n        reject(new TimeoutError());\n        abortController.abort();\n      }\n    }, ms);\n    /**\r\n     * @param {(value: any) => void } next\r\n     */\n\n    var after = function after(next) {\n      /**\r\n       * @param {any} res\r\n       */\n      var fn = function fn(res) {\n        clearTimeout(timeoutID);\n\n        if (timedOut()) {\n          reject(new TimeoutError());\n          return;\n        }\n\n        next(res);\n      };\n\n      return fn;\n    };\n\n    promise.then(after(resolve), after(reject));\n  });\n};\n\nvar defaults = {\n  throwHttpErrors: true,\n  credentials: 'same-origin'\n};\n\nvar HTTP = /*#__PURE__*/function () {\n  /**\r\n   *\r\n   * @param {HTTPOptions} options\r\n   */\n  function HTTP() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, HTTP);\n\n    /** @type {HTTPOptions} */\n    this.opts = merge(defaults, options);\n  }\n  /**\r\n   * Fetch\r\n   *\r\n   * @param {string | Request} resource\r\n   * @param {HTTPOptions} options\r\n   * @returns {Promise<Response>}\r\n   */\n\n\n  _createClass(HTTP, [{\n    key: \"fetch\",\n    value: function () {\n      var _fetch2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(resource) {\n        var options,\n            opts,\n            headers,\n            url,\n            searchParams,\n            transformSearchParams,\n            json,\n            abortController,\n            signal,\n            response,\n            _args2 = arguments;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n\n                /** @type {HTTPOptions} */\n                opts = merge(this.opts, options);\n                headers = new Headers(opts.headers); // validate resource type\n\n                if (!(typeof resource !== 'string' && !(resource instanceof URL || resource instanceof Request))) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                throw new TypeError('`resource` must be a string, URL, or Request');\n\n              case 5:\n                url = new URL(resource.toString(), opts.base);\n                searchParams = opts.searchParams, transformSearchParams = opts.transformSearchParams, json = opts.json;\n\n                if (searchParams) {\n                  if (typeof transformSearchParams === 'function') {\n                    // @ts-ignore\n                    url.search = transformSearchParams(new URLSearchParams(opts.searchParams));\n                  } else {\n                    // @ts-ignore\n                    url.search = new URLSearchParams(opts.searchParams);\n                  }\n                }\n\n                if (json) {\n                  opts.body = JSON.stringify(opts.json);\n                  headers.set('content-type', 'application/json');\n                }\n\n                abortController = new AbortController(); // @ts-ignore\n\n                signal = anySignal([abortController.signal, opts.signal]);\n                _context2.next = 13;\n                return timeout(_fetch(url.toString(), _objectSpread(_objectSpread({}, opts), {}, {\n                  signal: signal,\n                  timeout: undefined,\n                  headers: headers\n                })), opts.timeout, abortController);\n\n              case 13:\n                response = _context2.sent;\n\n                if (!(!response.ok && opts.throwHttpErrors)) {\n                  _context2.next = 19;\n                  break;\n                }\n\n                if (!opts.handleError) {\n                  _context2.next = 18;\n                  break;\n                }\n\n                _context2.next = 18;\n                return opts.handleError(response);\n\n              case 18:\n                throw new HTTPError(response);\n\n              case 19:\n                response.iterator = function () {\n                  return fromStream(response.body);\n                };\n\n                response.ndjson = /*#__PURE__*/_wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                  var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk;\n\n                  return _regeneratorRuntime().wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          _iteratorAbruptCompletion = false;\n                          _didIteratorError = false;\n                          _context.prev = 2;\n                          _iterator = _asyncIterator(ndjson(response.iterator()));\n\n                        case 4:\n                          _context.next = 6;\n                          return _awaitAsyncGenerator(_iterator.next());\n\n                        case 6:\n                          if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n                            _context.next = 18;\n                            break;\n                          }\n\n                          chunk = _step.value;\n\n                          if (!options.transform) {\n                            _context.next = 13;\n                            break;\n                          }\n\n                          _context.next = 11;\n                          return options.transform(chunk);\n\n                        case 11:\n                          _context.next = 15;\n                          break;\n\n                        case 13:\n                          _context.next = 15;\n                          return chunk;\n\n                        case 15:\n                          _iteratorAbruptCompletion = false;\n                          _context.next = 4;\n                          break;\n\n                        case 18:\n                          _context.next = 24;\n                          break;\n\n                        case 20:\n                          _context.prev = 20;\n                          _context.t0 = _context[\"catch\"](2);\n                          _didIteratorError = true;\n                          _iteratorError = _context.t0;\n\n                        case 24:\n                          _context.prev = 24;\n                          _context.prev = 25;\n\n                          if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                            _context.next = 29;\n                            break;\n                          }\n\n                          _context.next = 29;\n                          return _awaitAsyncGenerator(_iterator.return());\n\n                        case 29:\n                          _context.prev = 29;\n\n                          if (!_didIteratorError) {\n                            _context.next = 32;\n                            break;\n                          }\n\n                          throw _iteratorError;\n\n                        case 32:\n                          return _context.finish(29);\n\n                        case 33:\n                          return _context.finish(24);\n\n                        case 34:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee, null, [[2, 20, 24, 34], [25,, 29, 33]]);\n                }));\n                return _context2.abrupt(\"return\", response);\n\n              case 22:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function fetch(_x2) {\n        return _fetch2.apply(this, arguments);\n      }\n\n      return fetch;\n    }()\n    /**\r\n     * @param {string | Request} resource\r\n     * @param {HTTPOptions} options\r\n     * @returns {Promise<Response>}\r\n     */\n\n  }, {\n    key: \"post\",\n    value: function post(resource) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.fetch(resource, _objectSpread(_objectSpread({}, options), {}, {\n        method: 'POST'\n      }));\n    }\n    /**\r\n     * @param {string | Request} resource\r\n     * @param {HTTPOptions} options\r\n     * @returns {Promise<Response>}\r\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(resource) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.fetch(resource, _objectSpread(_objectSpread({}, options), {}, {\n        method: 'GET'\n      }));\n    }\n    /**\r\n     * @param {string | Request} resource\r\n     * @param {HTTPOptions} options\r\n     * @returns {Promise<Response>}\r\n     */\n\n  }, {\n    key: \"put\",\n    value: function put(resource) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.fetch(resource, _objectSpread(_objectSpread({}, options), {}, {\n        method: 'PUT'\n      }));\n    }\n    /**\r\n     * @param {string | Request} resource\r\n     * @param {HTTPOptions} options\r\n     * @returns {Promise<Response>}\r\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(resource) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.fetch(resource, _objectSpread(_objectSpread({}, options), {}, {\n        method: 'DELETE'\n      }));\n    }\n    /**\r\n     * @param {string | Request} resource\r\n     * @param {HTTPOptions} options\r\n     * @returns {Promise<Response>}\r\n     */\n\n  }, {\n    key: \"options\",\n    value: function options(resource) {\n      var _options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      return this.fetch(resource, _objectSpread(_objectSpread({}, _options), {}, {\n        method: 'OPTIONS'\n      }));\n    }\n  }]);\n\n  return HTTP;\n}();\n/**\r\n * Parses NDJSON chunks from an iterator\r\n *\r\n * @param {AsyncIterable<Uint8Array>} source\r\n * @returns {AsyncIterable<any>}\r\n */\n\n\nvar ndjson = /*#__PURE__*/function () {\n  var _ref2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(source) {\n    var decoder, buf, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, chunk, lines, i, l;\n\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            decoder = new TextDecoder();\n            buf = '';\n            _iteratorAbruptCompletion2 = false;\n            _didIteratorError2 = false;\n            _context3.prev = 4;\n            _iterator2 = _asyncIterator(source);\n\n          case 6:\n            _context3.next = 8;\n            return _awaitAsyncGenerator(_iterator2.next());\n\n          case 8:\n            if (!(_iteratorAbruptCompletion2 = !(_step2 = _context3.sent).done)) {\n              _context3.next = 25;\n              break;\n            }\n\n            chunk = _step2.value;\n            buf += decoder.decode(chunk, {\n              stream: true\n            });\n            lines = buf.split(/\\r?\\n/);\n            i = 0;\n\n          case 13:\n            if (!(i < lines.length - 1)) {\n              _context3.next = 21;\n              break;\n            }\n\n            l = lines[i].trim();\n\n            if (!(l.length > 0)) {\n              _context3.next = 18;\n              break;\n            }\n\n            _context3.next = 18;\n            return JSON.parse(l);\n\n          case 18:\n            i++;\n            _context3.next = 13;\n            break;\n\n          case 21:\n            buf = lines[lines.length - 1];\n\n          case 22:\n            _iteratorAbruptCompletion2 = false;\n            _context3.next = 6;\n            break;\n\n          case 25:\n            _context3.next = 31;\n            break;\n\n          case 27:\n            _context3.prev = 27;\n            _context3.t0 = _context3[\"catch\"](4);\n            _didIteratorError2 = true;\n            _iteratorError2 = _context3.t0;\n\n          case 31:\n            _context3.prev = 31;\n            _context3.prev = 32;\n\n            if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n              _context3.next = 36;\n              break;\n            }\n\n            _context3.next = 36;\n            return _awaitAsyncGenerator(_iterator2.return());\n\n          case 36:\n            _context3.prev = 36;\n\n            if (!_didIteratorError2) {\n              _context3.next = 39;\n              break;\n            }\n\n            throw _iteratorError2;\n\n          case 39:\n            return _context3.finish(36);\n\n          case 40:\n            return _context3.finish(31);\n\n          case 41:\n            buf += decoder.decode();\n            buf = buf.trim();\n\n            if (!(buf.length !== 0)) {\n              _context3.next = 46;\n              break;\n            }\n\n            _context3.next = 46;\n            return JSON.parse(buf);\n\n          case 46:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[4, 27, 31, 41], [32,, 36, 40]]);\n  }));\n\n  return function ndjson(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\r\n * Stream to AsyncIterable\r\n *\r\n * @template TChunk\r\n * @param {ReadableStream<TChunk> | NodeReadableStream | null} source\r\n * @returns {AsyncIterable<TChunk>}\r\n */\n\n\nvar fromStream = function fromStream(source) {\n  // Workaround for https://github.com/node-fetch/node-fetch/issues/766\n  if (isNodeReadableStream(source)) {\n    var iter = source[Symbol.asyncIterator]();\n    return _defineProperty({}, Symbol.asyncIterator, function () {\n      return {\n        next: iter.next.bind(iter),\n        return: function _return(value) {\n          source.destroy();\n\n          if (typeof iter.return === 'function') {\n            return iter.return();\n          }\n\n          return Promise.resolve({\n            done: true,\n            value: value\n          });\n        }\n      };\n    });\n  }\n\n  if (isWebReadableStream(source)) {\n    var reader = source.getReader();\n    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n      var _yield$_awaitAsyncGen, done, value;\n\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.prev = 0;\n\n            case 1:\n              if (!true) {\n                _context4.next = 14;\n                break;\n              }\n\n              _context4.next = 4;\n              return _awaitAsyncGenerator(reader.read());\n\n            case 4:\n              _yield$_awaitAsyncGen = _context4.sent;\n              done = _yield$_awaitAsyncGen.done;\n              value = _yield$_awaitAsyncGen.value;\n\n              if (!done) {\n                _context4.next = 9;\n                break;\n              }\n\n              return _context4.abrupt(\"return\");\n\n            case 9:\n              if (!value) {\n                _context4.next = 12;\n                break;\n              }\n\n              _context4.next = 12;\n              return value;\n\n            case 12:\n              _context4.next = 1;\n              break;\n\n            case 14:\n              _context4.prev = 14;\n              reader.releaseLock();\n              return _context4.finish(14);\n\n            case 17:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4, null, [[0,, 14, 17]]);\n    }))();\n  }\n\n  if (isAsyncIterable(source)) {\n    return source;\n  }\n\n  throw new TypeError('Body can\\'t be converted to AsyncIterable');\n};\n/**\r\n * Check if it's an AsyncIterable\r\n *\r\n * @template {unknown} TChunk\r\n * @template {any} Other\r\n * @param {Other|AsyncIterable<TChunk>} value\r\n * @returns {value is AsyncIterable<TChunk>}\r\n */\n\n\nvar isAsyncIterable = function isAsyncIterable(value) {\n  return typeof value === 'object' && value !== null && typeof\n  /** @type {any} */\n  value[Symbol.asyncIterator] === 'function';\n};\n/**\r\n * Check for web readable stream\r\n *\r\n * @template {unknown} TChunk\r\n * @template {any} Other\r\n * @param {Other|ReadableStream<TChunk>} value\r\n * @returns {value is ReadableStream<TChunk>}\r\n */\n\n\nvar isWebReadableStream = function isWebReadableStream(value) {\n  return value && typeof\n  /** @type {any} */\n  value.getReader === 'function';\n};\n/**\r\n * @param {any} value\r\n * @returns {value is NodeReadableStream}\r\n */\n\n\nvar isNodeReadableStream = function isNodeReadableStream(value) {\n  return Object.prototype.hasOwnProperty.call(value, 'readable') && Object.prototype.hasOwnProperty.call(value, 'writable');\n};\n\nHTTP.HTTPError = HTTPError;\nHTTP.TimeoutError = TimeoutError;\nHTTP.streamToAsyncIterator = fromStream;\n/**\r\n * @param {string | Request} resource\r\n * @param {HTTPOptions} [options]\r\n * @returns {Promise<Response>}\r\n */\n\nHTTP.post = function (resource, options) {\n  return new HTTP(options).post(resource, options);\n};\n/**\r\n * @param {string | Request} resource\r\n * @param {HTTPOptions} [options]\r\n * @returns {Promise<Response>}\r\n */\n\n\nHTTP.get = function (resource, options) {\n  return new HTTP(options).get(resource, options);\n};\n/**\r\n * @param {string | Request} resource\r\n * @param {HTTPOptions} [options]\r\n * @returns {Promise<Response>}\r\n */\n\n\nHTTP.put = function (resource, options) {\n  return new HTTP(options).put(resource, options);\n};\n/**\r\n * @param {string | Request} resource\r\n * @param {HTTPOptions} [options]\r\n * @returns {Promise<Response>}\r\n */\n\n\nHTTP.delete = function (resource, options) {\n  return new HTTP(options).delete(resource, options);\n};\n/**\r\n * @param {string | Request} resource\r\n * @param {HTTPOptions} [options]\r\n * @returns {Promise<Response>}\r\n */\n\n\nHTTP.options = function (resource, options) {\n  return new HTTP(options).options(resource, options);\n};\n\nmodule.exports = HTTP;","map":{"version":3,"names":["require","fetch","Request","Headers","TimeoutError","HTTPError","merge","bind","ignoreUndefined","URL","URLSearchParams","AbortController","anySignal","timeout","promise","ms","abortController","undefined","start","Date","now","timedOut","time","Promise","resolve","reject","timeoutID","setTimeout","abort","after","next","fn","res","clearTimeout","then","defaults","throwHttpErrors","credentials","HTTP","options","opts","resource","headers","TypeError","url","toString","base","searchParams","transformSearchParams","json","search","body","JSON","stringify","set","signal","response","ok","handleError","iterator","fromStream","ndjson","chunk","transform","method","source","decoder","TextDecoder","buf","decode","stream","lines","split","i","length","l","trim","parse","isNodeReadableStream","iter","Symbol","asyncIterator","return","value","destroy","done","isWebReadableStream","reader","getReader","read","releaseLock","isAsyncIterable","Object","prototype","hasOwnProperty","call","streamToAsyncIterator","post","get","put","delete","module","exports"],"sources":["C:/Users/User/Documents/clone-starter-kit-08/node_modules/ipfs-utils/src/http.js"],"sourcesContent":["/* eslint-disable no-undef */\r\n'use strict'\r\n\r\nconst { fetch, Request, Headers } = require('./http/fetch')\r\nconst { TimeoutError, HTTPError } = require('./http/error')\r\nconst merge = require('merge-options').bind({ ignoreUndefined: true })\r\nconst { URL, URLSearchParams } = require('iso-url')\r\nconst { AbortController } = require('native-abort-controller')\r\nconst anySignal = require('any-signal')\r\n\r\n/**\r\n * @typedef {import('native-fetch').Response} Response\r\n * @typedef {import('stream').Readable} NodeReadableStream\r\n * @typedef {import('stream').Duplex} NodeDuplexStream\r\n * @typedef {import('./types').HTTPOptions} HTTPOptions\r\n */\r\n\r\n/**\r\n * @template TResponse\r\n * @param {Promise<TResponse>} promise\r\n * @param {number | undefined} ms\r\n * @param {AbortController} abortController\r\n * @returns {Promise<TResponse>}\r\n */\r\nconst timeout = (promise, ms, abortController) => {\r\n  if (ms === undefined) {\r\n    return promise\r\n  }\r\n\r\n  const start = Date.now()\r\n\r\n  const timedOut = () => {\r\n    const time = Date.now() - start\r\n\r\n    return time >= ms\r\n  }\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const timeoutID = setTimeout(() => {\r\n      if (timedOut()) {\r\n        reject(new TimeoutError())\r\n        abortController.abort()\r\n      }\r\n    }, ms)\r\n\r\n    /**\r\n     * @param {(value: any) => void } next\r\n     */\r\n    const after = (next) => {\r\n      /**\r\n       * @param {any} res\r\n       */\r\n      const fn = (res) => {\r\n        clearTimeout(timeoutID)\r\n\r\n        if (timedOut()) {\r\n          reject(new TimeoutError())\r\n          return\r\n        }\r\n\r\n        next(res)\r\n      }\r\n      return fn\r\n    }\r\n\r\n    promise\r\n      .then(after(resolve), after(reject))\r\n  })\r\n}\r\n\r\nconst defaults = {\r\n  throwHttpErrors: true,\r\n  credentials: 'same-origin'\r\n}\r\n\r\nclass HTTP {\r\n  /**\r\n   *\r\n   * @param {HTTPOptions} options\r\n   */\r\n  constructor (options = {}) {\r\n    /** @type {HTTPOptions} */\r\n    this.opts = merge(defaults, options)\r\n  }\r\n\r\n  /**\r\n   * Fetch\r\n   *\r\n   * @param {string | Request} resource\r\n   * @param {HTTPOptions} options\r\n   * @returns {Promise<Response>}\r\n   */\r\n  async fetch (resource, options = {}) {\r\n    /** @type {HTTPOptions} */\r\n    const opts = merge(this.opts, options)\r\n    const headers = new Headers(opts.headers)\r\n\r\n    // validate resource type\r\n    if (typeof resource !== 'string' && !(resource instanceof URL || resource instanceof Request)) {\r\n      throw new TypeError('`resource` must be a string, URL, or Request')\r\n    }\r\n\r\n    const url = new URL(resource.toString(), opts.base)\r\n\r\n    const {\r\n      searchParams,\r\n      transformSearchParams,\r\n      json\r\n    } = opts\r\n\r\n    if (searchParams) {\r\n      if (typeof transformSearchParams === 'function') {\r\n        // @ts-ignore\r\n        url.search = transformSearchParams(new URLSearchParams(opts.searchParams))\r\n      } else {\r\n        // @ts-ignore\r\n        url.search = new URLSearchParams(opts.searchParams)\r\n      }\r\n    }\r\n\r\n    if (json) {\r\n      opts.body = JSON.stringify(opts.json)\r\n      headers.set('content-type', 'application/json')\r\n    }\r\n\r\n    const abortController = new AbortController()\r\n    // @ts-ignore\r\n    const signal = anySignal([abortController.signal, opts.signal])\r\n\r\n    const response = await timeout(\r\n      fetch(\r\n        url.toString(),\r\n        {\r\n          ...opts,\r\n          signal,\r\n          timeout: undefined,\r\n          headers\r\n        }\r\n      ),\r\n      opts.timeout,\r\n      abortController\r\n    )\r\n\r\n    if (!response.ok && opts.throwHttpErrors) {\r\n      if (opts.handleError) {\r\n        await opts.handleError(response)\r\n      }\r\n      throw new HTTPError(response)\r\n    }\r\n\r\n    response.iterator = function () {\r\n      return fromStream(response.body)\r\n    }\r\n\r\n    response.ndjson = async function * () {\r\n      for await (const chunk of ndjson(response.iterator())) {\r\n        if (options.transform) {\r\n          yield options.transform(chunk)\r\n        } else {\r\n          yield chunk\r\n        }\r\n      }\r\n    }\r\n\r\n    return response\r\n  }\r\n\r\n  /**\r\n   * @param {string | Request} resource\r\n   * @param {HTTPOptions} options\r\n   * @returns {Promise<Response>}\r\n   */\r\n  post (resource, options = {}) {\r\n    return this.fetch(resource, { ...options, method: 'POST' })\r\n  }\r\n\r\n  /**\r\n   * @param {string | Request} resource\r\n   * @param {HTTPOptions} options\r\n   * @returns {Promise<Response>}\r\n   */\r\n  get (resource, options = {}) {\r\n    return this.fetch(resource, { ...options, method: 'GET' })\r\n  }\r\n\r\n  /**\r\n   * @param {string | Request} resource\r\n   * @param {HTTPOptions} options\r\n   * @returns {Promise<Response>}\r\n   */\r\n  put (resource, options = {}) {\r\n    return this.fetch(resource, { ...options, method: 'PUT' })\r\n  }\r\n\r\n  /**\r\n   * @param {string | Request} resource\r\n   * @param {HTTPOptions} options\r\n   * @returns {Promise<Response>}\r\n   */\r\n  delete (resource, options = {}) {\r\n    return this.fetch(resource, { ...options, method: 'DELETE' })\r\n  }\r\n\r\n  /**\r\n   * @param {string | Request} resource\r\n   * @param {HTTPOptions} options\r\n   * @returns {Promise<Response>}\r\n   */\r\n  options (resource, options = {}) {\r\n    return this.fetch(resource, { ...options, method: 'OPTIONS' })\r\n  }\r\n}\r\n\r\n/**\r\n * Parses NDJSON chunks from an iterator\r\n *\r\n * @param {AsyncIterable<Uint8Array>} source\r\n * @returns {AsyncIterable<any>}\r\n */\r\nconst ndjson = async function * (source) {\r\n  const decoder = new TextDecoder()\r\n  let buf = ''\r\n\r\n  for await (const chunk of source) {\r\n    buf += decoder.decode(chunk, { stream: true })\r\n    const lines = buf.split(/\\r?\\n/)\r\n\r\n    for (let i = 0; i < lines.length - 1; i++) {\r\n      const l = lines[i].trim()\r\n      if (l.length > 0) {\r\n        yield JSON.parse(l)\r\n      }\r\n    }\r\n    buf = lines[lines.length - 1]\r\n  }\r\n  buf += decoder.decode()\r\n  buf = buf.trim()\r\n  if (buf.length !== 0) {\r\n    yield JSON.parse(buf)\r\n  }\r\n}\r\n\r\n/**\r\n * Stream to AsyncIterable\r\n *\r\n * @template TChunk\r\n * @param {ReadableStream<TChunk> | NodeReadableStream | null} source\r\n * @returns {AsyncIterable<TChunk>}\r\n */\r\nconst fromStream = (source) => {\r\n  // Workaround for https://github.com/node-fetch/node-fetch/issues/766\r\n  if (isNodeReadableStream(source)) {\r\n    const iter = source[Symbol.asyncIterator]()\r\n    return {\r\n      [Symbol.asyncIterator] () {\r\n        return {\r\n          next: iter.next.bind(iter),\r\n          return (value) {\r\n            source.destroy()\r\n            if (typeof iter.return === 'function') {\r\n              return iter.return()\r\n            }\r\n            return Promise.resolve({ done: true, value })\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (isWebReadableStream(source)) {\r\n    const reader = source.getReader()\r\n    return (async function * () {\r\n      try {\r\n        while (true) {\r\n          // Read from the stream\r\n          const { done, value } = await reader.read()\r\n          // Exit if we're done\r\n          if (done) return\r\n          // Else yield the chunk\r\n          if (value) {\r\n            yield value\r\n          }\r\n        }\r\n      } finally {\r\n        reader.releaseLock()\r\n      }\r\n    })()\r\n  }\r\n\r\n  if (isAsyncIterable(source)) {\r\n    return source\r\n  }\r\n\r\n  throw new TypeError('Body can\\'t be converted to AsyncIterable')\r\n}\r\n\r\n/**\r\n * Check if it's an AsyncIterable\r\n *\r\n * @template {unknown} TChunk\r\n * @template {any} Other\r\n * @param {Other|AsyncIterable<TChunk>} value\r\n * @returns {value is AsyncIterable<TChunk>}\r\n */\r\nconst isAsyncIterable = (value) => {\r\n  return typeof value === 'object' &&\r\n  value !== null &&\r\n  typeof /** @type {any} */(value)[Symbol.asyncIterator] === 'function'\r\n}\r\n\r\n/**\r\n * Check for web readable stream\r\n *\r\n * @template {unknown} TChunk\r\n * @template {any} Other\r\n * @param {Other|ReadableStream<TChunk>} value\r\n * @returns {value is ReadableStream<TChunk>}\r\n */\r\nconst isWebReadableStream = (value) => {\r\n  return value && typeof /** @type {any} */(value).getReader === 'function'\r\n}\r\n\r\n/**\r\n * @param {any} value\r\n * @returns {value is NodeReadableStream}\r\n */\r\nconst isNodeReadableStream = (value) =>\r\n  Object.prototype.hasOwnProperty.call(value, 'readable') &&\r\n  Object.prototype.hasOwnProperty.call(value, 'writable')\r\n\r\nHTTP.HTTPError = HTTPError\r\nHTTP.TimeoutError = TimeoutError\r\nHTTP.streamToAsyncIterator = fromStream\r\n\r\n/**\r\n * @param {string | Request} resource\r\n * @param {HTTPOptions} [options]\r\n * @returns {Promise<Response>}\r\n */\r\nHTTP.post = (resource, options) => new HTTP(options).post(resource, options)\r\n\r\n/**\r\n * @param {string | Request} resource\r\n * @param {HTTPOptions} [options]\r\n * @returns {Promise<Response>}\r\n */\r\nHTTP.get = (resource, options) => new HTTP(options).get(resource, options)\r\n\r\n/**\r\n * @param {string | Request} resource\r\n * @param {HTTPOptions} [options]\r\n * @returns {Promise<Response>}\r\n */\r\nHTTP.put = (resource, options) => new HTTP(options).put(resource, options)\r\n\r\n/**\r\n * @param {string | Request} resource\r\n * @param {HTTPOptions} [options]\r\n * @returns {Promise<Response>}\r\n */\r\nHTTP.delete = (resource, options) => new HTTP(options).delete(resource, options)\r\n\r\n/**\r\n * @param {string | Request} resource\r\n * @param {HTTPOptions} [options]\r\n * @returns {Promise<Response>}\r\n */\r\nHTTP.options = (resource, options) => new HTTP(options).options(resource, options)\r\n\r\nmodule.exports = HTTP\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}