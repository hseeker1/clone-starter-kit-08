{"ast":null,"code":"/*\r\n    Copyright 2021 The caver-js Authors\r\n    This file is part of the caver-js library.\r\n\r\n    The caver-js library is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    The caver-js library is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\r\n*/\nconst utils = require('../../caver-utils');\n\nconst {\n  KEY_ROLE\n} = require('../../caver-wallet/src/keyring/keyringHelper');\n\nconst {\n  refineSignatures\n} = require('../../caver-transaction/src/transactionHelper/transactionHelper');\n\nconst AbstractTransaction = require('../../caver-transaction/src/transactionTypes/abstractTransaction');\n\nconst AbstractFeeDelegatedTransaction = require('../../caver-transaction/src/transactionTypes/abstractFeeDelegatedTransaction');\n/**\r\n * Representing a class to support validation functions.\r\n * @class\r\n * @hideconstructor\r\n */\n\n\nclass Validator {\n  /**\r\n   * Creates a Validator.\r\n   *\r\n   * @constructor\r\n   * @param {object} klaytnCall - An object includes klay rpc calls.\r\n   */\n  constructor(klaytnCall) {\n    this.klaytnCall = klaytnCall;\n  }\n  /**\r\n   * Validates a signed message by comparing the public key recovered from the signature with the account key of the Klaytn account.\r\n   *\r\n   * @example\r\n   * const address = '0x...'\r\n   * const message = 'Some data'\r\n   * const signature = { v: '0x1c', r: '0xd0b8d...', s: '0x5472e...' } // You can get a signature via `keyring.signMessage(...).signatures[0]`.\r\n   * const isValid = caver.validator.validateSignedMessage(message, signature, address)\r\n   *\r\n   * @memberof Validator\r\n   * @inner\r\n   *\r\n   * @param {string} message The raw message string. If this message is hased with Klaytn specific prefix, the third parameter should be passed as `true`.\r\n   * @param {SignatureData|Array.<SignatureData>} signatures An instance of `SignatureData` or an array of `SignatureData`.\r\n   * @param {string} address The address of the account that signed the message.\r\n   * @param {boolean} [isHashed] (optional, default: `false`) If the `isHashed` is true, the given message will NOT automatically be prefixed with \"\\x19Klaytn Signed Message:\\n\" + message.length + message, and be assumed as already prefixed.\r\n   * @return {Promise<boolean>} The promise will be resolved with a boolean value of whether the signature on the message is valid or not.\r\n   */\n\n\n  async validateSignedMessage(message, signatures, address) {\n    let isHashed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const getAccountKeyResult = await this.klaytnCall.getAccountKey(address); // Remove duplicate and format to `Array.<SignatureData>` type.\n\n    signatures = refineSignatures(signatures);\n    const publicKeys = [];\n\n    for (const sig of signatures) {\n      const recovered = utils.recoverPublicKey(message, sig, isHashed);\n      const pub = recovered.toString();\n      publicKeys.push(pub);\n    }\n\n    return validateWithAccountKeyAndRole(address, getAccountKeyResult, publicKeys, KEY_ROLE.roleTransactionKey);\n  }\n  /**\r\n   * Validates a transaction.\r\n   * This function compares the public keys from the account key of the Klaytn account with the public keys recovered from `signatures`.\r\n   * If the transaction is fee-delegated with the `feePayerSignatures` variable inside, this function compares the public keys recovered from `feePayerSignatures` with the public keys of the fee payer.\r\n   *\r\n   * @example\r\n   * const tx = caver.transaction.valueTransfer.create({...})\r\n   * const isValid = caver.validator.validateTransaction(tx)\r\n   *\r\n   * @memberof Validator\r\n   * @inner\r\n   *\r\n   * @param {module:Transaction.Transaction} tx An instance of transaction to validate.\r\n   * @return {boolean}\r\n   */\n\n\n  async validateTransaction(tx) {\n    let isValid = await this.validateSender(tx);\n\n    if (isValid === true && tx instanceof AbstractFeeDelegatedTransaction) {\n      isValid = this.validateFeePayer(tx);\n    }\n\n    return isValid;\n  }\n  /**\r\n   * Validates the sender of the transaction.\r\n   * This function compares the public keys of the account key of the Klaytn account with the public keys recovered from `signatures`.\r\n   *\r\n   * @example\r\n   * const tx = caver.transaction.valueTransfer.create({...})\r\n   * const isValid = caver.validator.validateSender(tx)\r\n   *\r\n   * @memberof Validator\r\n   * @inner\r\n   *\r\n   * @param {module:Transaction.Transaction} tx An instance of transaction to validate.\r\n   * @return {boolean}\r\n   */\n\n\n  async validateSender(tx) {\n    if (!(tx instanceof AbstractTransaction)) throw new Error('Invalid parameter type: To validate `signatures` field in the transaction, you need to pass the transaction instance.');\n    const fromAccountKey = await this.klaytnCall.getAccountKey(tx.from);\n    const publicKeys = tx.recoverPublicKeys();\n    const role = tx.type.includes('AccountUpdate') ? KEY_ROLE.roleAccountUpdateKey : KEY_ROLE.roleTransactionKey;\n    return validateWithAccountKeyAndRole(tx.from, fromAccountKey, publicKeys, role);\n  }\n  /**\r\n   * Validates a fee payer in the transaction.\r\n   * This function compares the public keys of the account key of the fee payer with the public keys recovered from `feePayerSignatures`.\r\n   *\r\n   * @example\r\n   * const tx = caver.transaction.feeDelegatedValueTransfer.create({...})\r\n   * const isValid = caver.validator.validateFeePayer(tx)\r\n   *\r\n   * @memberof Validator\r\n   * @inner\r\n   *\r\n   * @param {module:Transaction.FeeDelegatedTransaction} tx An instance of transaction to validate.\r\n   * @return {boolean}\r\n   */\n\n\n  async validateFeePayer(tx) {\n    if (!(tx instanceof AbstractFeeDelegatedTransaction)) throw new Error('Invalid parameter type: To validate `feePayerSignatures` field in the transaction, you need to pass the fee-delegated transaction instance.');\n    const feePayerAccountKey = await this.klaytnCall.getAccountKey(tx.feePayer);\n    const publicKeys = tx.recoverFeePayerPublicKeys();\n    const role = KEY_ROLE.roleFeePayerKey;\n    return validateWithAccountKeyAndRole(tx.feePayer, feePayerAccountKey, publicKeys, role);\n  }\n\n}\n\nfunction validateWithAccountKeyAndRole(address, accountKey, publicKeys, role) {\n  let isValid = false; // For accounts that have not yet been applied in Klaytn's state, the return value of `caver.rpc.klay.getAccountKey` is null.\n  // In this case, the account's key has never been updated, so the logic is the same as in AccountKeyLegacy.\n\n  if (accountKey === null) accountKey = {\n    keyType: 1,\n    key: {}\n  };\n\n  switch (accountKey.keyType) {\n    case 1:\n      // TODO: If an invalid signature is included, it should be changed to return false.\n      // if (signatures.length > 1) return isValid\n      for (const pub of publicKeys) {\n        const recoveredAddress = utils.publicKeyToAddress(pub);\n\n        if (recoveredAddress.toLowerCase() === address.toLowerCase()) {\n          isValid = true;\n          break;\n        }\n      }\n\n      break;\n\n    case 2:\n      // TODO: If an invalid signature is included, it should be changed to return false.\n      // if (signatures.length > 1) return isValid\n      for (const pub of publicKeys) {\n        const xyPoints = utils.xyPointFromPublicKey(pub);\n\n        if (xyPoints[0].toLowerCase() === accountKey.key.x.toLowerCase() && xyPoints[1].toLowerCase() === accountKey.key.y.toLowerCase()) {\n          isValid = true;\n          break;\n        }\n      }\n\n      break;\n\n    case 3:\n      break;\n\n    case 4:\n      // TODO: If an invalid signature is included, it should be changed to return false.\n      // if (signatures.length > accountKey.key.keys.length) return isValid\n      let weightSum = 0;\n      const threshold = accountKey.key.threshold;\n\n      for (const pub of publicKeys) {\n        for (const pubKey of accountKey.key.keys) {\n          const xyPoints = utils.xyPointFromPublicKey(pub);\n\n          if (xyPoints[0].toLowerCase() === pubKey.key.x.toLowerCase() && xyPoints[1].toLowerCase() === pubKey.key.y.toLowerCase()) {\n            weightSum += pubKey.weight;\n            break;\n          }\n        } // If sum of weight is satisfied threshold, signatures are valid.\n\n\n        if (weightSum >= threshold) {\n          isValid = true;\n          break;\n        }\n      }\n\n      break;\n\n    case 5:\n      // If the AccountKey of the account is AccountKeyRoleBased,\n      // it is judged as valid only if the signature is signed using valid role key.\n      const roleKey = accountKey.key[role];\n      if (accountKey.key[role].keyType === 5) throw new Error(`Invalid account key type: nested composite type`);\n      isValid = validateWithAccountKeyAndRole(address, roleKey, publicKeys);\n      break;\n\n    default:\n      throw new Error(`Invalid account key type`);\n  }\n\n  return isValid;\n}\n\nmodule.exports = Validator;","map":{"version":3,"names":["utils","require","KEY_ROLE","refineSignatures","AbstractTransaction","AbstractFeeDelegatedTransaction","Validator","constructor","klaytnCall","validateSignedMessage","message","signatures","address","isHashed","getAccountKeyResult","getAccountKey","publicKeys","sig","recovered","recoverPublicKey","pub","toString","push","validateWithAccountKeyAndRole","roleTransactionKey","validateTransaction","tx","isValid","validateSender","validateFeePayer","Error","fromAccountKey","from","recoverPublicKeys","role","type","includes","roleAccountUpdateKey","feePayerAccountKey","feePayer","recoverFeePayerPublicKeys","roleFeePayerKey","accountKey","keyType","key","recoveredAddress","publicKeyToAddress","toLowerCase","xyPoints","xyPointFromPublicKey","x","y","weightSum","threshold","pubKey","keys","weight","roleKey","module","exports"],"sources":["C:/Users/User/Documents/clone-starter-kit-08/node_modules/caver-js/packages/caver-validator/src/index.js"],"sourcesContent":["/*\r\n    Copyright 2021 The caver-js Authors\r\n    This file is part of the caver-js library.\r\n\r\n    The caver-js library is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    The caver-js library is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst utils = require('../../caver-utils')\r\nconst { KEY_ROLE } = require('../../caver-wallet/src/keyring/keyringHelper')\r\nconst { refineSignatures } = require('../../caver-transaction/src/transactionHelper/transactionHelper')\r\nconst AbstractTransaction = require('../../caver-transaction/src/transactionTypes/abstractTransaction')\r\nconst AbstractFeeDelegatedTransaction = require('../../caver-transaction/src/transactionTypes/abstractFeeDelegatedTransaction')\r\n\r\n/**\r\n * Representing a class to support validation functions.\r\n * @class\r\n * @hideconstructor\r\n */\r\nclass Validator {\r\n    /**\r\n     * Creates a Validator.\r\n     *\r\n     * @constructor\r\n     * @param {object} klaytnCall - An object includes klay rpc calls.\r\n     */\r\n    constructor(klaytnCall) {\r\n        this.klaytnCall = klaytnCall\r\n    }\r\n\r\n    /**\r\n     * Validates a signed message by comparing the public key recovered from the signature with the account key of the Klaytn account.\r\n     *\r\n     * @example\r\n     * const address = '0x...'\r\n     * const message = 'Some data'\r\n     * const signature = { v: '0x1c', r: '0xd0b8d...', s: '0x5472e...' } // You can get a signature via `keyring.signMessage(...).signatures[0]`.\r\n     * const isValid = caver.validator.validateSignedMessage(message, signature, address)\r\n     *\r\n     * @memberof Validator\r\n     * @inner\r\n     *\r\n     * @param {string} message The raw message string. If this message is hased with Klaytn specific prefix, the third parameter should be passed as `true`.\r\n     * @param {SignatureData|Array.<SignatureData>} signatures An instance of `SignatureData` or an array of `SignatureData`.\r\n     * @param {string} address The address of the account that signed the message.\r\n     * @param {boolean} [isHashed] (optional, default: `false`) If the `isHashed` is true, the given message will NOT automatically be prefixed with \"\\x19Klaytn Signed Message:\\n\" + message.length + message, and be assumed as already prefixed.\r\n     * @return {Promise<boolean>} The promise will be resolved with a boolean value of whether the signature on the message is valid or not.\r\n     */\r\n    async validateSignedMessage(message, signatures, address, isHashed = false) {\r\n        const getAccountKeyResult = await this.klaytnCall.getAccountKey(address)\r\n\r\n        // Remove duplicate and format to `Array.<SignatureData>` type.\r\n        signatures = refineSignatures(signatures)\r\n\r\n        const publicKeys = []\r\n        for (const sig of signatures) {\r\n            const recovered = utils.recoverPublicKey(message, sig, isHashed)\r\n            const pub = recovered.toString()\r\n            publicKeys.push(pub)\r\n        }\r\n\r\n        return validateWithAccountKeyAndRole(address, getAccountKeyResult, publicKeys, KEY_ROLE.roleTransactionKey)\r\n    }\r\n\r\n    /**\r\n     * Validates a transaction.\r\n     * This function compares the public keys from the account key of the Klaytn account with the public keys recovered from `signatures`.\r\n     * If the transaction is fee-delegated with the `feePayerSignatures` variable inside, this function compares the public keys recovered from `feePayerSignatures` with the public keys of the fee payer.\r\n     *\r\n     * @example\r\n     * const tx = caver.transaction.valueTransfer.create({...})\r\n     * const isValid = caver.validator.validateTransaction(tx)\r\n     *\r\n     * @memberof Validator\r\n     * @inner\r\n     *\r\n     * @param {module:Transaction.Transaction} tx An instance of transaction to validate.\r\n     * @return {boolean}\r\n     */\r\n    async validateTransaction(tx) {\r\n        let isValid = await this.validateSender(tx)\r\n\r\n        if (isValid === true && tx instanceof AbstractFeeDelegatedTransaction) {\r\n            isValid = this.validateFeePayer(tx)\r\n        }\r\n\r\n        return isValid\r\n    }\r\n\r\n    /**\r\n     * Validates the sender of the transaction.\r\n     * This function compares the public keys of the account key of the Klaytn account with the public keys recovered from `signatures`.\r\n     *\r\n     * @example\r\n     * const tx = caver.transaction.valueTransfer.create({...})\r\n     * const isValid = caver.validator.validateSender(tx)\r\n     *\r\n     * @memberof Validator\r\n     * @inner\r\n     *\r\n     * @param {module:Transaction.Transaction} tx An instance of transaction to validate.\r\n     * @return {boolean}\r\n     */\r\n    async validateSender(tx) {\r\n        if (!(tx instanceof AbstractTransaction))\r\n            throw new Error(\r\n                'Invalid parameter type: To validate `signatures` field in the transaction, you need to pass the transaction instance.'\r\n            )\r\n        const fromAccountKey = await this.klaytnCall.getAccountKey(tx.from)\r\n        const publicKeys = tx.recoverPublicKeys()\r\n\r\n        const role = tx.type.includes('AccountUpdate') ? KEY_ROLE.roleAccountUpdateKey : KEY_ROLE.roleTransactionKey\r\n\r\n        return validateWithAccountKeyAndRole(tx.from, fromAccountKey, publicKeys, role)\r\n    }\r\n\r\n    /**\r\n     * Validates a fee payer in the transaction.\r\n     * This function compares the public keys of the account key of the fee payer with the public keys recovered from `feePayerSignatures`.\r\n     *\r\n     * @example\r\n     * const tx = caver.transaction.feeDelegatedValueTransfer.create({...})\r\n     * const isValid = caver.validator.validateFeePayer(tx)\r\n     *\r\n     * @memberof Validator\r\n     * @inner\r\n     *\r\n     * @param {module:Transaction.FeeDelegatedTransaction} tx An instance of transaction to validate.\r\n     * @return {boolean}\r\n     */\r\n    async validateFeePayer(tx) {\r\n        if (!(tx instanceof AbstractFeeDelegatedTransaction))\r\n            throw new Error(\r\n                'Invalid parameter type: To validate `feePayerSignatures` field in the transaction, you need to pass the fee-delegated transaction instance.'\r\n            )\r\n        const feePayerAccountKey = await this.klaytnCall.getAccountKey(tx.feePayer)\r\n        const publicKeys = tx.recoverFeePayerPublicKeys()\r\n\r\n        const role = KEY_ROLE.roleFeePayerKey\r\n\r\n        return validateWithAccountKeyAndRole(tx.feePayer, feePayerAccountKey, publicKeys, role)\r\n    }\r\n}\r\n\r\nfunction validateWithAccountKeyAndRole(address, accountKey, publicKeys, role) {\r\n    let isValid = false\r\n\r\n    // For accounts that have not yet been applied in Klaytn's state, the return value of `caver.rpc.klay.getAccountKey` is null.\r\n    // In this case, the account's key has never been updated, so the logic is the same as in AccountKeyLegacy.\r\n    if (accountKey === null) accountKey = { keyType: 1, key: {} }\r\n\r\n    switch (accountKey.keyType) {\r\n        case 1:\r\n            // TODO: If an invalid signature is included, it should be changed to return false.\r\n            // if (signatures.length > 1) return isValid\r\n            for (const pub of publicKeys) {\r\n                const recoveredAddress = utils.publicKeyToAddress(pub)\r\n\r\n                if (recoveredAddress.toLowerCase() === address.toLowerCase()) {\r\n                    isValid = true\r\n                    break\r\n                }\r\n            }\r\n            break\r\n        case 2:\r\n            // TODO: If an invalid signature is included, it should be changed to return false.\r\n            // if (signatures.length > 1) return isValid\r\n            for (const pub of publicKeys) {\r\n                const xyPoints = utils.xyPointFromPublicKey(pub)\r\n                if (\r\n                    xyPoints[0].toLowerCase() === accountKey.key.x.toLowerCase() &&\r\n                    xyPoints[1].toLowerCase() === accountKey.key.y.toLowerCase()\r\n                ) {\r\n                    isValid = true\r\n                    break\r\n                }\r\n            }\r\n            break\r\n        case 3:\r\n            break\r\n        case 4:\r\n            // TODO: If an invalid signature is included, it should be changed to return false.\r\n            // if (signatures.length > accountKey.key.keys.length) return isValid\r\n            let weightSum = 0\r\n            const threshold = accountKey.key.threshold\r\n\r\n            for (const pub of publicKeys) {\r\n                for (const pubKey of accountKey.key.keys) {\r\n                    const xyPoints = utils.xyPointFromPublicKey(pub)\r\n                    if (\r\n                        xyPoints[0].toLowerCase() === pubKey.key.x.toLowerCase() &&\r\n                        xyPoints[1].toLowerCase() === pubKey.key.y.toLowerCase()\r\n                    ) {\r\n                        weightSum += pubKey.weight\r\n                        break\r\n                    }\r\n                }\r\n\r\n                // If sum of weight is satisfied threshold, signatures are valid.\r\n                if (weightSum >= threshold) {\r\n                    isValid = true\r\n                    break\r\n                }\r\n            }\r\n            break\r\n        case 5:\r\n            // If the AccountKey of the account is AccountKeyRoleBased,\r\n            // it is judged as valid only if the signature is signed using valid role key.\r\n            const roleKey = accountKey.key[role]\r\n            if (accountKey.key[role].keyType === 5) throw new Error(`Invalid account key type: nested composite type`)\r\n            isValid = validateWithAccountKeyAndRole(address, roleKey, publicKeys)\r\n            break\r\n        default:\r\n            throw new Error(`Invalid account key type`)\r\n    }\r\n\r\n    return isValid\r\n}\r\n\r\nmodule.exports = Validator\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}