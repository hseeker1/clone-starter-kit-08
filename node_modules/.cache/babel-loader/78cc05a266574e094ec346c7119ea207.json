{"ast":null,"code":"var _asyncToGenerator = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _get = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createSuper\");\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\n/*\r\n    Copyright 2022 The caver-js Authors\r\n    This file is part of the caver-js library.\r\n\r\n    The caver-js library is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    The caver-js library is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\r\n*/\nvar _ = require('lodash');\n\nvar RLP = require('eth-lib/lib/rlp');\n\nvar Bytes = require('eth-lib/lib/bytes');\n\nvar Hash = require('eth-lib/lib/hash');\n\nvar AbstractTransaction = require('../abstractTransaction');\n\nvar _require = require('../../transactionHelper/transactionHelper'),\n    TX_TYPE_STRING = _require.TX_TYPE_STRING,\n    TX_TYPE_TAG = _require.TX_TYPE_TAG,\n    refineSignatures = _require.refineSignatures,\n    getTypeTagWithoutEthereumTxTypeEnvelopeTag = _require.getTypeTagWithoutEthereumTxTypeEnvelopeTag,\n    isNot = _require.isNot;\n\nvar utils = require('../../../../caver-utils/src');\n\nvar AccessList = require('../../utils/accessList');\n\nvar TransactionHasher = require('../../transactionHasher/transactionHasher');\n\nfunction _decode(rlpEncoded) {\n  rlpEncoded = utils.addHexPrefix(rlpEncoded);\n  if (!rlpEncoded.startsWith(TX_TYPE_TAG.TxTypeEthereumAccessList)) throw new Error(\"Cannot decode to EthereumAccessList. The prefix must be \".concat(TX_TYPE_TAG.TxTypeEthereumAccessList, \": \").concat(rlpEncoded));\n  var typeDettached = \"0x\".concat(rlpEncoded.replace(TX_TYPE_TAG.TxTypeEthereumAccessList, ''));\n\n  var _RLP$decode = RLP.decode(typeDettached),\n      _RLP$decode2 = _slicedToArray(_RLP$decode, 11),\n      chainId = _RLP$decode2[0],\n      nonce = _RLP$decode2[1],\n      gasPrice = _RLP$decode2[2],\n      gas = _RLP$decode2[3],\n      to = _RLP$decode2[4],\n      value = _RLP$decode2[5],\n      input = _RLP$decode2[6],\n      encodedAccessList = _RLP$decode2[7],\n      v = _RLP$decode2[8],\n      r = _RLP$decode2[9],\n      s = _RLP$decode2[10];\n\n  return {\n    chainId: utils.trimLeadingZero(chainId),\n    nonce: utils.trimLeadingZero(nonce),\n    gasPrice: utils.trimLeadingZero(gasPrice),\n    gas: utils.trimLeadingZero(gas),\n    to: to,\n    value: utils.trimLeadingZero(value),\n    input: input,\n    encodedAccessList: encodedAccessList,\n    signatures: [v, r, s]\n  };\n}\n/**\r\n * Represents a ethereum access list transaction.\r\n * @class\r\n * @hideconstructor\r\n * @augments AbstractTransaction\r\n */\n\n\nvar EthereumAccessList = /*#__PURE__*/function (_AbstractTransaction) {\n  \"use strict\";\n\n  _inherits(EthereumAccessList, _AbstractTransaction);\n\n  var _super = _createSuper(EthereumAccessList);\n\n  /**\r\n   * Creates a ethereum access list transaction.\r\n   * @constructor\r\n   * @param {object|string} createTxObj - The parameters to create a EthereumAccessList transaction. This can be an object defining transaction information, or it can be an RLP-encoded string.\r\n   *                                      If it is an RLP-encoded string, decode it to create a transaction instance.\r\n   *                                      The object can define `from`, `to`, `value`, `input`, `nonce`, `gas`, `gasPrice`, `accessList` and `chainId`.\r\n   * @param {object} [klaytnCall] - An object includes klay rpc calls.\r\n   */\n  function EthereumAccessList(createTxObj, klaytnCall) {\n    var _this;\n\n    _classCallCheck(this, EthereumAccessList);\n\n    if (_.isString(createTxObj)) createTxObj = _decode(createTxObj);\n    createTxObj.from = createTxObj.from || '0x0000000000000000000000000000000000000000';\n    _this = _super.call(this, TX_TYPE_STRING.TxTypeEthereumAccessList, createTxObj, klaytnCall);\n    _this.to = createTxObj.to || '0x';\n    if (createTxObj.input && createTxObj.data) throw new Error(\"'input' and 'data' properties cannot be defined at the same time, please use either 'input' or 'data'.\");\n    _this.input = createTxObj.input || createTxObj.data || '0x';\n    _this.value = createTxObj.value || '0x0';\n    _this.accessList = createTxObj.accessList || [];\n    if (createTxObj.gasPrice !== undefined) _this.gasPrice = createTxObj.gasPrice;\n    return _this;\n  }\n  /**\r\n   * @type {string}\r\n   */\n\n\n  _createClass(EthereumAccessList, [{\n    key: \"gasPrice\",\n    get: function get() {\n      return this._gasPrice;\n    },\n    set: function set(g) {\n      this._gasPrice = utils.numberToHex(g);\n    }\n    /**\r\n     * @type {string}\r\n     */\n\n  }, {\n    key: \"to\",\n    get: function get() {\n      return this._to;\n    },\n    set: function set(address) {\n      if (address !== '0x' && !utils.isAddress(address)) throw new Error(\"Invalid address \".concat(address));\n      this._to = address.toLowerCase();\n    }\n    /**\r\n     * @type {string}\r\n     */\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this._value;\n    },\n    set: function set(val) {\n      this._value = utils.numberToHex(val);\n    }\n    /**\r\n     * @type {string}\r\n     */\n\n  }, {\n    key: \"input\",\n    get: function get() {\n      return this._input;\n    },\n    set: function set(input) {\n      if (!input || !utils.isHex(input)) throw new Error(\"Invalid input data \".concat(input));\n      this._input = utils.addHexPrefix(input);\n    }\n    /**\r\n     * @type {string}\r\n     */\n\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this._input;\n    },\n    set: function set(data) {\n      this._input = data;\n    }\n    /**\r\n     * @type {AccessList}\r\n     */\n\n  }, {\n    key: \"accessList\",\n    get: function get() {\n      return this._accessList;\n    },\n    set: function set(list) {\n      if (!(list instanceof AccessList)) list = AccessList.create(list);\n      this._accessList = list;\n    }\n    /**\r\n     * @type {SignatureData}\r\n     */\n\n  }, {\n    key: \"signatures\",\n    get: function get() {\n      return this._signatures;\n    } // overrides signatures getter/setter to validate y-parity.\n    ,\n    set: function set(sigs) {\n      var refined = refineSignatures(sigs, this.type);\n\n      if (!utils.isEmptySig(refined)) {\n        var v = utils.hexToNumber(refined.v);\n\n        if (v !== 0 && v !== 1) {\n          throw new Error(\"Invalid signature: The y-parity of the transaction should either be 0 or 1.\");\n        }\n      }\n\n      this._signatures = refined;\n    }\n    /**\r\n     * Appends signatures array to transaction.\r\n     * EthereumAccessList transaction cannot have more than one signature, so an error will be occured if the transaction already has a signature or the `sig` parameter has more than one signatures.\r\n     *\r\n     * @example\r\n     * tx.appendSignatures([ '0x0fea', '0xade94...', '0x38160...' ])\r\n     *\r\n     * @override\r\n     * @param {SignatureData|Array.<SignatureData>|Array.<string>|Array.<Array.<string>>} signatures - The `signatures` to be appended to the transaction. {@link SignatureData|SignatureData} instance or an array containing {@link SignatureData|SignatureData} instances.\r\n     *                                                                                                 An array in which each 'v', 'r', and 's' are sequentially defined as string formats or a 2D array containing those arrays can also be taken as parameters.\r\n     */\n\n  }, {\n    key: \"appendSignatures\",\n    value: function appendSignatures(sig) {\n      if (!utils.isEmptySig(this.signatures)) throw new Error(\"signatures already defined. \".concat(this.type, \" cannot include more than one signature. Please use tx.signatures = sigArr to replace.\"));\n\n      if (Array.isArray(sig[0])) {\n        if (sig.length > 1) throw new Error(\"signatures are too long. \".concat(this.type, \" cannot include more than one signature.\"));\n        sig = sig[0];\n      }\n\n      this.signatures = sig;\n    }\n    /**\r\n     * Returns the RLP-encoded string of this transaction (i.e., rawTransaction).\r\n     * This returns with `TxTypeEthereumAccessList` type prefix('0x7801').\r\n     *\r\n     * @example\r\n     * const result = tx.getRLPEncoding()\r\n     *\r\n     * @return {string} An RLP-encoded transaction string.\r\n     */\n\n  }, {\n    key: \"getRLPEncoding\",\n    value: function getRLPEncoding() {\n      this.validateOptionalValues(); // TxTypeEthereumEnvelope(0x78) || 0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, signatureYParity, signatureR, signatureS])\n\n      var _this$signatures$enco = this.signatures.encode(),\n          _this$signatures$enco2 = _slicedToArray(_this$signatures$enco, 3),\n          v = _this$signatures$enco2[0],\n          r = _this$signatures$enco2[1],\n          s = _this$signatures$enco2[2];\n\n      return TX_TYPE_TAG[this.type] + RLP.encode([Bytes.fromNat(this.chainId), Bytes.fromNat(this.nonce), Bytes.fromNat(this.gasPrice), Bytes.fromNat(this.gas), this.to.toLowerCase(), Bytes.fromNat(this.value), this.input, this.accessList.encodeToBytes(), v, r, s]).slice(2);\n    }\n    /**\r\n     * Returns RLP-encoded string for making signature.\r\n     *\r\n     * @example\r\n     * const result = tx.getRLPEncodingForSignature()\r\n     *\r\n     * @override\r\n     * @return {string}\r\n     */\n\n  }, {\n    key: \"getRLPEncodingForSignature\",\n    value: function getRLPEncodingForSignature() {\n      this.validateOptionalValues(); // sigRLP = 0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList])\n\n      return getTypeTagWithoutEthereumTxTypeEnvelopeTag(this.type) + RLP.encode([Bytes.fromNat(this.chainId), Bytes.fromNat(this.nonce), Bytes.fromNat(this.gasPrice), Bytes.fromNat(this.gas), this.to.toLowerCase(), Bytes.fromNat(this.value), this.input, this.accessList.encodeToBytes()]).slice(2);\n    }\n    /**\r\n     * EthereumAccessList does not have a common RLP encoding because no other type exists.\r\n     * So getCommonRLPEncodingForSignature calls getRLPEncodingForSignature to return RLP-encoded string.\r\n     *\r\n     * @return {string}\r\n     */\n\n  }, {\n    key: \"getCommonRLPEncodingForSignature\",\n    value: function getCommonRLPEncodingForSignature() {\n      return this.getRLPEncodingForSignature();\n    }\n    /**\r\n     * Recovers the public key strings from `signatures` field in transaction object.\r\n     * If you want to derive an address from public key, please use {@link module:utils~publicKeyToAddress|caver.utils.publicKeyToAddress}.\r\n     *\r\n     * @example\r\n     * const publicKey = tx.recoverPublicKeys()\r\n     *\r\n     * @return {Array.<string>} An array containing public keys recovered from `signatures`.\r\n     */\n\n  }, {\n    key: \"recoverPublicKeys\",\n    value: function recoverPublicKeys() {\n      if (utils.isEmptySig(this.signatures)) throw new Error(\"Failed to recover public key from signatures: signatures is empty.\");\n      var recovery = Bytes.toNumber(this.signatures.v);\n      var signingDataHex = this.getRLPEncodingForSignature();\n      var hasedSigningData = Hash.keccak256(signingDataHex);\n      var publicKeys = [];\n      publicKeys.push(utils.recoverPublicKey(hasedSigningData, [utils.makeEven(utils.toHex(recovery)), this.signatures.r, this.signatures.s], true));\n      return publicKeys;\n    }\n    /**\r\n     * Signs the transaction as a transaction sender with the private key(s) in the `keyring` and appends `signatures` in the transaction object.\r\n     *\r\n     * If the user has not defined an `index`, `transaction.sign` signs the transaction using \"all the private keys\" used by the role.\r\n     * If `index` is defined, the `transaction.sign` signs the transaction using \"only one private key\" at the given index.\r\n     *\r\n     * @example\r\n     * const keyring = caver.wallet.keyring.create('0x{address in hex}', '0x{private key}')\r\n     * const signedTx = await tx.sign(keyring)\r\n     *\r\n     * const keyring = caver.wallet.keyring.create('0x{address in hex}', ['0x{private key}', '0x{private key}'])\r\n     * const signedTx = await tx.sign(keyring, 1) // sign the transaction with index. If omitted, sign with all private keys.\r\n     *\r\n     * @param {KeyringContainer.Keyring|string} key - A private key string ({@link https://docs.klaytn.com/klaytn/design/accounts#klaytn-wallet-key-format|KlaytnWalletKey} format is also allowed) or an instance of {@link KeyringContainer.Keyring|Keyring}. If a private key string or a KlaytnWalletKey is passed as a parameter, the keyring instance is created internally.\r\n     * @param {number} [index] - The index of the private key you want to use. The index must be less than the length of the array of the private keys defined for each role. If an index is not defined, this method will use all the private keys.\r\n     * @param {function} [hasher] - The hash function to get the hash of the transaction.\r\n     * @return {module:Transaction.Transaction} An instance of signed Transaction. The `signature` is appended to the `transaction.signatures`.\r\n     */\n\n  }, {\n    key: \"sign\",\n    value: function () {\n      var _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(key, index) {\n        var hasher,\n            _yield$this$_sign,\n            keyring,\n            hash,\n            role,\n            sig,\n            _args = arguments;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                hasher = _args.length > 2 && _args[2] !== undefined ? _args[2] : TransactionHasher.getHashForSignature;\n\n                // User parameter input cases\n                // (key) / (key index) / (key hasher) / (key index hasher)\n                if (_.isFunction(index)) {\n                  hasher = index;\n                  index = undefined;\n                }\n\n                _context.next = 4;\n                return this._sign(key, hasher);\n\n              case 4:\n                _yield$this$_sign = _context.sent;\n                keyring = _yield$this$_sign.keyring;\n                hash = _yield$this$_sign.hash;\n                role = _yield$this$_sign.role;\n                sig = keyring.ecsign(hash, role, index);\n                this.appendSignatures(sig);\n                return _context.abrupt(\"return\", this);\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function sign(_x, _x2) {\n        return _sign.apply(this, arguments);\n      }\n\n      return sign;\n    }()\n    /**\r\n     * Fills in the optional variables in transaction.\r\n     *\r\n     * If the `gasPrice`, `nonce`, or `chainId` of the transaction are not defined, this method asks the default values for these optional variables and preset them by sending JSON RPC call to the connected Klaytn Node.\r\n     * Use {@link Klay#getGasPrice|caver.rpc.klay.getGasPrice} to get gasPrice, {@link Klay#getTransactionCount|caver.rpc.klay.getTransactionCount} to get nonce and {@link Klay#getChainId|caver.rpc.klay.getChainId} call to get chainId.\r\n     *\r\n     * @example\r\n     * await tx.fillTransaction()\r\n     */\n\n  }, {\n    key: \"fillTransaction\",\n    value: function () {\n      var _fillTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _yield$Promise$all, _yield$Promise$all2, chainId, gasPrice, nonce;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return Promise.all([isNot(this.chainId) ? this.getChainId() : this.chainId, isNot(this.gasPrice) ? this.suggestGasPrice() : this.gasPrice, isNot(this.nonce) ? this.getNonce(this.from) : this.nonce]);\n\n              case 2:\n                _yield$Promise$all = _context2.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 3);\n                chainId = _yield$Promise$all2[0];\n                gasPrice = _yield$Promise$all2[1];\n                nonce = _yield$Promise$all2[2];\n                this.chainId = chainId;\n                this.gasPrice = gasPrice;\n                this.nonce = nonce;\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function fillTransaction() {\n        return _fillTransaction.apply(this, arguments);\n      }\n\n      return fillTransaction;\n    }()\n    /**\r\n     * Checks that member variables that can be defined by the user are defined.\r\n     * If there is an undefined variable, an error occurs.\r\n     *\r\n     * @ignore\r\n     */\n\n  }, {\n    key: \"validateOptionalValues\",\n    value: function validateOptionalValues() {\n      _get(_getPrototypeOf(EthereumAccessList.prototype), \"validateOptionalValues\", this).call(this);\n\n      if (this.gasPrice === undefined) throw new Error(\"gasPrice is undefined. Define gasPrice in transaction or use 'transaction.fillTransaction' to fill values.\");\n      if (this.chainId === undefined) throw new Error(\"chainId is undefined. Define chainId in transaction or use 'transaction.fillTransaction' to fill values.\");\n    }\n    /**\r\n     * Returns a hash string of transaction.\r\n     *\r\n     * @example\r\n     * const result = tx.getTransactionHash()\r\n     *\r\n     * @return {string}\r\n     */\n\n  }, {\n    key: \"getTransactionHash\",\n    value: function getTransactionHash() {\n      var encoded = this.getRLPEncoding();\n      encoded = encoded.replace(TX_TYPE_TAG[this.type], getTypeTagWithoutEthereumTxTypeEnvelopeTag(this.type));\n      return Hash.keccak256(encoded);\n    }\n  }], [{\n    key: \"create\",\n    value:\n    /**\r\n     * Creates a ethereum access list transaction.\r\n     *\r\n     * @example\r\n     * const tx = caver.transaction.ethereumAccessList.create({ from: '0x{}', ... })\r\n     *\r\n     * @method create\r\n     * @param {object|string} createTxObj - The parameters to create a EthereumAccessList transaction. This can be an object defining transaction information, or it can be an RLP-encoded string.\r\n     *                                      If it is an RLP-encoded string, decode it to create a transaction instance.\r\n     *                                      The object can define `from`, `to`, `value`, `input`, `nonce`, `gas`, `gasPrice`, `accessList` and `chainId`.\r\n     * @param {object} [klaytnCall] - An object includes klay rpc calls.\r\n     * @return {EthereumAccessList}\r\n     */\n    function create(createTxObj, klaytnCall) {\n      return new EthereumAccessList(createTxObj, klaytnCall);\n    }\n    /**\r\n     * decodes the RLP-encoded string and returns an EthereumAccessList instance.\r\n     *\r\n     * @example\r\n     * const tx = caver.transaction.ethereumAccessList.decode('0x{rlp encoded data}')\r\n     *\r\n     * @param {string} rlpEncoded The RLP-encoded ethereum access list transaction.\r\n     * @param {object} [klaytnCall] - An object includes klay rpc calls.\r\n     * @return {EthereumAccessList}\r\n     */\n\n  }, {\n    key: \"decode\",\n    value: function decode(rlpEncoded, klaytnCall) {\n      var decoded = _decode(rlpEncoded);\n\n      decoded.accessList = AccessList.decode(decoded.encodedAccessList);\n      return new EthereumAccessList(decoded, klaytnCall);\n    }\n  }]);\n\n  return EthereumAccessList;\n}(AbstractTransaction);\n\nmodule.exports = EthereumAccessList;","map":{"version":3,"names":["_","require","RLP","Bytes","Hash","AbstractTransaction","TX_TYPE_STRING","TX_TYPE_TAG","refineSignatures","getTypeTagWithoutEthereumTxTypeEnvelopeTag","isNot","utils","AccessList","TransactionHasher","_decode","rlpEncoded","addHexPrefix","startsWith","TxTypeEthereumAccessList","Error","typeDettached","replace","decode","chainId","nonce","gasPrice","gas","to","value","input","encodedAccessList","v","r","s","trimLeadingZero","signatures","EthereumAccessList","createTxObj","klaytnCall","isString","from","data","accessList","undefined","_gasPrice","g","numberToHex","_to","address","isAddress","toLowerCase","_value","val","_input","isHex","_accessList","list","create","_signatures","sigs","refined","type","isEmptySig","hexToNumber","sig","Array","isArray","length","validateOptionalValues","encode","fromNat","encodeToBytes","slice","getRLPEncodingForSignature","recovery","toNumber","signingDataHex","hasedSigningData","keccak256","publicKeys","push","recoverPublicKey","makeEven","toHex","key","index","hasher","getHashForSignature","isFunction","_sign","keyring","hash","role","ecsign","appendSignatures","Promise","all","getChainId","suggestGasPrice","getNonce","encoded","getRLPEncoding","decoded","module","exports"],"sources":["C:/Users/User/Documents/clone-starter-kit-08/node_modules/caver-js/packages/caver-transaction/src/transactionTypes/ethereumTypedTransaction/ethereumAccessList.js"],"sourcesContent":["/*\r\n    Copyright 2022 The caver-js Authors\r\n    This file is part of the caver-js library.\r\n\r\n    The caver-js library is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    The caver-js library is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst _ = require('lodash')\r\nconst RLP = require('eth-lib/lib/rlp')\r\nconst Bytes = require('eth-lib/lib/bytes')\r\nconst Hash = require('eth-lib/lib/hash')\r\nconst AbstractTransaction = require('../abstractTransaction')\r\nconst {\r\n    TX_TYPE_STRING,\r\n    TX_TYPE_TAG,\r\n    refineSignatures,\r\n    getTypeTagWithoutEthereumTxTypeEnvelopeTag,\r\n    isNot,\r\n} = require('../../transactionHelper/transactionHelper')\r\nconst utils = require('../../../../caver-utils/src')\r\nconst AccessList = require('../../utils/accessList')\r\nconst TransactionHasher = require('../../transactionHasher/transactionHasher')\r\n\r\nfunction _decode(rlpEncoded) {\r\n    rlpEncoded = utils.addHexPrefix(rlpEncoded)\r\n    if (!rlpEncoded.startsWith(TX_TYPE_TAG.TxTypeEthereumAccessList))\r\n        throw new Error(`Cannot decode to EthereumAccessList. The prefix must be ${TX_TYPE_TAG.TxTypeEthereumAccessList}: ${rlpEncoded}`)\r\n\r\n    const typeDettached = `0x${rlpEncoded.replace(TX_TYPE_TAG.TxTypeEthereumAccessList, '')}`\r\n    const [chainId, nonce, gasPrice, gas, to, value, input, encodedAccessList, v, r, s] = RLP.decode(typeDettached)\r\n    return {\r\n        chainId: utils.trimLeadingZero(chainId),\r\n        nonce: utils.trimLeadingZero(nonce),\r\n        gasPrice: utils.trimLeadingZero(gasPrice),\r\n        gas: utils.trimLeadingZero(gas),\r\n        to,\r\n        value: utils.trimLeadingZero(value),\r\n        input: input,\r\n        encodedAccessList,\r\n        signatures: [v, r, s],\r\n    }\r\n}\r\n/**\r\n * Represents a ethereum access list transaction.\r\n * @class\r\n * @hideconstructor\r\n * @augments AbstractTransaction\r\n */\r\nclass EthereumAccessList extends AbstractTransaction {\r\n    /**\r\n     * Creates a ethereum access list transaction.\r\n     *\r\n     * @example\r\n     * const tx = caver.transaction.ethereumAccessList.create({ from: '0x{}', ... })\r\n     *\r\n     * @method create\r\n     * @param {object|string} createTxObj - The parameters to create a EthereumAccessList transaction. This can be an object defining transaction information, or it can be an RLP-encoded string.\r\n     *                                      If it is an RLP-encoded string, decode it to create a transaction instance.\r\n     *                                      The object can define `from`, `to`, `value`, `input`, `nonce`, `gas`, `gasPrice`, `accessList` and `chainId`.\r\n     * @param {object} [klaytnCall] - An object includes klay rpc calls.\r\n     * @return {EthereumAccessList}\r\n     */\r\n    static create(createTxObj, klaytnCall) {\r\n        return new EthereumAccessList(createTxObj, klaytnCall)\r\n    }\r\n\r\n    /**\r\n     * decodes the RLP-encoded string and returns an EthereumAccessList instance.\r\n     *\r\n     * @example\r\n     * const tx = caver.transaction.ethereumAccessList.decode('0x{rlp encoded data}')\r\n     *\r\n     * @param {string} rlpEncoded The RLP-encoded ethereum access list transaction.\r\n     * @param {object} [klaytnCall] - An object includes klay rpc calls.\r\n     * @return {EthereumAccessList}\r\n     */\r\n    static decode(rlpEncoded, klaytnCall) {\r\n        const decoded = _decode(rlpEncoded)\r\n        decoded.accessList = AccessList.decode(decoded.encodedAccessList)\r\n        return new EthereumAccessList(decoded, klaytnCall)\r\n    }\r\n\r\n    /**\r\n     * Creates a ethereum access list transaction.\r\n     * @constructor\r\n     * @param {object|string} createTxObj - The parameters to create a EthereumAccessList transaction. This can be an object defining transaction information, or it can be an RLP-encoded string.\r\n     *                                      If it is an RLP-encoded string, decode it to create a transaction instance.\r\n     *                                      The object can define `from`, `to`, `value`, `input`, `nonce`, `gas`, `gasPrice`, `accessList` and `chainId`.\r\n     * @param {object} [klaytnCall] - An object includes klay rpc calls.\r\n     */\r\n    constructor(createTxObj, klaytnCall) {\r\n        if (_.isString(createTxObj)) createTxObj = _decode(createTxObj)\r\n\r\n        createTxObj.from = createTxObj.from || '0x0000000000000000000000000000000000000000'\r\n\r\n        super(TX_TYPE_STRING.TxTypeEthereumAccessList, createTxObj, klaytnCall)\r\n        this.to = createTxObj.to || '0x'\r\n\r\n        if (createTxObj.input && createTxObj.data)\r\n            throw new Error(`'input' and 'data' properties cannot be defined at the same time, please use either 'input' or 'data'.`)\r\n        this.input = createTxObj.input || createTxObj.data || '0x'\r\n\r\n        this.value = createTxObj.value || '0x0'\r\n\r\n        this.accessList = createTxObj.accessList || []\r\n\r\n        if (createTxObj.gasPrice !== undefined) this.gasPrice = createTxObj.gasPrice\r\n    }\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    get gasPrice() {\r\n        return this._gasPrice\r\n    }\r\n\r\n    set gasPrice(g) {\r\n        this._gasPrice = utils.numberToHex(g)\r\n    }\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    get to() {\r\n        return this._to\r\n    }\r\n\r\n    set to(address) {\r\n        if (address !== '0x' && !utils.isAddress(address)) throw new Error(`Invalid address ${address}`)\r\n        this._to = address.toLowerCase()\r\n    }\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    get value() {\r\n        return this._value\r\n    }\r\n\r\n    set value(val) {\r\n        this._value = utils.numberToHex(val)\r\n    }\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    get input() {\r\n        return this._input\r\n    }\r\n\r\n    set input(input) {\r\n        if (!input || !utils.isHex(input)) throw new Error(`Invalid input data ${input}`)\r\n        this._input = utils.addHexPrefix(input)\r\n    }\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    get data() {\r\n        return this._input\r\n    }\r\n\r\n    set data(data) {\r\n        this._input = data\r\n    }\r\n\r\n    /**\r\n     * @type {AccessList}\r\n     */\r\n    get accessList() {\r\n        return this._accessList\r\n    }\r\n\r\n    set accessList(list) {\r\n        if (!(list instanceof AccessList)) list = AccessList.create(list)\r\n        this._accessList = list\r\n    }\r\n\r\n    /**\r\n     * @type {SignatureData}\r\n     */\r\n    get signatures() {\r\n        return this._signatures\r\n    }\r\n\r\n    // overrides signatures getter/setter to validate y-parity.\r\n    set signatures(sigs) {\r\n        const refined = refineSignatures(sigs, this.type)\r\n        if (!utils.isEmptySig(refined)) {\r\n            const v = utils.hexToNumber(refined.v)\r\n            if (v !== 0 && v !== 1) {\r\n                throw new Error(`Invalid signature: The y-parity of the transaction should either be 0 or 1.`)\r\n            }\r\n        }\r\n        this._signatures = refined\r\n    }\r\n\r\n    /**\r\n     * Appends signatures array to transaction.\r\n     * EthereumAccessList transaction cannot have more than one signature, so an error will be occured if the transaction already has a signature or the `sig` parameter has more than one signatures.\r\n     *\r\n     * @example\r\n     * tx.appendSignatures([ '0x0fea', '0xade94...', '0x38160...' ])\r\n     *\r\n     * @override\r\n     * @param {SignatureData|Array.<SignatureData>|Array.<string>|Array.<Array.<string>>} signatures - The `signatures` to be appended to the transaction. {@link SignatureData|SignatureData} instance or an array containing {@link SignatureData|SignatureData} instances.\r\n     *                                                                                                 An array in which each 'v', 'r', and 's' are sequentially defined as string formats or a 2D array containing those arrays can also be taken as parameters.\r\n     */\r\n    appendSignatures(sig) {\r\n        if (!utils.isEmptySig(this.signatures))\r\n            throw new Error(\r\n                `signatures already defined. ${this.type} cannot include more than one signature. Please use tx.signatures = sigArr to replace.`\r\n            )\r\n\r\n        if (Array.isArray(sig[0])) {\r\n            if (sig.length > 1) throw new Error(`signatures are too long. ${this.type} cannot include more than one signature.`)\r\n            sig = sig[0]\r\n        }\r\n\r\n        this.signatures = sig\r\n    }\r\n\r\n    /**\r\n     * Returns the RLP-encoded string of this transaction (i.e., rawTransaction).\r\n     * This returns with `TxTypeEthereumAccessList` type prefix('0x7801').\r\n     *\r\n     * @example\r\n     * const result = tx.getRLPEncoding()\r\n     *\r\n     * @return {string} An RLP-encoded transaction string.\r\n     */\r\n    getRLPEncoding() {\r\n        this.validateOptionalValues()\r\n\r\n        // TxTypeEthereumEnvelope(0x78) || 0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, signatureYParity, signatureR, signatureS])\r\n\r\n        const [v, r, s] = this.signatures.encode()\r\n        return (\r\n            TX_TYPE_TAG[this.type] +\r\n            RLP.encode([\r\n                Bytes.fromNat(this.chainId),\r\n                Bytes.fromNat(this.nonce),\r\n                Bytes.fromNat(this.gasPrice),\r\n                Bytes.fromNat(this.gas),\r\n                this.to.toLowerCase(),\r\n                Bytes.fromNat(this.value),\r\n                this.input,\r\n                this.accessList.encodeToBytes(),\r\n                v,\r\n                r,\r\n                s,\r\n            ]).slice(2)\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Returns RLP-encoded string for making signature.\r\n     *\r\n     * @example\r\n     * const result = tx.getRLPEncodingForSignature()\r\n     *\r\n     * @override\r\n     * @return {string}\r\n     */\r\n    getRLPEncodingForSignature() {\r\n        this.validateOptionalValues()\r\n\r\n        // sigRLP = 0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList])\r\n        return (\r\n            getTypeTagWithoutEthereumTxTypeEnvelopeTag(this.type) +\r\n            RLP.encode([\r\n                Bytes.fromNat(this.chainId),\r\n                Bytes.fromNat(this.nonce),\r\n                Bytes.fromNat(this.gasPrice),\r\n                Bytes.fromNat(this.gas),\r\n                this.to.toLowerCase(),\r\n                Bytes.fromNat(this.value),\r\n                this.input,\r\n                this.accessList.encodeToBytes(),\r\n            ]).slice(2)\r\n        )\r\n    }\r\n\r\n    /**\r\n     * EthereumAccessList does not have a common RLP encoding because no other type exists.\r\n     * So getCommonRLPEncodingForSignature calls getRLPEncodingForSignature to return RLP-encoded string.\r\n     *\r\n     * @return {string}\r\n     */\r\n    getCommonRLPEncodingForSignature() {\r\n        return this.getRLPEncodingForSignature()\r\n    }\r\n\r\n    /**\r\n     * Recovers the public key strings from `signatures` field in transaction object.\r\n     * If you want to derive an address from public key, please use {@link module:utils~publicKeyToAddress|caver.utils.publicKeyToAddress}.\r\n     *\r\n     * @example\r\n     * const publicKey = tx.recoverPublicKeys()\r\n     *\r\n     * @return {Array.<string>} An array containing public keys recovered from `signatures`.\r\n     */\r\n    recoverPublicKeys() {\r\n        if (utils.isEmptySig(this.signatures)) throw new Error(`Failed to recover public key from signatures: signatures is empty.`)\r\n\r\n        const recovery = Bytes.toNumber(this.signatures.v)\r\n        const signingDataHex = this.getRLPEncodingForSignature()\r\n        const hasedSigningData = Hash.keccak256(signingDataHex)\r\n\r\n        const publicKeys = []\r\n        publicKeys.push(\r\n            utils.recoverPublicKey(hasedSigningData, [utils.makeEven(utils.toHex(recovery)), this.signatures.r, this.signatures.s], true)\r\n        )\r\n\r\n        return publicKeys\r\n    }\r\n\r\n    /**\r\n     * Signs the transaction as a transaction sender with the private key(s) in the `keyring` and appends `signatures` in the transaction object.\r\n     *\r\n     * If the user has not defined an `index`, `transaction.sign` signs the transaction using \"all the private keys\" used by the role.\r\n     * If `index` is defined, the `transaction.sign` signs the transaction using \"only one private key\" at the given index.\r\n     *\r\n     * @example\r\n     * const keyring = caver.wallet.keyring.create('0x{address in hex}', '0x{private key}')\r\n     * const signedTx = await tx.sign(keyring)\r\n     *\r\n     * const keyring = caver.wallet.keyring.create('0x{address in hex}', ['0x{private key}', '0x{private key}'])\r\n     * const signedTx = await tx.sign(keyring, 1) // sign the transaction with index. If omitted, sign with all private keys.\r\n     *\r\n     * @param {KeyringContainer.Keyring|string} key - A private key string ({@link https://docs.klaytn.com/klaytn/design/accounts#klaytn-wallet-key-format|KlaytnWalletKey} format is also allowed) or an instance of {@link KeyringContainer.Keyring|Keyring}. If a private key string or a KlaytnWalletKey is passed as a parameter, the keyring instance is created internally.\r\n     * @param {number} [index] - The index of the private key you want to use. The index must be less than the length of the array of the private keys defined for each role. If an index is not defined, this method will use all the private keys.\r\n     * @param {function} [hasher] - The hash function to get the hash of the transaction.\r\n     * @return {module:Transaction.Transaction} An instance of signed Transaction. The `signature` is appended to the `transaction.signatures`.\r\n     */\r\n    async sign(key, index, hasher = TransactionHasher.getHashForSignature) {\r\n        // User parameter input cases\r\n        // (key) / (key index) / (key hasher) / (key index hasher)\r\n        if (_.isFunction(index)) {\r\n            hasher = index\r\n            index = undefined\r\n        }\r\n\r\n        const { keyring, hash, role } = await this._sign(key, hasher)\r\n\r\n        const sig = keyring.ecsign(hash, role, index)\r\n\r\n        this.appendSignatures(sig)\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Fills in the optional variables in transaction.\r\n     *\r\n     * If the `gasPrice`, `nonce`, or `chainId` of the transaction are not defined, this method asks the default values for these optional variables and preset them by sending JSON RPC call to the connected Klaytn Node.\r\n     * Use {@link Klay#getGasPrice|caver.rpc.klay.getGasPrice} to get gasPrice, {@link Klay#getTransactionCount|caver.rpc.klay.getTransactionCount} to get nonce and {@link Klay#getChainId|caver.rpc.klay.getChainId} call to get chainId.\r\n     *\r\n     * @example\r\n     * await tx.fillTransaction()\r\n     */\r\n    async fillTransaction() {\r\n        const [chainId, gasPrice, nonce] = await Promise.all([\r\n            isNot(this.chainId) ? this.getChainId() : this.chainId,\r\n            isNot(this.gasPrice) ? this.suggestGasPrice() : this.gasPrice,\r\n            isNot(this.nonce) ? this.getNonce(this.from) : this.nonce,\r\n        ])\r\n\r\n        this.chainId = chainId\r\n        this.gasPrice = gasPrice\r\n        this.nonce = nonce\r\n    }\r\n\r\n    /**\r\n     * Checks that member variables that can be defined by the user are defined.\r\n     * If there is an undefined variable, an error occurs.\r\n     *\r\n     * @ignore\r\n     */\r\n    validateOptionalValues() {\r\n        super.validateOptionalValues()\r\n        if (this.gasPrice === undefined)\r\n            throw new Error(`gasPrice is undefined. Define gasPrice in transaction or use 'transaction.fillTransaction' to fill values.`)\r\n        if (this.chainId === undefined)\r\n            throw new Error(`chainId is undefined. Define chainId in transaction or use 'transaction.fillTransaction' to fill values.`)\r\n    }\r\n\r\n    /**\r\n     * Returns a hash string of transaction.\r\n     *\r\n     * @example\r\n     * const result = tx.getTransactionHash()\r\n     *\r\n     * @return {string}\r\n     */\r\n    getTransactionHash() {\r\n        let encoded = this.getRLPEncoding()\r\n        encoded = encoded.replace(TX_TYPE_TAG[this.type], getTypeTagWithoutEthereumTxTypeEnvelopeTag(this.type))\r\n        return Hash.keccak256(encoded)\r\n    }\r\n}\r\n\r\nmodule.exports = EthereumAccessList\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}