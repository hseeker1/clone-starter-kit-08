{"ast":null,"code":"/*\r\n Modifications copyright 2018 The caver-js Authors\r\n This file is part of web3.js.\r\n\r\n web3.js is free software: you can redistribute it and/or modify\r\n it under the terms of the GNU Lesser General Public License as published by\r\n the Free Software Foundation, either version 3 of the License, or\r\n (at your option) any later version.\r\n\r\n web3.js is distributed in the hope that it will be useful,\r\n but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n GNU Lesser General Public License for more details.\r\n\r\n You should have received a copy of the GNU Lesser General Public License\r\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n This file is derived from web3.js/packages/web3-utils/src/utils.js (2019/06/12).\r\n Modified and improved for the caver-js development.\r\n */\n\n/**\r\n * @file utils.js\r\n * @author Fabian Vogelsteller <fabian@ethereum.org>\r\n * @date 2017\r\n */\nconst _ = require('lodash');\n\nconst BN = require('bn.js');\n\nconst BigNumber = require('bignumber.js');\n\nconst numberToBN = require('number-to-bn');\n\nconst utf8 = require('utf8');\n\nconst Hash = require('eth-lib/lib/hash');\n\nconst RLP = require('eth-lib/lib/rlp');\n\nconst Account = require('eth-lib/lib/account');\n\nconst elliptic = require('elliptic');\n\nconst secp256k1 = new elliptic.ec('secp256k1');\nconst txTypeToString = {\n  '0x20': 'ACCOUNT_UPDATE',\n  '0x21': 'FEE_DELEGATED_ACCOUNT_UPDATE',\n  '0x22': 'FEE_DELEGATED_ACCOUNT_UPDATE_WITH_RATIO',\n  '0x08': 'VALUE_TRANSFER',\n  '0x10': 'VALUE_TRANSFER_MEMO',\n  '0x09': 'FEE_DELEGATED_VALUE_TRANSFER',\n  '0x0a': 'FEE_DELEGATED_VALUE_TRANSFER_WITH_RATIO',\n  '0x11': 'FEE_DELEGATED_VALUE_TRANSFER_MEMO',\n  '0x12': 'FEE_DELEGATED_VALUE_TRANSFER_MEMO_WITH_RATIO',\n  '0x28': 'SMART_CONTRACT_DEPLOY',\n  '0x29': 'FEE_DELEGATED_SMART_CONTRACT_DEPLOY',\n  '0x2a': 'FEE_DELEGATED_SMART_CONTRACT_DEPLOY_WITH_RATIO',\n  '0x30': 'SMART_CONTRACT_EXECUTION',\n  '0x31': 'FEE_DELEGATED_SMART_CONTRACT_EXECUTION',\n  '0x32': 'FEE_DELEGATED_SMART_CONTRACT_EXECUTION_WITH_RATIO',\n  '0x38': 'CANCEL',\n  '0x39': 'FEE_DELEGATED_CANCEL',\n  '0x3a': 'FEE_DELEGATED_CANCEL_WITH_RATIO',\n  '0x48': 'CHAIN_DATA_ANCHORING'\n};\nconst HASH_LENGTH = 66;\n/**\r\n * Returns `true` if parameter is a BN instance, otherwise `false`.\r\n *\r\n * @example\r\n * const bn = new caver.utils.BN(10)\r\n * const result = caver.utils.isBN(bn)\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {*} bn\r\n * @return {boolean} `true` if a given value is a `BN.js` instance.\r\n */\n\nconst isBN = function (bn) {\n  return BN.isBN(bn);\n};\n/**\r\n * Returns `true` if object is a BigNumber instance, otherwise `false`.\r\n *\r\n * @example\r\n * const bigNumber = new caver.utils.BigNumber(10)\r\n * const result = caver.utils.isBigNumber(bigNumber)\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {*} bigNumber\r\n * @return {boolean} `true` if a given value is a `Bignumber.js` instance.\r\n */\n\n\nconst isBigNumber = function (bigNumber) {\n  return BigNumber.isBigNumber(bigNumber);\n};\n/**\r\n * Safely converts any given value (including `Bignumber.js` instances) into a `BN.js` instance, for handling big numbers in JavaScript.\r\n *\r\n * @example\r\n * const result = caver.utils.toBN(num)\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {number|string|BN|BigNumber} number The number to convert to a BN.js instance.\r\n * @return {BN} The {@link https://github.com/indutny/bn.js/|BN.js} instance.\r\n */\n\n\nfunction toBN(number) {\n  try {\n    return numberToBN.apply(null, arguments);\n  } catch (e) {\n    throw new Error(`${e} Given value: \"${number}\"`);\n  }\n}\n/**\r\n * Converts a negative number into a two's complement.\r\n *\r\n * @example\r\n * const result = caver.utils.toTwosComplement(num)\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {number|string|BN|BigNumber} number The number to convert.\r\n * @return {string} The converted hex string.\r\n */\n\n\nconst toTwosComplement = function (number) {\n  return `0x${toBN(number).toTwos(256).toString(16, 64)}`;\n};\n/**\r\n * Checks if a given string is a valid Klaytn address.\r\n * It will also check the checksum if the address has upper and lowercase letters.\r\n *\r\n * @example\r\n * const result = caver.utils.isAddress('0x{address in hex}')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} address An address string.\r\n * @return {boolean} `true` if a given string is a valid Klaytn address.\r\n */\n\n\nconst isAddress = function (address) {\n  // check if it has the basic requirements of an address\n  if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {\n    return false; // If it's ALL lowercase or ALL upppercase\n  }\n\n  if (/^(0x|0X)?[0-9a-f]{40}$/.test(address) || /^(0x|0X)?[0-9A-F]{40}$/.test(address)) {\n    return true; // Otherwise check each case\n  }\n\n  return checkAddressChecksum(address);\n};\n/**\r\n * Checks the checksum of a given address.\r\n * Will also return `false` on non-checksum addresses.\r\n *\r\n * @example\r\n * const result = caver.utils.checkAddressChecksum('0x{address in hex}')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} address An address string.\r\n * @return {boolean}\r\n */\n\n\nconst checkAddressChecksum = function (address) {\n  // Check each case\n  address = address.replace(/^0x/i, '');\n  const addressHash = sha3(address.toLowerCase()).replace(/^0x/i, '');\n\n  for (let i = 0; i < 40; i++) {\n    // the nth letter should be uppercase if the nth digit of casemap is 1\n    if (parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i] || parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\r\n * Adds padding on the left of a string. Useful for adding paddings to HEX strings.\r\n *\r\n * @example\r\n * const result = caver.utils.padLeft('0x3456ff', 20) // '0x000000000000003456ff'\r\n * const result = caver.utils.padLeft('Hello', 20, 'x') // 'xxxxxxxxxxxxxxxHello'\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n * @alias padLeft\r\n *\r\n * @param {string} string The string to add padding on the left.\r\n * @param {number} chars The number of characters the total string should have.\r\n * @param {string} [sign] The character sign to use, defaults to `0`.\r\n * @returns {string} The padded string.\r\n */\n\n\nconst leftPad = function (string, chars, sign) {\n  const hasPrefix = /^0x/i.test(string) || typeof string === 'number';\n  string = string.toString(16).replace(/^0x/i, '');\n  const padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0;\n  return (hasPrefix ? '0x' : '') + new Array(padding).join(sign || '0') + string;\n};\n/**\r\n * Adds padding on the right of a string, Useful for adding paddings to HEX strings.\r\n *\r\n * @example\r\n * const result = caver.utils.rightPad('0x3456ff', 20) // '0x3456ff00000000000000'\r\n * const result = caver.utils.rightPad('Hello', 20, 'x') // 'Helloxxxxxxxxxxxxxxx'\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n * @alias padRight\r\n *\r\n * @param {string} string The string to add padding on the right.\r\n * @param {number} chars The number of characters the total string should have.\r\n * @param {string} [sign] The character sign to use, defaults to `0`.\r\n * @returns {string} The padded string.\r\n */\n\n\nconst rightPad = function (string, chars, sign) {\n  const hasPrefix = /^0x/i.test(string) || typeof string === 'number';\n  string = string.toString(16).replace(/^0x/i, '');\n  const padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0;\n  return (hasPrefix ? '0x' : '') + string + new Array(padding).join(sign || '0');\n};\n/**\r\n * Returns the HEX representation of a given UTF-8 string.\r\n *\r\n * @example\r\n * const result = caver.utils.utf8ToHex('I have 100€') // '0x49206861766520313030e282ac'\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} str A UTF-8 string to convert to a HEX string.\r\n * @returns {string} The HEX string.\r\n */\n\n\nconst utf8ToHex = function (str) {\n  str = utf8.encode(str);\n  let hex = ''; // remove \\u0000 padding from either side\n\n  str = str.replace(/^(?:\\u0000)*/, '');\n  str = str.split('').reverse().join('');\n  str = str.replace(/^(?:\\u0000)*/, '');\n  str = str.split('').reverse().join('');\n\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i); // if (code !== 0) {\n\n    const n = code.toString(16);\n    hex += n.length < 2 ? `0${n}` : n; // }\n  }\n\n  return `0x${hex}`;\n};\n/**\r\n * Returns the UTF-8 string representation of a given HEX value.\r\n *\r\n * @example\r\n * const result = caver.utils.hexToUtf8('0x49206861766520313030e282ac') // 'I have 100€'\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} hex A HEX string to convert to a UTF-8 string.\r\n * @returns {string} The UTF-8 string.\r\n */\n\n\nconst hexToUtf8 = function (hex) {\n  if (!isHexStrict(hex)) {\n    throw new Error(`The parameter \"${hex}\" must be a valid HEX string.`);\n  }\n\n  let str = '';\n  let code = 0;\n  hex = hex.replace(/^0x/i, ''); // remove 00 padding from either side\n\n  hex = hex.replace(/^(?:00)*/, '');\n  hex = hex.split('').reverse().join('');\n  hex = hex.replace(/^(?:00)*/, '');\n  hex = hex.split('').reverse().join('');\n  const l = hex.length;\n\n  for (let i = 0; i < l; i += 2) {\n    code = parseInt(hex.substr(i, 2), 16); // if (code !== 0) {\n\n    str += String.fromCharCode(code); // }\n  }\n\n  return utf8.decode(str);\n};\n/**\r\n * Returns the number representation of a given HEX value.\r\n * Please note that this function is not useful for big numbers, rather use `caver.utils.toBN`.\r\n *\r\n * @example\r\n * const result = caver.utils.hexToNumber('0xea') // 234\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} A HEX string to be converted.\r\n * @return {number} The number representation of a given HEX value.\r\n */\n\n\nconst hexToNumber = function (value) {\n  if (!value) return value;\n\n  if (typeof value === 'string' && !isHexStrict(value)) {\n    throw new Error(`Given value \"${value}\" is not a valid hex string.`);\n  }\n\n  return toBN(value).toNumber();\n};\n/**\r\n * Returns the number representation of a given HEX value as a string.\r\n *\r\n * @example\r\n * const result = caver.utils.hexToNumberString('0xea') // '234'\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} A HEX string to be converted.\r\n * @return {string} The number as a string.\r\n */\n\n\nconst hexToNumberString = function (value) {\n  if (!value) return value;\n\n  if (_.isString(value) && !isHexStrict(value)) {\n    throw new Error(`Given value \"${value}\" is not a valid hex string.`);\n  }\n\n  return toBN(value).toString(10);\n};\n/**\r\n * Returns the HEX representation of a given number value.\r\n *\r\n * @example\r\n * const result = caver.utils.numberToHex(234) // '0xea'\r\n * const result = caver.utils.numberToHex('234')\r\n * const result = caver.utils.numberToHex(new caver.utils.BN(234))\r\n * const result = caver.utils.numberToHex(new caver.utils.BigNumber(234))\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string|number|BN|BigNumber} value A number as string or number.\r\n * @return {string} The HEX value of the given number.\r\n */\n\n\nconst numberToHex = function (value) {\n  if (_.isNumber(value)) {\n    const bn = toBN(value);\n\n    try {\n      bn.toNumber();\n    } catch (e) {\n      throw new Error(`${e.message}: Number type cannot handle big number. Please use hex string or BigNumber/BN.`);\n    }\n  }\n\n  if (_.isNull(value) || _.isUndefined(value)) {\n    return value;\n  }\n\n  if (!isFinite(value) && !isHexStrict(value)) {\n    throw new Error(`Given input \"${value}\" is not a number.`);\n  }\n\n  const number = toBN(value);\n  const result = number.toString(16);\n  return number.lt(new BN(0)) ? `-0x${result.substr(1)}` : `0x${result}`;\n};\n/**\r\n * Returns a HEX string from a byte array.\r\n *\r\n * @example\r\n * const result = caver.utils.bytesToHex([ 72, 101, 108, 108, 111, 33, 36 ]) // '0x48656c6c6f2124'\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {Array} bytes A byte array to convert.\r\n * @return {string} The HEX string.\r\n */\n\n\nconst bytesToHex = function (bytes) {\n  const hex = [];\n\n  for (let i = 0; i < bytes.length; i++) {\n    // eslint-disable-next-line no-bitwise\n    hex.push((bytes[i] >>> 4).toString(16)); // eslint-disable-next-line no-bitwise\n\n    hex.push((bytes[i] & 0xf).toString(16));\n  }\n\n  return `0x${hex.join('')}`;\n};\n/**\r\n * Returns a byte array from the given HEX string.\r\n *\r\n * @example\r\n * const result = caver.utils.hexToBytes('0x000000ea') // [ 0, 0, 0, 234 ]\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} hex A HEX string to be converted.\r\n * @return {Array.<number>} The byte array.\r\n */\n\n\nconst hexToBytes = function (hex) {\n  hex = hex.toString(16);\n\n  if (!isHexStrict(hex)) {\n    throw new Error(`Given value \"${hex}\" is not a valid hex string.`);\n  }\n\n  hex = hex.replace(/^0x/i, '');\n  const bytes = [];\n\n  for (let c = 0; c < hex.length; c += 2) {\n    bytes.push(parseInt(hex.substr(c, 2), 16));\n  }\n\n  return bytes;\n};\n/**\r\n * Converts any given value to HEX.\r\n * The numeric strings will be interpreted as numbers.\r\n * Text strings will be interpreted as UTF-8 strings.\r\n *\r\n * @example\r\n * const result = caver.utils.toHex('234') // '0xea'\r\n * const result = caver.utils.toHex(234) // '0xea'\r\n * const result = caver.utils.toHex(new caver.utils.BN('234')) // '0xea'\r\n * const result = caver.utils.toHex(new caver.utils.Bignumber('234')) // '0xea'\r\n * const result = caver.utils.toHex('I have 100€') // '0x49206861766520313030e282ac'\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string|number|BN|BigNumber|Buffer} value The input to convert to HEX.\r\n * @return {string} The resulting HEX string.\r\n */\n\n/* eslint-disable complexity */\n\n\nconst toHex = function (value, returnType) {\n  if (Buffer.isBuffer(value)) {\n    return returnType ? 'buffer' : bufferToHex(value);\n  }\n\n  if (isAddress(value)) {\n    return returnType ? 'address' : `0x${value.toLowerCase().replace(/^0x/i, '')}`;\n  }\n\n  if (_.isBoolean(value)) {\n    return returnType ? 'bool' : value ? '0x01' : '0x00';\n  }\n\n  if (_.isObject(value) && !isBigNumber(value) && !isBN(value)) {\n    return returnType ? 'string' : utf8ToHex(JSON.stringify(value));\n  } // if its a negative number, pass it through numberToHex\n\n\n  if (_.isString(value)) {\n    if (value.indexOf('-0x') === 0 || value.indexOf('-0X') === 0) {\n      return returnType ? 'int256' : numberToHex(value);\n    }\n\n    if (value.indexOf('0x') === 0 || value.indexOf('0X') === 0) {\n      return returnType ? 'bytes' : value;\n    }\n\n    if (!isFinite(value)) {\n      return returnType ? 'string' : utf8ToHex(value);\n    }\n  }\n\n  return returnType ? value < 0 ? 'int256' : 'uint256' : numberToHex(value);\n};\n/* eslint-enable complexity */\n\n/**\r\n * Converts buffer to 0x-prefixed hex string.\r\n *\r\n * @example\r\n * const result = caver.utils.bufferToHex(Buffer.from('5b9ac8', 'hex')) // '0x5b9ac8'\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {Buffer} buf A buffer to convert to hex string.\r\n * @return {string} The 0x-prefixed hex string.\r\n */\n\n\nconst bufferToHex = function (buf) {\n  buf = toBuffer(buf);\n  return `0x${buf.toString('hex')}`;\n};\n/**\r\n * This function converts the input to a Buffer.\r\n * To convert an object into a Buffer using `caver.utils.toBuffer`, the object must implement `toArray` function.\r\n * For string type input, this function only works with a 0x-prefixed hex string.\r\n *\r\n * @example\r\n * const result = caver.utils.toBuffer(Buffer.alloc(0))\r\n * const result = caver.utils.toBuffer('0x1234')\r\n * const result = caver.utils.toBuffer(1)\r\n * const result = caver.utils.toBuffer([1,2,3])\r\n * const result = caver.utils.toBuffer(new caver.utils.BN(255))\r\n * const result = caver.utils.toBuffer(new caver.utils.BigNumber(255))\r\n * const result = caver.utils.toBuffer({toArray: function() {return [1,2,3,4]}}) // An object that implements `toArray` function\r\n * const result = caver.utils.toBuffer(null)\r\n * const result = caver.utils.toBuffer(undefined)\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {Buffer|Array.<number>|string|number|BN|BigNumber|object} input The value to be converted to a Buffer.\r\n * @return {Buffer} The value converted to Buffer type is returned.\r\n */\n\n\nconst toBuffer = function (input) {\n  if (Buffer.isBuffer(input)) return input;\n  if (input === null || input === undefined) return Buffer.alloc(0);\n  if (Array.isArray(input)) return Buffer.from(input);\n  if (isBigNumber(input)) input = toBN(input);\n  if (isBN(input)) return input.toArrayLike(Buffer);\n\n  if (_.isObject(input)) {\n    if (input.toArray && _.isFunction(input.toArray)) return Buffer.from(input.toArray());\n    throw new Error('To convert an object to a buffer, the toArray function must be implemented inside the object');\n  }\n\n  switch (typeof input) {\n    case 'string':\n      if (isHexStrict(input)) return Buffer.from(makeEven(input).replace('0x', ''), 'hex');\n      throw new Error(\"Failed to convert string to Buffer. 'toBuffer' function only supports 0x-prefixed hex string\");\n\n    case 'number':\n      return numberToBuffer(input);\n  }\n\n  throw new Error(`Not supported type with ${input}`);\n};\n/**\r\n * This function converts a number to a Buffer.\r\n * The {@link module:utils~toBuffer|caver.utils.toBuffer} has the same behavior as this function when the input is a number.\r\n *\r\n * @example\r\n * const result = caver.utils.numberToBuffer(1)\r\n * const result = caver.utils.numberToBuffer('2')\r\n * const result = caver.utils.numberToBuffer('0x3')\r\n * const result = caver.utils.numberToBuffer(new caver.utils.BN(4))\r\n * const result = caver.utils.numberToBuffer(new caver.utils.BigNumber(4))\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {number|string|BN|BigNumber} num A number to be converted to a Buffer.\r\n * @return {Buffer}\r\n */\n\n\nconst numberToBuffer = function (num) {\n  return Buffer.from(makeEven(numberToHex(num)).replace('0x', ''), 'hex');\n};\n/**\r\n * Checks if a given string is a HEX string.\r\n * Difference to {@link module:utils~isHex|caver.utils.isHex} is that it expects HEX to be prefixed with `0x`.\r\n *\r\n * @example\r\n * const result = caver.utils.isHexStrict('0xc1912') // true\r\n * const result = caver.utils.isHexStrict('c1912') // false\r\n * const result = caver.utils.isHexStrict('Hello') // false\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} hex The given HEX string.\r\n * @returns {boolean} `true` if a given string is a HEX string.\r\n */\n\n\nconst isHexStrict = function (hex) {\n  return (_.isString(hex) || _.isNumber(hex)) && /^(-)?0x[0-9a-f]*$/i.test(hex);\n};\n/**\r\n * Checks if a given string is a HEX string.\r\n *\r\n * @example\r\n * const result = caver.utils.isHex('0xc1912') // true\r\n * const result = caver.utils.isHex('c1912') // true\r\n * const result = caver.utils.isHex('Hello') // false\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} hex The given HEX string.\r\n * @returns {boolean} `true` if a given parameter is a HEX string.\r\n */\n\n\nconst isHex = function (hex) {\n  return (_.isString(hex) || _.isNumber(hex)) && /^(-0x|0x)?[0-9a-f]*$/i.test(hex);\n};\n/**\r\n * Checks if the given string is a hexadecimal transaction hash with or without prefix 0x\r\n * @deprecated since version v1.5.0\r\n * @ignore\r\n * @method isTxHash\r\n * @param {String} txHash given hexadecimal transaction hash\r\n * @return {Boolean}\r\n */\n\n\nconst isTxHash = txHash => isValidHash(txHash);\n/**\r\n * Returns `true` if the input is in 32-bytes hash format, otherwise it returns `false`.\r\n *\r\n * @example\r\n * const result = caver.utils.isValidHash('0xe9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550') // true\r\n * const result = caver.utils.isValidHash('e9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550') // true\r\n * const result = caver.utils.isValidHash('0x1') // false\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} hash The value to be examined that if it is in 32-bytes hash format or not.\r\n * @return {boolean} `true` means the input is in the format of 32-bytes hash.\r\n */\n\n\nconst isValidHash = hash => new RegExp(`^(0x|0X)?[0-9a-fA-F]{${HASH_LENGTH - 2}}$`).test(hash);\n/**\r\n * Checks if the given string is a hexadecimal transaction hash that starts with 0x\r\n * @deprecated since version v1.5.0\r\n * @ignore\r\n * @method isTxHashStrict\r\n * @param {String} txHash given hexadecimal transaction hash\r\n * @return {Boolean}\r\n */\n\n\nconst isTxHashStrict = txHash => isValidHashStrict(txHash);\n/**\r\n * Returns `true` if the input is in 0x-prefixed 32-bytes hash format, otherwise it returns `false`.\r\n * This function only looks at the input and determines if it is in the format of 0x-prefixed 32-bytes hash.\r\n * Difference to {@link module:utils~isValidHash|caver.utils.isValidHash} is that it expects HEX to be prefixed with 0x.\r\n *\r\n * @example\r\n * const result = caver.utils.isValidHashStrict('0xe9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550') // true\r\n * const result = caver.utils.isValidHashStrict('e9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550') // false\r\n * const result = caver.utils.isValidHashStrict('0x1') // false\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} hash The value to be examined that if it is in the format of 0x-prefixed 32-bytes hash or not.\r\n * @return {boolean} `true` means the input is in the format of 0x-prefixed 32-bytes hash.\r\n */\n\n\nconst isValidHashStrict = hash => new RegExp(`^(0x|0X)[0-9a-fA-F]{${HASH_LENGTH - 2}}$`).test(hash);\n/**\r\n * Returns `true` if the bloom is a valid bloom.\r\n *\r\n * @example\r\n * const result = caver.utils.isBloom('0x00000...')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} bloom An encoded bloom filter.\r\n * @return {boolean} `true` means the input bloom parameter is valid.\r\n */\n\n\nconst isBloom = function (bloom) {\n  if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {\n    return false;\n  }\n\n  if (/^(0x)?[0-9a-f]{512}$/.test(bloom) || /^(0x)?[0-9A-F]{512}$/.test(bloom)) {\n    return true;\n  }\n\n  return false;\n};\n/**\r\n * Returns `true` if the topic is valid.\r\n *\r\n * @example\r\n * const result = caver.utils.isBloom('0x00000...')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} hex An encoded topic.\r\n * @return {boolean}\r\n */\n\n\nconst isTopic = function (topic) {\n  if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {\n    return false;\n  }\n\n  if (/^(0x)?[0-9a-f]{64}$/.test(topic) || /^(0x)?[0-9A-F]{64}$/.test(topic)) {\n    return true;\n  }\n\n  return false;\n};\n\nconst parsePredefinedBlockNumber = blockNumber => {\n  switch (blockNumber) {\n    case 'genesis':\n    case 'earliest':\n      return '0x0';\n\n    default:\n      return blockNumber;\n  }\n};\n/**\r\n * Returns `true` if the parameter is predefined block tag.\r\n *\r\n * @example\r\n * const result = caver.utils.isPredefinedBlockNumber('latest') // true\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} predefinedBlock The predefined block.\r\n * @return {boolean} `true` means predefinedBlock is valid predefined block tag.\r\n */\n\n\nconst isPredefinedBlockNumber = function (predefinedBlock) {\n  return predefinedBlock === 'latest' || predefinedBlock === 'pending' || predefinedBlock === 'earliest' || predefinedBlock === 'genesis';\n};\n/**\r\n * Validtes block number (or block tag string).\r\n *\r\n * The block number should be one of a type below:\r\n * 1) predefined block number ex:) 'latest', 'earliest', 'pending', 'genesis'\r\n * 2) hex\r\n * 3) finite number\r\n *\r\n * @example\r\n * const result = caver.utils.isValidBlockNumberCandidate('latest') // true\r\n * const result = caver.utils.isValidBlockNumberCandidate('0x1') // true\r\n * const result = caver.utils.isValidBlockNumberCandidate('1') // true\r\n * const result = caver.utils.isValidBlockNumberCandidate(1) // true\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param  {string|number} blockNumber The block number to validate. This can be block number in number type or block tag(`latest`, `pending`, `earliest`, `genesis`) string.\r\n * @return {boolean} `true` means blockNumber is valid.\r\n */\n\n\nconst isValidBlockNumberCandidate = blockNumber => {\n  return isPredefinedBlockNumber(blockNumber) || isHexStrict(blockNumber) || Number.isFinite(Number(blockNumber));\n};\n/**\r\n * Hashes values to a sha3 hash using keccak 256\r\n *\r\n * To hash a HEX string the hex must have 0x in front.\r\n *\r\n * @return {String} the sha3 string\r\n */\n\n\nconst SHA3_NULL_S = '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\n/**\r\n * Calculates the sha3 of the input.\r\n *\r\n * @example\r\n * const hash = caver.utils.sha3('234')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} str - A string to hash.\r\n * @return {string} The result hash.\r\n */\n\nconst sha3 = function (value) {\n  // return null when value is not string type.\n  if (typeof value === 'number') return null;\n\n  if (isHexStrict(value) && /^0x/i.test(value.toString())) {\n    value = hexToBytes(value);\n  }\n\n  if (isBN(value)) {\n    value = value.toString(10);\n  }\n\n  const returnValue = Hash.keccak256(value);\n\n  if (returnValue === SHA3_NULL_S) {\n    return null;\n  }\n\n  return returnValue;\n}; // expose the under the hood keccak256\n\n\nsha3._Hash = Hash;\n/**\r\n * An object defines the AccountKeyLegacy.\r\n *\r\n * @example\r\n * { privateKey: '0x{private key}', address: '0x{address in hex}', type: '0x00' }\r\n *\r\n * @typedef {object} module:utils.ParsedPrivateKey\r\n * @property {string} privateKey - The private key string.\r\n * @property {string} address - The address string.\r\n * @property {string} type - The type string. Currently only `0x00` is supported.\r\n */\n\n/**\r\n * Parses private key string to { privateKey, address, type }.\r\n *\r\n * @example\r\n * const { privateKey, address, type } = caver.utils.parsePrivateKey('0x45a915e4d060149eb4365960e6a7a45f334393093061116b197e3240065ff2d8')\r\n * const { privateKey, address, type } = caver.utils.parsePrivateKey('0x45a915e4d060149eb4365960e6a7a45f334393093061116b197e3240065ff2d80x000xa94f5374fce5edbc8e2a8697c15331677e6ebf0b')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} privateKey - A private key or KlaytnWalletKey string to parse.\r\n * @return {module:utils.ParsedPrivateKey} A parsed private key object.\r\n */\n\nfunction parsePrivateKey(privateKey) {\n  if (typeof privateKey !== 'string') throw new Error('The private key must be of type string');\n  const has0xPrefix = privateKey.slice(0, 2) === '0x';\n  privateKey = has0xPrefix ? privateKey.slice(2) : privateKey;\n\n  if (privateKey.length !== 110 && privateKey.length !== 64) {\n    throw new Error(`Invalid private key(${privateKey})`);\n  }\n\n  const parsedPrivateKey = privateKey.slice(0, 64);\n\n  if (!isHex(parsedPrivateKey)) {\n    throw new Error('Invalid private key format : privateKey must be in hex format.');\n  }\n\n  if (privateKey.length !== 110) {\n    return {\n      privateKey: `0x${privateKey}`,\n      address: '',\n      type: ''\n    };\n  }\n\n  const type = privateKey.slice(66, 68);\n  if (type !== '00') throw new Error('Invalid type: Currently only type `0x00` is supported.');\n  if (!isKlaytnWalletKey(privateKey)) throw new Error(`Invalid KlaytnWalletKey format.`);\n  const parsedAddress = privateKey.slice(68);\n  return {\n    privateKey: `0x${parsedPrivateKey}`,\n    address: parsedAddress,\n    type: `0x${type}`\n  };\n}\n/**\r\n * Parses KlatynWalletKey to [ '0x{privateKey}', '0x{type}', '0x{address}' ].\r\n *\r\n * @example\r\n * const parsed = caver.utils.parseKlaytnWalletKey('0x45a915e4d060149eb4365960e6a7a45f334393093061116b197e3240065ff2d80x000xa94f5374fce5edbc8e2a8697c15331677e6ebf0b')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} key - A KlaytnWalletKey string to parse.\r\n * @return {Array.<string>} An array that includes parsed KlaytnWalletKey.\r\n */\n\n\nfunction parseKlaytnWalletKey(key) {\n  if (!isKlaytnWalletKey(key)) throw new Error(`Invalid KlaytnWalletKey format: ${key}`);\n  const klaytnWalletKey = key.startsWith('0x') ? key.slice(2) : key;\n  const splitted = klaytnWalletKey.split('0x');\n  return [`0x${splitted[0]}`, `0x${splitted[1]}`, `0x${splitted[2]}`];\n}\n/**\r\n * Validate a KlaytnWalletKey string.\r\n *\r\n * @example\r\n * const result = caver.utils.isKlaytnWalletKey('0x45a915e4d060149eb4365960e6a7a45f334393093061116b197e3240065ff2d80x000xa94f5374fce5edbc8e2a8697c15331677e6ebf0b')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} privateKey - A KlaytnWalletKey string to validate.\r\n * @return {boolean} `true` means valid KlaytnWalletKey.\r\n */\n\n\nconst isKlaytnWalletKey = privateKey => {\n  if (!_.isString(privateKey)) return false;\n  const has0xPrefix = privateKey.slice(0, 2) === '0x';\n  privateKey = has0xPrefix ? privateKey.slice(2) : privateKey;\n\n  if (privateKey.length !== 110) {\n    return false;\n  }\n\n  const splited = privateKey.split('0x');\n  if (splited.length !== 3) return false;\n\n  for (let i = 0; i < splited.length; i++) {\n    if (!isHex(splited[i])) return false;\n\n    switch (i) {\n      case 0:\n        if (splited[i].length !== 64 || !isValidPrivateKey(splited[i])) return false;\n        break;\n\n      case 1:\n        if (splited[i].length !== 2 || splited[i] !== '00') return false;\n        break;\n\n      case 2:\n        if (splited[i].length !== 40 || !isAddress(splited[i])) return false;\n        break;\n    }\n  }\n\n  return true;\n};\n/**\r\n * Validate a private key string.\r\n *\r\n * @example\r\n * const result = caver.utils.isValidPrivateKey('0x45a915e4d060149eb4365960e6a7a45f334393093061116b197e3240065ff2d8')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} privateKey - A private key string to validate.\r\n * @return {boolean} `true` means valid private key.\r\n */\n\n\nfunction isValidPrivateKey(privateKey) {\n  if (typeof privateKey !== 'string') return false;\n  const has0xPrefix = privateKey.slice(0, 2) === '0x';\n  privateKey = has0xPrefix ? privateKey.slice(2) : privateKey; // Private key validation 1: private key should be string and minimum length of it is 64.\n\n  if (privateKey.length !== 64 || !isHex(privateKey)) return false; // order n value in secp256k1. privateKey should be less than order n value.\n\n  const VALID_PRIVATE_KEY_LIMIT = 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141';\n  const VALID_PRIVATE_LOWER_BOUND = '0000000000000000000000000000000000000000000000000000000000000000';\n  return VALID_PRIVATE_LOWER_BOUND < privateKey.toUpperCase() && privateKey.toUpperCase() < VALID_PRIVATE_KEY_LIMIT;\n} // Check is 1)Number string or 2)Hex string or 3)Number.\n\n\nfunction isValidNSHSN(value) {\n  switch (typeof value) {\n    case 'number':\n      if (value < 0) {\n        return false;\n      }\n\n      break;\n\n    case 'string':\n      if (Number(value) != value && !isHexStrict(value)) {\n        return false;\n      }\n\n      break;\n\n    default:\n      return false;\n  }\n\n  return true;\n}\n\nconst rlpEncode = data => RLP.encode(data);\n\nconst rlpDecode = encodedData => RLP.decode(encodedData);\n/**\r\n * Converts from public key to x, y points.\r\n *\r\n * @example\r\n * const result = caver.utils.xyPointFromPublicKey('0x04019b186993b620455077b6bc37bf61666725d8d87ab33eb113ac0414cd48d78ff46e5ea48c6f22e8f19a77e5dbba9d209df60cbcb841b7e3e81fe444ba829831')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} publicKey - A public key string.\r\n * @return {Array.<string>} An array with x, y points.\r\n */\n\n\nconst xyPointFromPublicKey = pub => {\n  let publicKey = pub;\n  if (isCompressedPublicKey(publicKey)) publicKey = decompressPublicKey(pub);\n  publicKey = publicKey.replace('0x', '');\n  if (publicKey.length === 130 && publicKey.slice(0, 2) === '04') publicKey = publicKey.slice(2);\n  if (publicKey.length !== 128) throw Error('Invalid public key'); // + 2 means '0x'\n\n  const pubX = `0x${publicKey.slice(0, 64).replace(/^0+/, '')}`;\n  const pubY = `0x${publicKey.slice(64).replace(/^0+/, '')}`;\n  return [pubX, pubY];\n};\n/**\r\n * Trims leading zero from 0x-prefixed hex string.\r\n *\r\n * @example\r\n * const result = caver.utils.trimLeadingZero('0x0000011') // '0x11'\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} hex - A hex string to trim.\r\n * @return {string} A hex string without leading zero.\r\n */\n\n\nconst trimLeadingZero = function (hex) {\n  while (hex && hex.startsWith('0x0')) {\n    hex = `0x${hex.slice(3)}`;\n  }\n\n  return hex;\n};\n/**\r\n * Returns a string to an even length.\r\n *\r\n * @example\r\n * const result = caver.utils.makeEven('0x011') // '0x0011'\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} hex - A hex string to make even.\r\n * @return {string} A string with even length.\r\n */\n\n\nconst makeEven = function (hex) {\n  if (hex.length % 2 === 1) {\n    hex = hex.replace('0x', '0x0');\n  }\n\n  return hex;\n};\n/**\r\n * Converts the signature to an array format.\r\n *\r\n * @example\r\n * const result = caver.utils.resolveSignature({ v: '0x0fe9', r: '0x02aca...', s: '0x20502...' })\r\n * const result = caver.utils.resolveSignature({ V: '0x0fe9', R: '0x02aca...', S: '0x20502...' })\r\n * const result = caver.utils.resolveSignature('0x7e85aaff6a6ef0730308af49f6b512741e61f958a21df387a0d0e8973fb40ca0307a8b87f6ac249f7218b4ee1a1d2f7d764ec2d20d9824e7b7b842dd214f139c7f6')\r\n *\r\n * @ignore\r\n * @param {string|object|Array.<string>|SignatureData} signature A signature string, object or array.\r\n * @return {Array.<string>} A signature array.\r\n */\n\n\nconst resolveSignature = signature => {\n  if (_.isArray(signature)) {\n    const [v, r, s] = signature;\n    return [v, r, s];\n  }\n\n  if (_.isObject(signature)) {\n    const v = signature.V || signature.v;\n    const r = signature.R || signature.r;\n    const s = signature.S || signature.s;\n    if (!v || !r || !s) throw new Error('v, r, s fields should exist in signature');\n    return [v, r, s];\n  }\n\n  if (_.isString(signature)) {\n    const v = `0x${signature.slice(64 * 2 + 2)}`;\n    const decoded = Account.decodeSignature(signature);\n    return [v, decoded[1], decoded[2]];\n  }\n};\n/**\r\n * Converts the signature to an `{ V, R, S }` format.\r\n * Klaytn Node uses `{ V, R, S }` format, so you can use this function to convert caver signature format to `{ V, R, S }`.\r\n *\r\n * @example\r\n * const result = caver.utils.transformSignaturesToObject([\r\n *     '0x7f6',\r\n *     '0x7e85aaff6a6ef0730308af49f6b512741e61f958a21df387a0d0e8973fb40ca0',\r\n *     '0x307a8b87f6ac249f7218b4ee1a1d2f7d764ec2d20d9824e7b7b842dd214f139c'\r\n * ])\r\n *\r\n * @ignore\r\n * @param {string|object|Array.<string>|SignatureData} signature A signature string, object or array.\r\n * @return {Klay.SignatureData} A signature object.\r\n */\n\n\nconst transformSignaturesToObject = signatures => {\n  let isSingular = false;\n  if (!signatures) throw new Error(`Failed to transform signatures to object: invalid signatures ${signatures}`); // Input cases\n  // case 1. '0xf1998...'\n  // case 2. {V: '0x4e44', R: '0x1692a...', S: '0x277b9...'} or {v: '0x4e44', r: '0x1692a...', s: '0x277b9...'}\n  // case 3. ['0xf1998...', '0x53fe7...']\n  // case 4. ['0x4e44', '0x1692a...', '0x277b9...']\n  // case 5. [{V: '0x4e44', R: '0x1692a...', S: '0x277b9...'}, {v: '0x4e44', r: '0x1692a...', s: '0x277b9...'}]\n  // case 6. [['0x4e44', '0x1692a...', '0x277b9...'], ['0x4e44', '0x1692a...', '0x277b9...']]\n  // Transform a signature to an array of signatures to execute the same logic in the for loop below.\n\n  if (!_.isArray(signatures)) {\n    signatures = [signatures];\n    isSingular = true;\n  } else if (_.isString(signatures[0])) {\n    // This logic is performed for case 3 and case 4.\n    // In case 3, the signature string is in the array.\n    // In case 4, v, r, and s are separately included in the array.\n    // The signature string is a combination of v, r, and s, so the length of the signature string will be longer than 64.\n    // Hence, only case 4 will perform the below logic to form an array of signatures.\n    const stripped = signatures[0].replace('0x', '');\n\n    if (stripped.length <= 64) {\n      signatures = [signatures];\n      isSingular = true;\n    }\n  }\n\n  const ret = [];\n\n  for (const sig of signatures) {\n    const sigObj = {};\n\n    if (_.isArray(sig)) {\n      if (sig.length !== 3) throw new Error(`Failed to transform signatures to object: invalid length of signature (${sig.length})`);\n      if (isEmptySig(sig)) continue;\n      const [V, R, S] = sig;\n      sigObj.V = V;\n      sigObj.R = R;\n      sigObj.S = S;\n    } else if (_.isString(sig)) {\n      const decoded = Account.decodeSignature(sig).map(s => makeEven(trimLeadingZero(s)));\n      sigObj.V = decoded[0];\n      sigObj.R = decoded[1];\n      sigObj.S = decoded[2];\n    } else if (_.isObject(sig)) {\n      Object.keys(sig).map(key => {\n        if (key === 'v' || key === 'V' || key === '_v') {\n          sigObj.V = sig[key];\n        } else if (key === 'r' || key === 'R' || key === '_r') {\n          sigObj.R = sig[key];\n        } else if (key === 's' || key === 'S' || key === '_s') {\n          sigObj.S = sig[key];\n        } else {\n          throw new Error(`Failed to transform signatures to object: invalid key(${key}) is defined in signature object.`);\n        }\n      });\n    } else {\n      throw new Error(`Unsupported signature type: ${typeof sig}`);\n    }\n\n    if (!sigObj.V || !sigObj.R || !sigObj.S) {\n      throw new Error(`Failed to transform signatures to object: invalid signature ${sig}`);\n    }\n\n    Object.keys(sigObj).map(k => {\n      sigObj[k] = trimLeadingZero(sigObj[k]);\n    });\n    ret.push(sigObj);\n  }\n\n  return isSingular ? ret[0] : ret;\n};\n/**\r\n * Returns tx type string.\r\n * This function uses an old type string.\r\n *\r\n * @example\r\n * const result = caver.utils.getTxTypeStringFromRawTransaction('0x08f83a808505d21dba00824e20945b2840bcbc2be07fb12d9129ed3a02d8e446594401945b2840bcbc2be07fb12d9129ed3a02d8e4465944c4c3018080')\r\n *\r\n * @deprecated\r\n * @ignore\r\n * @param {string} rawTransaction An RLP-encoded transaction string.\r\n * @return {string} A transaction type string.\r\n */\n\n\nconst getTxTypeStringFromRawTransaction = rawTransaction => {\n  if (typeof rawTransaction !== 'string') throw new Error('Invalid raw Tx', rawTransaction);\n  const type = rawTransaction.slice(0, 4);\n  const typeString = txTypeToString[type];\n  return typeString;\n};\n/**\r\n * Returns tx type string.\r\n * This function uses an old type string.\r\n *\r\n * @example\r\n * const result = caver.utils.isValidPublicKey('0x3a06fcf2eb4f096e01bc70ab2c81ba79e82af9c62a3ef5fe1fef329c3ad89e8622aed245899ffa530ddd8ebf1a0a66f157b75a38a715f82ad6061af36cbd9cd8')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} rawTransaction An RLP-encoded transaction string.\r\n * @return {string} A transaction type string.\r\n */\n\n\nconst isValidPublicKey = publicKey => {\n  let pubString = publicKey.replace('0x', '');\n  if (pubString.length === 130 && pubString.slice(0, 2) === '04') pubString = pubString.slice(2);\n  if (pubString.length !== 66 && pubString.length !== 128) return false;\n  if (pubString.length === 66 && !isCompressedPublicKey(pubString)) return false;\n  if (pubString.length === 66) pubString = decompressPublicKey(pubString);\n  const xyPoints = xyPointFromPublicKey(pubString);\n  if (xyPoints === undefined || !xyPoints.length || xyPoints.length !== 2) return false;\n  const point = secp256k1.curve.point(xyPoints[0].slice(2), xyPoints[1].slice(2), true);\n  return secp256k1.keyFromPublic(point).validate().result;\n};\n/**\r\n * Return `true` is public key is compressed, otherwise `false`.\r\n *\r\n * @example\r\n * const result = caver.utils.isCompressedPublicKey('0x023a06fcf2eb4f096e01bc70ab2c81ba79e82af9c62a3ef5fe1fef329c3ad89e86')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} publicKey A public key string.\r\n * @return {boolean} `true` means compressed.\r\n */\n\n\nconst isCompressedPublicKey = publicKey => {\n  const compressedIndicators = ['02', '03'];\n  const withoutPrefix = publicKey.replace('0x', '');\n  return withoutPrefix.length === 66 && compressedIndicators.includes(withoutPrefix.slice(0, 2));\n};\n/**\r\n * Compresses the uncompressed public key.\r\n *\r\n * @example\r\n * const result = caver.utils.compressPublicKey('0x62cef87819b82f62e9c0a38c1fa7dfa089084959df86aca19ff2f6c903db2248b45dc23220ee6bcd8753bb9df8ce7d58e56eabebb14479f3a0ca5ccd4bdea632')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} publicKey A public key string.\r\n * @return {string} A compressed public key.\r\n */\n\n\nconst compressPublicKey = uncompressedPublicKey => {\n  const isAlreadyCompressed = isCompressedPublicKey(uncompressedPublicKey);\n  if (isAlreadyCompressed) return uncompressedPublicKey;\n  const xyPoints = xyPointFromPublicKey(uncompressedPublicKey);\n\n  if (xyPoints === undefined || !xyPoints.length || xyPoints.length !== 2) {\n    throw new Error('invalid public key');\n  }\n\n  const [x, y] = xyPoints;\n  const keyPair = secp256k1.keyPair({\n    pub: {\n      x: x.replace('0x', ''),\n      y: y.replace('0x', '')\n    },\n    pubEnc: 'hex'\n  });\n  const compressedPublicKey = `0x${keyPair.getPublic(true, 'hex')}`;\n  return compressedPublicKey;\n};\n/**\r\n * Decompresses the compressed public key.\r\n *\r\n * @example\r\n * const result = caver.utils.decompressPublicKey('0x0262cef87819b82f62e9c0a38c1fa7dfa089084959df86aca19ff2f6c903db2248')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} publicKey A public key string.\r\n * @return {string} A uncompressed public key.\r\n */\n\n\nconst decompressPublicKey = compressedPublicKey => {\n  if (!isCompressedPublicKey(compressedPublicKey)) {\n    if (!isValidPublicKey(compressedPublicKey)) throw new Error(`Invalid public key`);\n    return compressedPublicKey;\n  }\n\n  const compressedWithoutPrefix = compressedPublicKey.replace('0x', '');\n  const curve = secp256k1.curve;\n  const decoded = curve.decodePoint(compressedWithoutPrefix, 'hex');\n  const hexEncoded = decoded.encode('hex').slice(2);\n  return `0x${hexEncoded}`;\n};\n\nconst isContractDeployment = txObject => {\n  if (txObject.type) {\n    if (txObject.type.includes('SMART_CONTRACT_DEPLOY') || txObject.type.includes('SmartContractDeploy')) return true;\n    if (txObject.type !== 'LEGACY' && txObject.type !== 'TxTypeLegacyTransaction') return false;\n  }\n\n  if (txObject.data && txObject.data !== '0x' && (!txObject.to || txObject.to === '0x')) return true;\n  return false;\n};\n\nconst isValidRole = role => {\n  switch (role) {\n    case 'roleTransactionKey':\n    case 'roleAccountUpdateKey':\n    case 'roleFeePayerKey':\n    case 'transactionKey':\n    case 'updateKey':\n    case 'feePayerKey':\n      return true;\n  }\n\n  return false;\n}; // ['0x01', '0x', '0x]\n// [['0x01', '0x', '0x]]\n// '0x....'\n// { v: '0x01', r: '0x', s:'0x' }\n// SignatureData { _v: '0x01', _r: '0x', _s:'0x' }\n// [SignatureData { _v: '0x01', _r: '0x', _s:'0x' }]\n\n/**\r\n * Returns `true` if sig is in the format of empty signature (`SignatureData { _v: '0x01', _r: '0x', _s: '0x' }` or `[SignatureData { _v: '0x01', _r: '0x', _s: '0x' }]`), otherwise it returns `false`.\r\n *\r\n * In caver-js, if signatures or feePayerSignatures is empty, the value representing an empty signature, `[SignatureData { _v: '0x01', _r: '0x', _s: '0x' }]`, is returned for the property.\r\n * This function is used to check whether the given signature is `[SignatureData { _v: '0x01', _r: '0x', _s: '0x' }]` (or `SignatureData { _v: '0x01', _r: '0x', _s: '0x' }` in the 'LEGACY' transaction).\r\n *\r\n * @example\r\n * const result = caver.utils.isEmptySig(['0x01', '0x', '0x'])\r\n * const result = caver.utils.isEmptySig({ v: '0x01', r: '0x', s: '0x' })\r\n * const result = caver.utils.isEmptySig({ V: '0x01', R: '0x', S: '0x' })\r\n * const result = caver.utils.isEmptySig(new caver.wallet.keyring.signatureData(['0x01', '0x', '0x']))\r\n *\r\n * const result = caver.utils.isEmptySig([['0x01', '0x', '0x']])\r\n * const result = caver.utils.isEmptySig([{ v: '0x01', r: '0x', s: '0x' }])\r\n * const result = caver.utils.isEmptySig([{ V: '0x01', R: '0x', S: '0x' }])\r\n * const result = caver.utils.isEmptySig([new caver.wallet.keyring.signatureData(['0x01', '0x', '0x'])])\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {object|Array.<object>|Array.<string>|Array.<Array.<string>>|SignatureData|Array.<SignatureData>} sig An instance of {@link SignatureData} or array of {@link SignatureData} to check empty or not.\r\n * @return {boolean} `true` means the sig is empty.\r\n */\n\n\nconst isEmptySig = sig => {\n  let sigs = sig; // Convert to array format\n\n  if (!_.isArray(sig)) sigs = resolveSignature(sigs); // Format to two-dimentional array\n\n  if (_.isString(sigs[0])) sigs = [sigs];\n\n  for (let s of sigs) {\n    if (!_.isArray(s)) s = resolveSignature(s);\n    if (s.length !== 3) throw new Error(`Invalid signatures length: ${s.length}`);\n    if (s[0] !== '0x01' || s[1] !== '0x' || s[2] !== '0x') return false;\n  }\n\n  return true;\n};\n/**\r\n * Hashes message with Klaytn specific prefix: `keccak256(\"\\x19Klaytn Signed Message:\\n\" + len(message) + message))`\r\n *\r\n * @example\r\n * const result = caver.utils.hashMessage('Hello') // '0x640bfab59b6e27468abd367888f4ab1a1c77aa2b45e76a1d3adcbd039c305917'\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} data A message to hash. If it is a HEX string, it will be UTF-8 decoded first.\r\n * @return {string} The hashed message with Klaytn specific prefix.\r\n */\n\n\nconst hashMessage = data => {\n  const message = isHexStrict(data) ? hexToBytes(data) : data;\n  const messageBuffer = Buffer.from(message);\n  const preamble = `\\x19Klaytn Signed Message:\\n${message.length}`;\n  const preambleBuffer = Buffer.from(preamble); // klayMessage is concatenated buffer (preambleBuffer + messageBuffer)\n\n  const klayMessage = Buffer.concat([preambleBuffer, messageBuffer]); // Finally, run keccak256 on klayMessage.\n\n  return Hash.keccak256(klayMessage);\n};\n/**\r\n * Recovers the public key that was used to sign the given data.\r\n *\r\n * @example\r\n * const message = 'Some data'\r\n * const signature = { v: '0x1c', r: '0xd0b8d...', s: '0x5472e...' } // You can get a signature via `keyring.signMessage(...).signatures[0]`.\r\n * const recoveredPublicKey = caver.utils.recoverPublicKey(message, signature)\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} message The raw message string. If this message is hased with Klaytn specific prefix, the third parameter should be passed as `true`.\r\n * @param {SignatureData|Array.<string>|object} signature An instance of `SignatureData`, `[v, r, s]` or `{v, r, s}`.\r\n * @param {boolean} [isHashed] (optional, default: `false`) If the `isHashed` is true, the given message will NOT automatically be prefixed with \"\\x19Klaytn Signed Message:\\n\" + message.length + message, and be assumed as already prefixed.\r\n * @return {string}\r\n */\n\n\nconst recoverPublicKey = function (message, signature) {\n  let isHashed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (!isHashed) message = hashMessage(message);\n  if (_.isArray(signature)) signature = {\n    v: signature[0],\n    r: signature[1],\n    s: signature[2]\n  };\n  const vrs = {\n    v: parseInt(signature.v.slice(2), 16),\n    r: signature.r.slice(2),\n    s: signature.s.slice(2)\n  };\n  const ecPublicKey = secp256k1.recoverPubKey(Buffer.from(message.slice(2), 'hex'), vrs, vrs.v < 2 ? vrs.v : 1 - vrs.v % 2);\n  return `0x${ecPublicKey.encode('hex', false).slice(2)}`;\n};\n/**\r\n * Recovers the Klaytn address that was used to sign the given data.\r\n *\r\n * @example\r\n * const message = 'Some data'\r\n * const signature = { v: '0x1c', r: '0xd0b8d...', s: '0x5472e...' } // You can get a signature via `keyring.signMessage(...).signatures[0]`.\r\n * const recoveredPublicKey = caver.utils.recover(message, signature)\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} message The raw message string. If this message is hased with Klaytn specific prefix, the third parameter should be passed as `true`.\r\n * @param {SignatureData|Array.<string>|object} signature An instance of `SignatureData`, `[v, r, s]` or `{v, r, s}`.\r\n * @param {boolean} [isHashed] (optional, default: `false`) If the `isHashed` is true, the given message will NOT automatically be prefixed with \"\\x19Klaytn Signed Message:\\n\" + message.length + message, and be assumed as already prefixed.\r\n * @return {string}\r\n */\n\n\nconst recover = function (message, signature) {\n  let isHashed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (!isHashed) {\n    message = hashMessage(message);\n  }\n\n  return Account.recover(message, Account.encodeSignature(resolveSignature(signature))).toLowerCase();\n};\n/**\r\n * Returns an address which is derived by a public key.\r\n * This function simply converts the public key string into address form by hashing it.\r\n * It has nothing to do with the actual account in the Klaytn.\r\n *\r\n * @example\r\n * const address = caver.utils.publicKeyToAddress('0x{public key}')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @method publicKeyToAddress\r\n * @param {string} pubKey The public key string to get the address.\r\n * @return {string}\r\n */\n\n\nconst publicKeyToAddress = pubKey => {\n  let publicKey = pubKey.slice(0, 2) === '0x' ? pubKey : `0x${pubKey}`;\n  if (isCompressedPublicKey(publicKey)) publicKey = decompressPublicKey(publicKey); // With '0x' prefix, 65 bytes in uncompressed format.\n\n  if (Buffer.byteLength(publicKey, 'hex') !== 65) throw new Error(`Invalid public key: ${pubKey}`);\n  const publicHash = Hash.keccak256(publicKey);\n  const address = `0x${publicHash.slice(-40)}`;\n  const addressHash = Hash.keccak256s(address.slice(2));\n  let checksumAddress = '0x';\n\n  for (let i = 0; i < 40; i++) checksumAddress += parseInt(addressHash[i + 2], 16) > 7 ? address[i + 2].toUpperCase() : address[i + 2];\n\n  return checksumAddress;\n};\n\nmodule.exports = {\n  BN: BN,\n  isBN: isBN,\n  BigNumber: BigNumber,\n  isBigNumber: isBigNumber,\n  toBN: toBN,\n  isAddress: isAddress,\n  isBloom: isBloom,\n  // TODO UNDOCUMENTED\n  isTopic: isTopic,\n  // TODO UNDOCUMENTED\n  checkAddressChecksum: checkAddressChecksum,\n  utf8ToHex: utf8ToHex,\n  hexToUtf8: hexToUtf8,\n  hexToNumber: hexToNumber,\n  hexToNumberString: hexToNumberString,\n  numberToHex: numberToHex,\n  toHex: toHex,\n  bufferToHex: bufferToHex,\n  toBuffer: toBuffer,\n  numberToBuffer: numberToBuffer,\n  hexToBytes: hexToBytes,\n  bytesToHex: bytesToHex,\n  isHex: isHex,\n  isHexStrict: isHexStrict,\n  leftPad: leftPad,\n  rightPad: rightPad,\n  toTwosComplement: toTwosComplement,\n  sha3: sha3,\n  parsePredefinedBlockNumber: parsePredefinedBlockNumber,\n  isPredefinedBlockNumber: isPredefinedBlockNumber,\n  isValidBlockNumberCandidate: isValidBlockNumberCandidate,\n  isValidPrivateKey: isValidPrivateKey,\n  isValidNSHSN: isValidNSHSN,\n  parsePrivateKey: parsePrivateKey,\n  parseKlaytnWalletKey: parseKlaytnWalletKey,\n  isKlaytnWalletKey: isKlaytnWalletKey,\n  isContractDeployment: isContractDeployment,\n  rlpEncode: rlpEncode,\n  rlpDecode: rlpDecode,\n  xyPointFromPublicKey: xyPointFromPublicKey,\n  resolveSignature: resolveSignature,\n  transformSignaturesToObject: transformSignaturesToObject,\n  getTxTypeStringFromRawTransaction,\n  trimLeadingZero,\n  makeEven,\n  txTypeToString,\n  isValidPublicKey,\n  isCompressedPublicKey,\n  compressPublicKey,\n  decompressPublicKey,\n  isTxHash,\n  isTxHashStrict,\n  isValidHash,\n  isValidHashStrict,\n  isValidRole: isValidRole,\n  isEmptySig: isEmptySig,\n  hashMessage: hashMessage,\n  recover: recover,\n  recoverPublicKey: recoverPublicKey,\n  publicKeyToAddress: publicKeyToAddress\n};","map":{"version":3,"names":["_","require","BN","BigNumber","numberToBN","utf8","Hash","RLP","Account","elliptic","secp256k1","ec","txTypeToString","HASH_LENGTH","isBN","bn","isBigNumber","bigNumber","toBN","number","apply","arguments","e","Error","toTwosComplement","toTwos","toString","isAddress","address","test","checkAddressChecksum","replace","addressHash","sha3","toLowerCase","i","parseInt","toUpperCase","leftPad","string","chars","sign","hasPrefix","padding","length","Array","join","rightPad","utf8ToHex","str","encode","hex","split","reverse","code","charCodeAt","n","hexToUtf8","isHexStrict","l","substr","String","fromCharCode","decode","hexToNumber","value","toNumber","hexToNumberString","isString","numberToHex","isNumber","message","isNull","isUndefined","isFinite","result","lt","bytesToHex","bytes","push","hexToBytes","c","toHex","returnType","Buffer","isBuffer","bufferToHex","isBoolean","isObject","JSON","stringify","indexOf","buf","toBuffer","input","undefined","alloc","isArray","from","toArrayLike","toArray","isFunction","makeEven","numberToBuffer","num","isHex","isTxHash","txHash","isValidHash","hash","RegExp","isTxHashStrict","isValidHashStrict","isBloom","bloom","isTopic","topic","parsePredefinedBlockNumber","blockNumber","isPredefinedBlockNumber","predefinedBlock","isValidBlockNumberCandidate","Number","SHA3_NULL_S","returnValue","keccak256","_Hash","parsePrivateKey","privateKey","has0xPrefix","slice","parsedPrivateKey","type","isKlaytnWalletKey","parsedAddress","parseKlaytnWalletKey","key","klaytnWalletKey","startsWith","splitted","splited","isValidPrivateKey","VALID_PRIVATE_KEY_LIMIT","VALID_PRIVATE_LOWER_BOUND","isValidNSHSN","rlpEncode","data","rlpDecode","encodedData","xyPointFromPublicKey","pub","publicKey","isCompressedPublicKey","decompressPublicKey","pubX","pubY","trimLeadingZero","resolveSignature","signature","v","r","s","V","R","S","decoded","decodeSignature","transformSignaturesToObject","signatures","isSingular","stripped","ret","sig","sigObj","isEmptySig","map","Object","keys","k","getTxTypeStringFromRawTransaction","rawTransaction","typeString","isValidPublicKey","pubString","xyPoints","point","curve","keyFromPublic","validate","compressedIndicators","withoutPrefix","includes","compressPublicKey","uncompressedPublicKey","isAlreadyCompressed","x","y","keyPair","pubEnc","compressedPublicKey","getPublic","compressedWithoutPrefix","decodePoint","hexEncoded","isContractDeployment","txObject","to","isValidRole","role","sigs","hashMessage","messageBuffer","preamble","preambleBuffer","klayMessage","concat","recoverPublicKey","isHashed","vrs","ecPublicKey","recoverPubKey","recover","encodeSignature","publicKeyToAddress","pubKey","byteLength","publicHash","keccak256s","checksumAddress","module","exports"],"sources":["C:/Users/User/Documents/clone-starter-kit-08/node_modules/caver-js/packages/caver-utils/src/utils.js"],"sourcesContent":["/*\r\n Modifications copyright 2018 The caver-js Authors\r\n This file is part of web3.js.\r\n\r\n web3.js is free software: you can redistribute it and/or modify\r\n it under the terms of the GNU Lesser General Public License as published by\r\n the Free Software Foundation, either version 3 of the License, or\r\n (at your option) any later version.\r\n\r\n web3.js is distributed in the hope that it will be useful,\r\n but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n GNU Lesser General Public License for more details.\r\n\r\n You should have received a copy of the GNU Lesser General Public License\r\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n This file is derived from web3.js/packages/web3-utils/src/utils.js (2019/06/12).\r\n Modified and improved for the caver-js development.\r\n */\r\n/**\r\n * @file utils.js\r\n * @author Fabian Vogelsteller <fabian@ethereum.org>\r\n * @date 2017\r\n */\r\n\r\nconst _ = require('lodash')\r\nconst BN = require('bn.js')\r\nconst BigNumber = require('bignumber.js')\r\nconst numberToBN = require('number-to-bn')\r\nconst utf8 = require('utf8')\r\nconst Hash = require('eth-lib/lib/hash')\r\nconst RLP = require('eth-lib/lib/rlp')\r\nconst Account = require('eth-lib/lib/account')\r\n\r\nconst elliptic = require('elliptic')\r\n\r\nconst secp256k1 = new elliptic.ec('secp256k1')\r\n\r\nconst txTypeToString = {\r\n    '0x20': 'ACCOUNT_UPDATE',\r\n    '0x21': 'FEE_DELEGATED_ACCOUNT_UPDATE',\r\n    '0x22': 'FEE_DELEGATED_ACCOUNT_UPDATE_WITH_RATIO',\r\n    '0x08': 'VALUE_TRANSFER',\r\n    '0x10': 'VALUE_TRANSFER_MEMO',\r\n    '0x09': 'FEE_DELEGATED_VALUE_TRANSFER',\r\n    '0x0a': 'FEE_DELEGATED_VALUE_TRANSFER_WITH_RATIO',\r\n    '0x11': 'FEE_DELEGATED_VALUE_TRANSFER_MEMO',\r\n    '0x12': 'FEE_DELEGATED_VALUE_TRANSFER_MEMO_WITH_RATIO',\r\n    '0x28': 'SMART_CONTRACT_DEPLOY',\r\n    '0x29': 'FEE_DELEGATED_SMART_CONTRACT_DEPLOY',\r\n    '0x2a': 'FEE_DELEGATED_SMART_CONTRACT_DEPLOY_WITH_RATIO',\r\n    '0x30': 'SMART_CONTRACT_EXECUTION',\r\n    '0x31': 'FEE_DELEGATED_SMART_CONTRACT_EXECUTION',\r\n    '0x32': 'FEE_DELEGATED_SMART_CONTRACT_EXECUTION_WITH_RATIO',\r\n    '0x38': 'CANCEL',\r\n    '0x39': 'FEE_DELEGATED_CANCEL',\r\n    '0x3a': 'FEE_DELEGATED_CANCEL_WITH_RATIO',\r\n    '0x48': 'CHAIN_DATA_ANCHORING',\r\n}\r\n\r\nconst HASH_LENGTH = 66\r\n\r\n/**\r\n * Returns `true` if parameter is a BN instance, otherwise `false`.\r\n *\r\n * @example\r\n * const bn = new caver.utils.BN(10)\r\n * const result = caver.utils.isBN(bn)\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {*} bn\r\n * @return {boolean} `true` if a given value is a `BN.js` instance.\r\n */\r\nconst isBN = function(bn) {\r\n    return BN.isBN(bn)\r\n}\r\n\r\n/**\r\n * Returns `true` if object is a BigNumber instance, otherwise `false`.\r\n *\r\n * @example\r\n * const bigNumber = new caver.utils.BigNumber(10)\r\n * const result = caver.utils.isBigNumber(bigNumber)\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {*} bigNumber\r\n * @return {boolean} `true` if a given value is a `Bignumber.js` instance.\r\n */\r\nconst isBigNumber = function(bigNumber) {\r\n    return BigNumber.isBigNumber(bigNumber)\r\n}\r\n\r\n/**\r\n * Safely converts any given value (including `Bignumber.js` instances) into a `BN.js` instance, for handling big numbers in JavaScript.\r\n *\r\n * @example\r\n * const result = caver.utils.toBN(num)\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {number|string|BN|BigNumber} number The number to convert to a BN.js instance.\r\n * @return {BN} The {@link https://github.com/indutny/bn.js/|BN.js} instance.\r\n */\r\nfunction toBN(number) {\r\n    try {\r\n        return numberToBN.apply(null, arguments)\r\n    } catch (e) {\r\n        throw new Error(`${e} Given value: \"${number}\"`)\r\n    }\r\n}\r\n\r\n/**\r\n * Converts a negative number into a two's complement.\r\n *\r\n * @example\r\n * const result = caver.utils.toTwosComplement(num)\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {number|string|BN|BigNumber} number The number to convert.\r\n * @return {string} The converted hex string.\r\n */\r\nconst toTwosComplement = function(number) {\r\n    return `0x${toBN(number)\r\n        .toTwos(256)\r\n        .toString(16, 64)}`\r\n}\r\n\r\n/**\r\n * Checks if a given string is a valid Klaytn address.\r\n * It will also check the checksum if the address has upper and lowercase letters.\r\n *\r\n * @example\r\n * const result = caver.utils.isAddress('0x{address in hex}')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} address An address string.\r\n * @return {boolean} `true` if a given string is a valid Klaytn address.\r\n */\r\nconst isAddress = function(address) {\r\n    // check if it has the basic requirements of an address\r\n    if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {\r\n        return false\r\n        // If it's ALL lowercase or ALL upppercase\r\n    }\r\n    if (/^(0x|0X)?[0-9a-f]{40}$/.test(address) || /^(0x|0X)?[0-9A-F]{40}$/.test(address)) {\r\n        return true\r\n        // Otherwise check each case\r\n    }\r\n    return checkAddressChecksum(address)\r\n}\r\n\r\n/**\r\n * Checks the checksum of a given address.\r\n * Will also return `false` on non-checksum addresses.\r\n *\r\n * @example\r\n * const result = caver.utils.checkAddressChecksum('0x{address in hex}')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} address An address string.\r\n * @return {boolean}\r\n */\r\nconst checkAddressChecksum = function(address) {\r\n    // Check each case\r\n    address = address.replace(/^0x/i, '')\r\n    const addressHash = sha3(address.toLowerCase()).replace(/^0x/i, '')\r\n\r\n    for (let i = 0; i < 40; i++) {\r\n        // the nth letter should be uppercase if the nth digit of casemap is 1\r\n        if (\r\n            (parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i]) ||\r\n            (parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i])\r\n        ) {\r\n            return false\r\n        }\r\n    }\r\n    return true\r\n}\r\n\r\n/**\r\n * Adds padding on the left of a string. Useful for adding paddings to HEX strings.\r\n *\r\n * @example\r\n * const result = caver.utils.padLeft('0x3456ff', 20) // '0x000000000000003456ff'\r\n * const result = caver.utils.padLeft('Hello', 20, 'x') // 'xxxxxxxxxxxxxxxHello'\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n * @alias padLeft\r\n *\r\n * @param {string} string The string to add padding on the left.\r\n * @param {number} chars The number of characters the total string should have.\r\n * @param {string} [sign] The character sign to use, defaults to `0`.\r\n * @returns {string} The padded string.\r\n */\r\nconst leftPad = function(string, chars, sign) {\r\n    const hasPrefix = /^0x/i.test(string) || typeof string === 'number'\r\n    string = string.toString(16).replace(/^0x/i, '')\r\n\r\n    const padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0\r\n\r\n    return (hasPrefix ? '0x' : '') + new Array(padding).join(sign || '0') + string\r\n}\r\n\r\n/**\r\n * Adds padding on the right of a string, Useful for adding paddings to HEX strings.\r\n *\r\n * @example\r\n * const result = caver.utils.rightPad('0x3456ff', 20) // '0x3456ff00000000000000'\r\n * const result = caver.utils.rightPad('Hello', 20, 'x') // 'Helloxxxxxxxxxxxxxxx'\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n * @alias padRight\r\n *\r\n * @param {string} string The string to add padding on the right.\r\n * @param {number} chars The number of characters the total string should have.\r\n * @param {string} [sign] The character sign to use, defaults to `0`.\r\n * @returns {string} The padded string.\r\n */\r\nconst rightPad = function(string, chars, sign) {\r\n    const hasPrefix = /^0x/i.test(string) || typeof string === 'number'\r\n    string = string.toString(16).replace(/^0x/i, '')\r\n\r\n    const padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0\r\n\r\n    return (hasPrefix ? '0x' : '') + string + new Array(padding).join(sign || '0')\r\n}\r\n\r\n/**\r\n * Returns the HEX representation of a given UTF-8 string.\r\n *\r\n * @example\r\n * const result = caver.utils.utf8ToHex('I have 100€') // '0x49206861766520313030e282ac'\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} str A UTF-8 string to convert to a HEX string.\r\n * @returns {string} The HEX string.\r\n */\r\nconst utf8ToHex = function(str) {\r\n    str = utf8.encode(str)\r\n    let hex = ''\r\n\r\n    // remove \\u0000 padding from either side\r\n    str = str.replace(/^(?:\\u0000)*/, '')\r\n    str = str\r\n        .split('')\r\n        .reverse()\r\n        .join('')\r\n    str = str.replace(/^(?:\\u0000)*/, '')\r\n    str = str\r\n        .split('')\r\n        .reverse()\r\n        .join('')\r\n\r\n    for (let i = 0; i < str.length; i++) {\r\n        const code = str.charCodeAt(i)\r\n        // if (code !== 0) {\r\n        const n = code.toString(16)\r\n        hex += n.length < 2 ? `0${n}` : n\r\n        // }\r\n    }\r\n\r\n    return `0x${hex}`\r\n}\r\n\r\n/**\r\n * Returns the UTF-8 string representation of a given HEX value.\r\n *\r\n * @example\r\n * const result = caver.utils.hexToUtf8('0x49206861766520313030e282ac') // 'I have 100€'\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} hex A HEX string to convert to a UTF-8 string.\r\n * @returns {string} The UTF-8 string.\r\n */\r\nconst hexToUtf8 = function(hex) {\r\n    if (!isHexStrict(hex)) {\r\n        throw new Error(`The parameter \"${hex}\" must be a valid HEX string.`)\r\n    }\r\n\r\n    let str = ''\r\n    let code = 0\r\n    hex = hex.replace(/^0x/i, '')\r\n\r\n    // remove 00 padding from either side\r\n    hex = hex.replace(/^(?:00)*/, '')\r\n    hex = hex\r\n        .split('')\r\n        .reverse()\r\n        .join('')\r\n    hex = hex.replace(/^(?:00)*/, '')\r\n    hex = hex\r\n        .split('')\r\n        .reverse()\r\n        .join('')\r\n\r\n    const l = hex.length\r\n\r\n    for (let i = 0; i < l; i += 2) {\r\n        code = parseInt(hex.substr(i, 2), 16)\r\n        // if (code !== 0) {\r\n        str += String.fromCharCode(code)\r\n        // }\r\n    }\r\n\r\n    return utf8.decode(str)\r\n}\r\n\r\n/**\r\n * Returns the number representation of a given HEX value.\r\n * Please note that this function is not useful for big numbers, rather use `caver.utils.toBN`.\r\n *\r\n * @example\r\n * const result = caver.utils.hexToNumber('0xea') // 234\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} A HEX string to be converted.\r\n * @return {number} The number representation of a given HEX value.\r\n */\r\nconst hexToNumber = function(value) {\r\n    if (!value) return value\r\n\r\n    if (typeof value === 'string' && !isHexStrict(value)) {\r\n        throw new Error(`Given value \"${value}\" is not a valid hex string.`)\r\n    }\r\n\r\n    return toBN(value).toNumber()\r\n}\r\n\r\n/**\r\n * Returns the number representation of a given HEX value as a string.\r\n *\r\n * @example\r\n * const result = caver.utils.hexToNumberString('0xea') // '234'\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} A HEX string to be converted.\r\n * @return {string} The number as a string.\r\n */\r\nconst hexToNumberString = function(value) {\r\n    if (!value) return value\r\n\r\n    if (_.isString(value) && !isHexStrict(value)) {\r\n        throw new Error(`Given value \"${value}\" is not a valid hex string.`)\r\n    }\r\n\r\n    return toBN(value).toString(10)\r\n}\r\n\r\n/**\r\n * Returns the HEX representation of a given number value.\r\n *\r\n * @example\r\n * const result = caver.utils.numberToHex(234) // '0xea'\r\n * const result = caver.utils.numberToHex('234')\r\n * const result = caver.utils.numberToHex(new caver.utils.BN(234))\r\n * const result = caver.utils.numberToHex(new caver.utils.BigNumber(234))\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string|number|BN|BigNumber} value A number as string or number.\r\n * @return {string} The HEX value of the given number.\r\n */\r\nconst numberToHex = function(value) {\r\n    if (_.isNumber(value)) {\r\n        const bn = toBN(value)\r\n        try {\r\n            bn.toNumber()\r\n        } catch (e) {\r\n            throw new Error(`${e.message}: Number type cannot handle big number. Please use hex string or BigNumber/BN.`)\r\n        }\r\n    }\r\n\r\n    if (_.isNull(value) || _.isUndefined(value)) {\r\n        return value\r\n    }\r\n\r\n    if (!isFinite(value) && !isHexStrict(value)) {\r\n        throw new Error(`Given input \"${value}\" is not a number.`)\r\n    }\r\n\r\n    const number = toBN(value)\r\n    const result = number.toString(16)\r\n\r\n    return number.lt(new BN(0)) ? `-0x${result.substr(1)}` : `0x${result}`\r\n}\r\n\r\n/**\r\n * Returns a HEX string from a byte array.\r\n *\r\n * @example\r\n * const result = caver.utils.bytesToHex([ 72, 101, 108, 108, 111, 33, 36 ]) // '0x48656c6c6f2124'\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {Array} bytes A byte array to convert.\r\n * @return {string} The HEX string.\r\n */\r\nconst bytesToHex = function(bytes) {\r\n    const hex = []\r\n    for (let i = 0; i < bytes.length; i++) {\r\n        // eslint-disable-next-line no-bitwise\r\n        hex.push((bytes[i] >>> 4).toString(16))\r\n\r\n        // eslint-disable-next-line no-bitwise\r\n        hex.push((bytes[i] & 0xf).toString(16))\r\n    }\r\n    return `0x${hex.join('')}`\r\n}\r\n\r\n/**\r\n * Returns a byte array from the given HEX string.\r\n *\r\n * @example\r\n * const result = caver.utils.hexToBytes('0x000000ea') // [ 0, 0, 0, 234 ]\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} hex A HEX string to be converted.\r\n * @return {Array.<number>} The byte array.\r\n */\r\nconst hexToBytes = function(hex) {\r\n    hex = hex.toString(16)\r\n\r\n    if (!isHexStrict(hex)) {\r\n        throw new Error(`Given value \"${hex}\" is not a valid hex string.`)\r\n    }\r\n\r\n    hex = hex.replace(/^0x/i, '')\r\n\r\n    const bytes = []\r\n    for (let c = 0; c < hex.length; c += 2) {\r\n        bytes.push(parseInt(hex.substr(c, 2), 16))\r\n    }\r\n    return bytes\r\n}\r\n\r\n/**\r\n * Converts any given value to HEX.\r\n * The numeric strings will be interpreted as numbers.\r\n * Text strings will be interpreted as UTF-8 strings.\r\n *\r\n * @example\r\n * const result = caver.utils.toHex('234') // '0xea'\r\n * const result = caver.utils.toHex(234) // '0xea'\r\n * const result = caver.utils.toHex(new caver.utils.BN('234')) // '0xea'\r\n * const result = caver.utils.toHex(new caver.utils.Bignumber('234')) // '0xea'\r\n * const result = caver.utils.toHex('I have 100€') // '0x49206861766520313030e282ac'\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string|number|BN|BigNumber|Buffer} value The input to convert to HEX.\r\n * @return {string} The resulting HEX string.\r\n */\r\n/* eslint-disable complexity */\r\nconst toHex = function(value, returnType) {\r\n    if (Buffer.isBuffer(value)) {\r\n        return returnType ? 'buffer' : bufferToHex(value)\r\n    }\r\n    if (isAddress(value)) {\r\n        return returnType ? 'address' : `0x${value.toLowerCase().replace(/^0x/i, '')}`\r\n    }\r\n\r\n    if (_.isBoolean(value)) {\r\n        return returnType ? 'bool' : value ? '0x01' : '0x00'\r\n    }\r\n\r\n    if (_.isObject(value) && !isBigNumber(value) && !isBN(value)) {\r\n        return returnType ? 'string' : utf8ToHex(JSON.stringify(value))\r\n    }\r\n\r\n    // if its a negative number, pass it through numberToHex\r\n    if (_.isString(value)) {\r\n        if (value.indexOf('-0x') === 0 || value.indexOf('-0X') === 0) {\r\n            return returnType ? 'int256' : numberToHex(value)\r\n        }\r\n        if (value.indexOf('0x') === 0 || value.indexOf('0X') === 0) {\r\n            return returnType ? 'bytes' : value\r\n        }\r\n        if (!isFinite(value)) {\r\n            return returnType ? 'string' : utf8ToHex(value)\r\n        }\r\n    }\r\n\r\n    return returnType ? (value < 0 ? 'int256' : 'uint256') : numberToHex(value)\r\n}\r\n/* eslint-enable complexity */\r\n\r\n/**\r\n * Converts buffer to 0x-prefixed hex string.\r\n *\r\n * @example\r\n * const result = caver.utils.bufferToHex(Buffer.from('5b9ac8', 'hex')) // '0x5b9ac8'\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {Buffer} buf A buffer to convert to hex string.\r\n * @return {string} The 0x-prefixed hex string.\r\n */\r\nconst bufferToHex = function(buf) {\r\n    buf = toBuffer(buf)\r\n    return `0x${buf.toString('hex')}`\r\n}\r\n\r\n/**\r\n * This function converts the input to a Buffer.\r\n * To convert an object into a Buffer using `caver.utils.toBuffer`, the object must implement `toArray` function.\r\n * For string type input, this function only works with a 0x-prefixed hex string.\r\n *\r\n * @example\r\n * const result = caver.utils.toBuffer(Buffer.alloc(0))\r\n * const result = caver.utils.toBuffer('0x1234')\r\n * const result = caver.utils.toBuffer(1)\r\n * const result = caver.utils.toBuffer([1,2,3])\r\n * const result = caver.utils.toBuffer(new caver.utils.BN(255))\r\n * const result = caver.utils.toBuffer(new caver.utils.BigNumber(255))\r\n * const result = caver.utils.toBuffer({toArray: function() {return [1,2,3,4]}}) // An object that implements `toArray` function\r\n * const result = caver.utils.toBuffer(null)\r\n * const result = caver.utils.toBuffer(undefined)\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {Buffer|Array.<number>|string|number|BN|BigNumber|object} input The value to be converted to a Buffer.\r\n * @return {Buffer} The value converted to Buffer type is returned.\r\n */\r\nconst toBuffer = function(input) {\r\n    if (Buffer.isBuffer(input)) return input\r\n    if (input === null || input === undefined) return Buffer.alloc(0)\r\n    if (Array.isArray(input)) return Buffer.from(input)\r\n    if (isBigNumber(input)) input = toBN(input)\r\n    if (isBN(input)) return input.toArrayLike(Buffer)\r\n    if (_.isObject(input)) {\r\n        if (input.toArray && _.isFunction(input.toArray)) return Buffer.from(input.toArray())\r\n        throw new Error('To convert an object to a buffer, the toArray function must be implemented inside the object')\r\n    }\r\n\r\n    switch (typeof input) {\r\n        case 'string':\r\n            if (isHexStrict(input)) return Buffer.from(makeEven(input).replace('0x', ''), 'hex')\r\n            throw new Error(\"Failed to convert string to Buffer. 'toBuffer' function only supports 0x-prefixed hex string\")\r\n        case 'number':\r\n            return numberToBuffer(input)\r\n    }\r\n    throw new Error(`Not supported type with ${input}`)\r\n}\r\n\r\n/**\r\n * This function converts a number to a Buffer.\r\n * The {@link module:utils~toBuffer|caver.utils.toBuffer} has the same behavior as this function when the input is a number.\r\n *\r\n * @example\r\n * const result = caver.utils.numberToBuffer(1)\r\n * const result = caver.utils.numberToBuffer('2')\r\n * const result = caver.utils.numberToBuffer('0x3')\r\n * const result = caver.utils.numberToBuffer(new caver.utils.BN(4))\r\n * const result = caver.utils.numberToBuffer(new caver.utils.BigNumber(4))\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {number|string|BN|BigNumber} num A number to be converted to a Buffer.\r\n * @return {Buffer}\r\n */\r\nconst numberToBuffer = function(num) {\r\n    return Buffer.from(makeEven(numberToHex(num)).replace('0x', ''), 'hex')\r\n}\r\n\r\n/**\r\n * Checks if a given string is a HEX string.\r\n * Difference to {@link module:utils~isHex|caver.utils.isHex} is that it expects HEX to be prefixed with `0x`.\r\n *\r\n * @example\r\n * const result = caver.utils.isHexStrict('0xc1912') // true\r\n * const result = caver.utils.isHexStrict('c1912') // false\r\n * const result = caver.utils.isHexStrict('Hello') // false\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} hex The given HEX string.\r\n * @returns {boolean} `true` if a given string is a HEX string.\r\n */\r\nconst isHexStrict = function(hex) {\r\n    return (_.isString(hex) || _.isNumber(hex)) && /^(-)?0x[0-9a-f]*$/i.test(hex)\r\n}\r\n\r\n/**\r\n * Checks if a given string is a HEX string.\r\n *\r\n * @example\r\n * const result = caver.utils.isHex('0xc1912') // true\r\n * const result = caver.utils.isHex('c1912') // true\r\n * const result = caver.utils.isHex('Hello') // false\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} hex The given HEX string.\r\n * @returns {boolean} `true` if a given parameter is a HEX string.\r\n */\r\nconst isHex = function(hex) {\r\n    return (_.isString(hex) || _.isNumber(hex)) && /^(-0x|0x)?[0-9a-f]*$/i.test(hex)\r\n}\r\n\r\n/**\r\n * Checks if the given string is a hexadecimal transaction hash with or without prefix 0x\r\n * @deprecated since version v1.5.0\r\n * @ignore\r\n * @method isTxHash\r\n * @param {String} txHash given hexadecimal transaction hash\r\n * @return {Boolean}\r\n */\r\nconst isTxHash = txHash => isValidHash(txHash)\r\n\r\n/**\r\n * Returns `true` if the input is in 32-bytes hash format, otherwise it returns `false`.\r\n *\r\n * @example\r\n * const result = caver.utils.isValidHash('0xe9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550') // true\r\n * const result = caver.utils.isValidHash('e9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550') // true\r\n * const result = caver.utils.isValidHash('0x1') // false\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} hash The value to be examined that if it is in 32-bytes hash format or not.\r\n * @return {boolean} `true` means the input is in the format of 32-bytes hash.\r\n */\r\nconst isValidHash = hash => new RegExp(`^(0x|0X)?[0-9a-fA-F]{${HASH_LENGTH - 2}}$`).test(hash)\r\n\r\n/**\r\n * Checks if the given string is a hexadecimal transaction hash that starts with 0x\r\n * @deprecated since version v1.5.0\r\n * @ignore\r\n * @method isTxHashStrict\r\n * @param {String} txHash given hexadecimal transaction hash\r\n * @return {Boolean}\r\n */\r\nconst isTxHashStrict = txHash => isValidHashStrict(txHash)\r\n\r\n/**\r\n * Returns `true` if the input is in 0x-prefixed 32-bytes hash format, otherwise it returns `false`.\r\n * This function only looks at the input and determines if it is in the format of 0x-prefixed 32-bytes hash.\r\n * Difference to {@link module:utils~isValidHash|caver.utils.isValidHash} is that it expects HEX to be prefixed with 0x.\r\n *\r\n * @example\r\n * const result = caver.utils.isValidHashStrict('0xe9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550') // true\r\n * const result = caver.utils.isValidHashStrict('e9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550') // false\r\n * const result = caver.utils.isValidHashStrict('0x1') // false\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} hash The value to be examined that if it is in the format of 0x-prefixed 32-bytes hash or not.\r\n * @return {boolean} `true` means the input is in the format of 0x-prefixed 32-bytes hash.\r\n */\r\nconst isValidHashStrict = hash => new RegExp(`^(0x|0X)[0-9a-fA-F]{${HASH_LENGTH - 2}}$`).test(hash)\r\n\r\n/**\r\n * Returns `true` if the bloom is a valid bloom.\r\n *\r\n * @example\r\n * const result = caver.utils.isBloom('0x00000...')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} bloom An encoded bloom filter.\r\n * @return {boolean} `true` means the input bloom parameter is valid.\r\n */\r\nconst isBloom = function(bloom) {\r\n    if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {\r\n        return false\r\n    }\r\n    if (/^(0x)?[0-9a-f]{512}$/.test(bloom) || /^(0x)?[0-9A-F]{512}$/.test(bloom)) {\r\n        return true\r\n    }\r\n    return false\r\n}\r\n\r\n/**\r\n * Returns `true` if the topic is valid.\r\n *\r\n * @example\r\n * const result = caver.utils.isBloom('0x00000...')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} hex An encoded topic.\r\n * @return {boolean}\r\n */\r\nconst isTopic = function(topic) {\r\n    if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {\r\n        return false\r\n    }\r\n    if (/^(0x)?[0-9a-f]{64}$/.test(topic) || /^(0x)?[0-9A-F]{64}$/.test(topic)) {\r\n        return true\r\n    }\r\n    return false\r\n}\r\n\r\nconst parsePredefinedBlockNumber = blockNumber => {\r\n    switch (blockNumber) {\r\n        case 'genesis':\r\n        case 'earliest':\r\n            return '0x0'\r\n        default:\r\n            return blockNumber\r\n    }\r\n}\r\n\r\n/**\r\n * Returns `true` if the parameter is predefined block tag.\r\n *\r\n * @example\r\n * const result = caver.utils.isPredefinedBlockNumber('latest') // true\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} predefinedBlock The predefined block.\r\n * @return {boolean} `true` means predefinedBlock is valid predefined block tag.\r\n */\r\nconst isPredefinedBlockNumber = function(predefinedBlock) {\r\n    return predefinedBlock === 'latest' || predefinedBlock === 'pending' || predefinedBlock === 'earliest' || predefinedBlock === 'genesis'\r\n}\r\n\r\n/**\r\n * Validtes block number (or block tag string).\r\n *\r\n * The block number should be one of a type below:\r\n * 1) predefined block number ex:) 'latest', 'earliest', 'pending', 'genesis'\r\n * 2) hex\r\n * 3) finite number\r\n *\r\n * @example\r\n * const result = caver.utils.isValidBlockNumberCandidate('latest') // true\r\n * const result = caver.utils.isValidBlockNumberCandidate('0x1') // true\r\n * const result = caver.utils.isValidBlockNumberCandidate('1') // true\r\n * const result = caver.utils.isValidBlockNumberCandidate(1) // true\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param  {string|number} blockNumber The block number to validate. This can be block number in number type or block tag(`latest`, `pending`, `earliest`, `genesis`) string.\r\n * @return {boolean} `true` means blockNumber is valid.\r\n */\r\nconst isValidBlockNumberCandidate = blockNumber => {\r\n    return isPredefinedBlockNumber(blockNumber) || isHexStrict(blockNumber) || Number.isFinite(Number(blockNumber))\r\n}\r\n\r\n/**\r\n * Hashes values to a sha3 hash using keccak 256\r\n *\r\n * To hash a HEX string the hex must have 0x in front.\r\n *\r\n * @return {String} the sha3 string\r\n */\r\nconst SHA3_NULL_S = '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\r\n\r\n/**\r\n * Calculates the sha3 of the input.\r\n *\r\n * @example\r\n * const hash = caver.utils.sha3('234')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} str - A string to hash.\r\n * @return {string} The result hash.\r\n */\r\nconst sha3 = function(value) {\r\n    // return null when value is not string type.\r\n    if (typeof value === 'number') return null\r\n\r\n    if (isHexStrict(value) && /^0x/i.test(value.toString())) {\r\n        value = hexToBytes(value)\r\n    }\r\n\r\n    if (isBN(value)) {\r\n        value = value.toString(10)\r\n    }\r\n\r\n    const returnValue = Hash.keccak256(value)\r\n\r\n    if (returnValue === SHA3_NULL_S) {\r\n        return null\r\n    }\r\n    return returnValue\r\n}\r\n// expose the under the hood keccak256\r\nsha3._Hash = Hash\r\n\r\n/**\r\n * An object defines the AccountKeyLegacy.\r\n *\r\n * @example\r\n * { privateKey: '0x{private key}', address: '0x{address in hex}', type: '0x00' }\r\n *\r\n * @typedef {object} module:utils.ParsedPrivateKey\r\n * @property {string} privateKey - The private key string.\r\n * @property {string} address - The address string.\r\n * @property {string} type - The type string. Currently only `0x00` is supported.\r\n */\r\n/**\r\n * Parses private key string to { privateKey, address, type }.\r\n *\r\n * @example\r\n * const { privateKey, address, type } = caver.utils.parsePrivateKey('0x45a915e4d060149eb4365960e6a7a45f334393093061116b197e3240065ff2d8')\r\n * const { privateKey, address, type } = caver.utils.parsePrivateKey('0x45a915e4d060149eb4365960e6a7a45f334393093061116b197e3240065ff2d80x000xa94f5374fce5edbc8e2a8697c15331677e6ebf0b')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} privateKey - A private key or KlaytnWalletKey string to parse.\r\n * @return {module:utils.ParsedPrivateKey} A parsed private key object.\r\n */\r\nfunction parsePrivateKey(privateKey) {\r\n    if (typeof privateKey !== 'string') throw new Error('The private key must be of type string')\r\n\r\n    const has0xPrefix = privateKey.slice(0, 2) === '0x'\r\n    privateKey = has0xPrefix ? privateKey.slice(2) : privateKey\r\n\r\n    if (privateKey.length !== 110 && privateKey.length !== 64) {\r\n        throw new Error(`Invalid private key(${privateKey})`)\r\n    }\r\n\r\n    const parsedPrivateKey = privateKey.slice(0, 64)\r\n\r\n    if (!isHex(parsedPrivateKey)) {\r\n        throw new Error('Invalid private key format : privateKey must be in hex format.')\r\n    }\r\n\r\n    if (privateKey.length !== 110) {\r\n        return {\r\n            privateKey: `0x${privateKey}`,\r\n            address: '',\r\n            type: '',\r\n        }\r\n    }\r\n\r\n    const type = privateKey.slice(66, 68)\r\n    if (type !== '00') throw new Error('Invalid type: Currently only type `0x00` is supported.')\r\n\r\n    if (!isKlaytnWalletKey(privateKey)) throw new Error(`Invalid KlaytnWalletKey format.`)\r\n\r\n    const parsedAddress = privateKey.slice(68)\r\n    return {\r\n        privateKey: `0x${parsedPrivateKey}`,\r\n        address: parsedAddress,\r\n        type: `0x${type}`,\r\n    }\r\n}\r\n\r\n/**\r\n * Parses KlatynWalletKey to [ '0x{privateKey}', '0x{type}', '0x{address}' ].\r\n *\r\n * @example\r\n * const parsed = caver.utils.parseKlaytnWalletKey('0x45a915e4d060149eb4365960e6a7a45f334393093061116b197e3240065ff2d80x000xa94f5374fce5edbc8e2a8697c15331677e6ebf0b')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} key - A KlaytnWalletKey string to parse.\r\n * @return {Array.<string>} An array that includes parsed KlaytnWalletKey.\r\n */\r\nfunction parseKlaytnWalletKey(key) {\r\n    if (!isKlaytnWalletKey(key)) throw new Error(`Invalid KlaytnWalletKey format: ${key}`)\r\n    const klaytnWalletKey = key.startsWith('0x') ? key.slice(2) : key\r\n    const splitted = klaytnWalletKey.split('0x')\r\n    return [`0x${splitted[0]}`, `0x${splitted[1]}`, `0x${splitted[2]}`]\r\n}\r\n\r\n/**\r\n * Validate a KlaytnWalletKey string.\r\n *\r\n * @example\r\n * const result = caver.utils.isKlaytnWalletKey('0x45a915e4d060149eb4365960e6a7a45f334393093061116b197e3240065ff2d80x000xa94f5374fce5edbc8e2a8697c15331677e6ebf0b')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} privateKey - A KlaytnWalletKey string to validate.\r\n * @return {boolean} `true` means valid KlaytnWalletKey.\r\n */\r\nconst isKlaytnWalletKey = privateKey => {\r\n    if (!_.isString(privateKey)) return false\r\n\r\n    const has0xPrefix = privateKey.slice(0, 2) === '0x'\r\n    privateKey = has0xPrefix ? privateKey.slice(2) : privateKey\r\n\r\n    if (privateKey.length !== 110) {\r\n        return false\r\n    }\r\n\r\n    const splited = privateKey.split('0x')\r\n    if (splited.length !== 3) return false\r\n\r\n    for (let i = 0; i < splited.length; i++) {\r\n        if (!isHex(splited[i])) return false\r\n        switch (i) {\r\n            case 0:\r\n                if (splited[i].length !== 64 || !isValidPrivateKey(splited[i])) return false\r\n                break\r\n            case 1:\r\n                if (splited[i].length !== 2 || splited[i] !== '00') return false\r\n                break\r\n            case 2:\r\n                if (splited[i].length !== 40 || !isAddress(splited[i])) return false\r\n                break\r\n        }\r\n    }\r\n\r\n    return true\r\n}\r\n\r\n/**\r\n * Validate a private key string.\r\n *\r\n * @example\r\n * const result = caver.utils.isValidPrivateKey('0x45a915e4d060149eb4365960e6a7a45f334393093061116b197e3240065ff2d8')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} privateKey - A private key string to validate.\r\n * @return {boolean} `true` means valid private key.\r\n */\r\nfunction isValidPrivateKey(privateKey) {\r\n    if (typeof privateKey !== 'string') return false\r\n\r\n    const has0xPrefix = privateKey.slice(0, 2) === '0x'\r\n    privateKey = has0xPrefix ? privateKey.slice(2) : privateKey\r\n    // Private key validation 1: private key should be string and minimum length of it is 64.\r\n    if (privateKey.length !== 64 || !isHex(privateKey)) return false\r\n\r\n    // order n value in secp256k1. privateKey should be less than order n value.\r\n    const VALID_PRIVATE_KEY_LIMIT = 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141'\r\n    const VALID_PRIVATE_LOWER_BOUND = '0000000000000000000000000000000000000000000000000000000000000000'\r\n    return VALID_PRIVATE_LOWER_BOUND < privateKey.toUpperCase() && privateKey.toUpperCase() < VALID_PRIVATE_KEY_LIMIT\r\n}\r\n\r\n// Check is 1)Number string or 2)Hex string or 3)Number.\r\nfunction isValidNSHSN(value) {\r\n    switch (typeof value) {\r\n        case 'number':\r\n            if (value < 0) {\r\n                return false\r\n            }\r\n            break\r\n        case 'string':\r\n            if (Number(value) != value && !isHexStrict(value)) {\r\n                return false\r\n            }\r\n            break\r\n        default:\r\n            return false\r\n    }\r\n\r\n    return true\r\n}\r\n\r\nconst rlpEncode = data => RLP.encode(data)\r\n\r\nconst rlpDecode = encodedData => RLP.decode(encodedData)\r\n\r\n/**\r\n * Converts from public key to x, y points.\r\n *\r\n * @example\r\n * const result = caver.utils.xyPointFromPublicKey('0x04019b186993b620455077b6bc37bf61666725d8d87ab33eb113ac0414cd48d78ff46e5ea48c6f22e8f19a77e5dbba9d209df60cbcb841b7e3e81fe444ba829831')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} publicKey - A public key string.\r\n * @return {Array.<string>} An array with x, y points.\r\n */\r\nconst xyPointFromPublicKey = pub => {\r\n    let publicKey = pub\r\n    if (isCompressedPublicKey(publicKey)) publicKey = decompressPublicKey(pub)\r\n\r\n    publicKey = publicKey.replace('0x', '')\r\n    if (publicKey.length === 130 && publicKey.slice(0, 2) === '04') publicKey = publicKey.slice(2)\r\n    if (publicKey.length !== 128) throw Error('Invalid public key') // + 2 means '0x'\r\n\r\n    const pubX = `0x${publicKey.slice(0, 64).replace(/^0+/, '')}`\r\n    const pubY = `0x${publicKey.slice(64).replace(/^0+/, '')}`\r\n    return [pubX, pubY]\r\n}\r\n\r\n/**\r\n * Trims leading zero from 0x-prefixed hex string.\r\n *\r\n * @example\r\n * const result = caver.utils.trimLeadingZero('0x0000011') // '0x11'\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} hex - A hex string to trim.\r\n * @return {string} A hex string without leading zero.\r\n */\r\nconst trimLeadingZero = function(hex) {\r\n    while (hex && hex.startsWith('0x0')) {\r\n        hex = `0x${hex.slice(3)}`\r\n    }\r\n    return hex\r\n}\r\n\r\n/**\r\n * Returns a string to an even length.\r\n *\r\n * @example\r\n * const result = caver.utils.makeEven('0x011') // '0x0011'\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} hex - A hex string to make even.\r\n * @return {string} A string with even length.\r\n */\r\nconst makeEven = function(hex) {\r\n    if (hex.length % 2 === 1) {\r\n        hex = hex.replace('0x', '0x0')\r\n    }\r\n    return hex\r\n}\r\n\r\n/**\r\n * Converts the signature to an array format.\r\n *\r\n * @example\r\n * const result = caver.utils.resolveSignature({ v: '0x0fe9', r: '0x02aca...', s: '0x20502...' })\r\n * const result = caver.utils.resolveSignature({ V: '0x0fe9', R: '0x02aca...', S: '0x20502...' })\r\n * const result = caver.utils.resolveSignature('0x7e85aaff6a6ef0730308af49f6b512741e61f958a21df387a0d0e8973fb40ca0307a8b87f6ac249f7218b4ee1a1d2f7d764ec2d20d9824e7b7b842dd214f139c7f6')\r\n *\r\n * @ignore\r\n * @param {string|object|Array.<string>|SignatureData} signature A signature string, object or array.\r\n * @return {Array.<string>} A signature array.\r\n */\r\nconst resolveSignature = signature => {\r\n    if (_.isArray(signature)) {\r\n        const [v, r, s] = signature\r\n        return [v, r, s]\r\n    }\r\n\r\n    if (_.isObject(signature)) {\r\n        const v = signature.V || signature.v\r\n        const r = signature.R || signature.r\r\n        const s = signature.S || signature.s\r\n        if (!v || !r || !s) throw new Error('v, r, s fields should exist in signature')\r\n\r\n        return [v, r, s]\r\n    }\r\n\r\n    if (_.isString(signature)) {\r\n        const v = `0x${signature.slice(64 * 2 + 2)}`\r\n        const decoded = Account.decodeSignature(signature)\r\n        return [v, decoded[1], decoded[2]]\r\n    }\r\n}\r\n\r\n/**\r\n * Converts the signature to an `{ V, R, S }` format.\r\n * Klaytn Node uses `{ V, R, S }` format, so you can use this function to convert caver signature format to `{ V, R, S }`.\r\n *\r\n * @example\r\n * const result = caver.utils.transformSignaturesToObject([\r\n *     '0x7f6',\r\n *     '0x7e85aaff6a6ef0730308af49f6b512741e61f958a21df387a0d0e8973fb40ca0',\r\n *     '0x307a8b87f6ac249f7218b4ee1a1d2f7d764ec2d20d9824e7b7b842dd214f139c'\r\n * ])\r\n *\r\n * @ignore\r\n * @param {string|object|Array.<string>|SignatureData} signature A signature string, object or array.\r\n * @return {Klay.SignatureData} A signature object.\r\n */\r\nconst transformSignaturesToObject = signatures => {\r\n    let isSingular = false\r\n\r\n    if (!signatures) throw new Error(`Failed to transform signatures to object: invalid signatures ${signatures}`)\r\n\r\n    // Input cases\r\n    // case 1. '0xf1998...'\r\n    // case 2. {V: '0x4e44', R: '0x1692a...', S: '0x277b9...'} or {v: '0x4e44', r: '0x1692a...', s: '0x277b9...'}\r\n    // case 3. ['0xf1998...', '0x53fe7...']\r\n    // case 4. ['0x4e44', '0x1692a...', '0x277b9...']\r\n    // case 5. [{V: '0x4e44', R: '0x1692a...', S: '0x277b9...'}, {v: '0x4e44', r: '0x1692a...', s: '0x277b9...'}]\r\n    // case 6. [['0x4e44', '0x1692a...', '0x277b9...'], ['0x4e44', '0x1692a...', '0x277b9...']]\r\n\r\n    // Transform a signature to an array of signatures to execute the same logic in the for loop below.\r\n    if (!_.isArray(signatures)) {\r\n        signatures = [signatures]\r\n        isSingular = true\r\n    } else if (_.isString(signatures[0])) {\r\n        // This logic is performed for case 3 and case 4.\r\n        // In case 3, the signature string is in the array.\r\n        // In case 4, v, r, and s are separately included in the array.\r\n        // The signature string is a combination of v, r, and s, so the length of the signature string will be longer than 64.\r\n        // Hence, only case 4 will perform the below logic to form an array of signatures.\r\n        const stripped = signatures[0].replace('0x', '')\r\n        if (stripped.length <= 64) {\r\n            signatures = [signatures]\r\n            isSingular = true\r\n        }\r\n    }\r\n\r\n    const ret = []\r\n\r\n    for (const sig of signatures) {\r\n        const sigObj = {}\r\n        if (_.isArray(sig)) {\r\n            if (sig.length !== 3) throw new Error(`Failed to transform signatures to object: invalid length of signature (${sig.length})`)\r\n            if (isEmptySig(sig)) continue\r\n            const [V, R, S] = sig\r\n            sigObj.V = V\r\n            sigObj.R = R\r\n            sigObj.S = S\r\n        } else if (_.isString(sig)) {\r\n            const decoded = Account.decodeSignature(sig).map(s => makeEven(trimLeadingZero(s)))\r\n            sigObj.V = decoded[0]\r\n            sigObj.R = decoded[1]\r\n            sigObj.S = decoded[2]\r\n        } else if (_.isObject(sig)) {\r\n            Object.keys(sig).map(key => {\r\n                if (key === 'v' || key === 'V' || key === '_v') {\r\n                    sigObj.V = sig[key]\r\n                } else if (key === 'r' || key === 'R' || key === '_r') {\r\n                    sigObj.R = sig[key]\r\n                } else if (key === 's' || key === 'S' || key === '_s') {\r\n                    sigObj.S = sig[key]\r\n                } else {\r\n                    throw new Error(`Failed to transform signatures to object: invalid key(${key}) is defined in signature object.`)\r\n                }\r\n            })\r\n        } else {\r\n            throw new Error(`Unsupported signature type: ${typeof sig}`)\r\n        }\r\n\r\n        if (!sigObj.V || !sigObj.R || !sigObj.S) {\r\n            throw new Error(`Failed to transform signatures to object: invalid signature ${sig}`)\r\n        }\r\n\r\n        Object.keys(sigObj).map(k => {\r\n            sigObj[k] = trimLeadingZero(sigObj[k])\r\n        })\r\n        ret.push(sigObj)\r\n    }\r\n\r\n    return isSingular ? ret[0] : ret\r\n}\r\n\r\n/**\r\n * Returns tx type string.\r\n * This function uses an old type string.\r\n *\r\n * @example\r\n * const result = caver.utils.getTxTypeStringFromRawTransaction('0x08f83a808505d21dba00824e20945b2840bcbc2be07fb12d9129ed3a02d8e446594401945b2840bcbc2be07fb12d9129ed3a02d8e4465944c4c3018080')\r\n *\r\n * @deprecated\r\n * @ignore\r\n * @param {string} rawTransaction An RLP-encoded transaction string.\r\n * @return {string} A transaction type string.\r\n */\r\nconst getTxTypeStringFromRawTransaction = rawTransaction => {\r\n    if (typeof rawTransaction !== 'string') throw new Error('Invalid raw Tx', rawTransaction)\r\n\r\n    const type = rawTransaction.slice(0, 4)\r\n\r\n    const typeString = txTypeToString[type]\r\n\r\n    return typeString\r\n}\r\n\r\n/**\r\n * Returns tx type string.\r\n * This function uses an old type string.\r\n *\r\n * @example\r\n * const result = caver.utils.isValidPublicKey('0x3a06fcf2eb4f096e01bc70ab2c81ba79e82af9c62a3ef5fe1fef329c3ad89e8622aed245899ffa530ddd8ebf1a0a66f157b75a38a715f82ad6061af36cbd9cd8')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} rawTransaction An RLP-encoded transaction string.\r\n * @return {string} A transaction type string.\r\n */\r\nconst isValidPublicKey = publicKey => {\r\n    let pubString = publicKey.replace('0x', '')\r\n\r\n    if (pubString.length === 130 && pubString.slice(0, 2) === '04') pubString = pubString.slice(2)\r\n\r\n    if (pubString.length !== 66 && pubString.length !== 128) return false\r\n\r\n    if (pubString.length === 66 && !isCompressedPublicKey(pubString)) return false\r\n\r\n    if (pubString.length === 66) pubString = decompressPublicKey(pubString)\r\n\r\n    const xyPoints = xyPointFromPublicKey(pubString)\r\n    if (xyPoints === undefined || !xyPoints.length || xyPoints.length !== 2) return false\r\n\r\n    const point = secp256k1.curve.point(xyPoints[0].slice(2), xyPoints[1].slice(2), true)\r\n    return secp256k1.keyFromPublic(point).validate().result\r\n}\r\n\r\n/**\r\n * Return `true` is public key is compressed, otherwise `false`.\r\n *\r\n * @example\r\n * const result = caver.utils.isCompressedPublicKey('0x023a06fcf2eb4f096e01bc70ab2c81ba79e82af9c62a3ef5fe1fef329c3ad89e86')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} publicKey A public key string.\r\n * @return {boolean} `true` means compressed.\r\n */\r\nconst isCompressedPublicKey = publicKey => {\r\n    const compressedIndicators = ['02', '03']\r\n    const withoutPrefix = publicKey.replace('0x', '')\r\n    return withoutPrefix.length === 66 && compressedIndicators.includes(withoutPrefix.slice(0, 2))\r\n}\r\n\r\n/**\r\n * Compresses the uncompressed public key.\r\n *\r\n * @example\r\n * const result = caver.utils.compressPublicKey('0x62cef87819b82f62e9c0a38c1fa7dfa089084959df86aca19ff2f6c903db2248b45dc23220ee6bcd8753bb9df8ce7d58e56eabebb14479f3a0ca5ccd4bdea632')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} publicKey A public key string.\r\n * @return {string} A compressed public key.\r\n */\r\nconst compressPublicKey = uncompressedPublicKey => {\r\n    const isAlreadyCompressed = isCompressedPublicKey(uncompressedPublicKey)\r\n\r\n    if (isAlreadyCompressed) return uncompressedPublicKey\r\n\r\n    const xyPoints = xyPointFromPublicKey(uncompressedPublicKey)\r\n\r\n    if (xyPoints === undefined || !xyPoints.length || xyPoints.length !== 2) {\r\n        throw new Error('invalid public key')\r\n    }\r\n\r\n    const [x, y] = xyPoints\r\n\r\n    const keyPair = secp256k1.keyPair({\r\n        pub: {\r\n            x: x.replace('0x', ''),\r\n            y: y.replace('0x', ''),\r\n        },\r\n        pubEnc: 'hex',\r\n    })\r\n\r\n    const compressedPublicKey = `0x${keyPair.getPublic(true, 'hex')}`\r\n\r\n    return compressedPublicKey\r\n}\r\n\r\n/**\r\n * Decompresses the compressed public key.\r\n *\r\n * @example\r\n * const result = caver.utils.decompressPublicKey('0x0262cef87819b82f62e9c0a38c1fa7dfa089084959df86aca19ff2f6c903db2248')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} publicKey A public key string.\r\n * @return {string} A uncompressed public key.\r\n */\r\nconst decompressPublicKey = compressedPublicKey => {\r\n    if (!isCompressedPublicKey(compressedPublicKey)) {\r\n        if (!isValidPublicKey(compressedPublicKey)) throw new Error(`Invalid public key`)\r\n        return compressedPublicKey\r\n    }\r\n\r\n    const compressedWithoutPrefix = compressedPublicKey.replace('0x', '')\r\n\r\n    const curve = secp256k1.curve\r\n    const decoded = curve.decodePoint(compressedWithoutPrefix, 'hex')\r\n    const hexEncoded = decoded.encode('hex').slice(2)\r\n\r\n    return `0x${hexEncoded}`\r\n}\r\n\r\nconst isContractDeployment = txObject => {\r\n    if (txObject.type) {\r\n        if (txObject.type.includes('SMART_CONTRACT_DEPLOY') || txObject.type.includes('SmartContractDeploy')) return true\r\n        if (txObject.type !== 'LEGACY' && txObject.type !== 'TxTypeLegacyTransaction') return false\r\n    }\r\n\r\n    if (txObject.data && txObject.data !== '0x' && (!txObject.to || txObject.to === '0x')) return true\r\n\r\n    return false\r\n}\r\n\r\nconst isValidRole = role => {\r\n    switch (role) {\r\n        case 'roleTransactionKey':\r\n        case 'roleAccountUpdateKey':\r\n        case 'roleFeePayerKey':\r\n        case 'transactionKey':\r\n        case 'updateKey':\r\n        case 'feePayerKey':\r\n            return true\r\n    }\r\n    return false\r\n}\r\n\r\n// ['0x01', '0x', '0x]\r\n// [['0x01', '0x', '0x]]\r\n// '0x....'\r\n// { v: '0x01', r: '0x', s:'0x' }\r\n// SignatureData { _v: '0x01', _r: '0x', _s:'0x' }\r\n// [SignatureData { _v: '0x01', _r: '0x', _s:'0x' }]\r\n/**\r\n * Returns `true` if sig is in the format of empty signature (`SignatureData { _v: '0x01', _r: '0x', _s: '0x' }` or `[SignatureData { _v: '0x01', _r: '0x', _s: '0x' }]`), otherwise it returns `false`.\r\n *\r\n * In caver-js, if signatures or feePayerSignatures is empty, the value representing an empty signature, `[SignatureData { _v: '0x01', _r: '0x', _s: '0x' }]`, is returned for the property.\r\n * This function is used to check whether the given signature is `[SignatureData { _v: '0x01', _r: '0x', _s: '0x' }]` (or `SignatureData { _v: '0x01', _r: '0x', _s: '0x' }` in the 'LEGACY' transaction).\r\n *\r\n * @example\r\n * const result = caver.utils.isEmptySig(['0x01', '0x', '0x'])\r\n * const result = caver.utils.isEmptySig({ v: '0x01', r: '0x', s: '0x' })\r\n * const result = caver.utils.isEmptySig({ V: '0x01', R: '0x', S: '0x' })\r\n * const result = caver.utils.isEmptySig(new caver.wallet.keyring.signatureData(['0x01', '0x', '0x']))\r\n *\r\n * const result = caver.utils.isEmptySig([['0x01', '0x', '0x']])\r\n * const result = caver.utils.isEmptySig([{ v: '0x01', r: '0x', s: '0x' }])\r\n * const result = caver.utils.isEmptySig([{ V: '0x01', R: '0x', S: '0x' }])\r\n * const result = caver.utils.isEmptySig([new caver.wallet.keyring.signatureData(['0x01', '0x', '0x'])])\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {object|Array.<object>|Array.<string>|Array.<Array.<string>>|SignatureData|Array.<SignatureData>} sig An instance of {@link SignatureData} or array of {@link SignatureData} to check empty or not.\r\n * @return {boolean} `true` means the sig is empty.\r\n */\r\nconst isEmptySig = sig => {\r\n    let sigs = sig\r\n\r\n    // Convert to array format\r\n    if (!_.isArray(sig)) sigs = resolveSignature(sigs)\r\n    // Format to two-dimentional array\r\n    if (_.isString(sigs[0])) sigs = [sigs]\r\n\r\n    for (let s of sigs) {\r\n        if (!_.isArray(s)) s = resolveSignature(s)\r\n        if (s.length !== 3) throw new Error(`Invalid signatures length: ${s.length}`)\r\n        if (s[0] !== '0x01' || s[1] !== '0x' || s[2] !== '0x') return false\r\n    }\r\n\r\n    return true\r\n}\r\n\r\n/**\r\n * Hashes message with Klaytn specific prefix: `keccak256(\"\\x19Klaytn Signed Message:\\n\" + len(message) + message))`\r\n *\r\n * @example\r\n * const result = caver.utils.hashMessage('Hello') // '0x640bfab59b6e27468abd367888f4ab1a1c77aa2b45e76a1d3adcbd039c305917'\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} data A message to hash. If it is a HEX string, it will be UTF-8 decoded first.\r\n * @return {string} The hashed message with Klaytn specific prefix.\r\n */\r\nconst hashMessage = data => {\r\n    const message = isHexStrict(data) ? hexToBytes(data) : data\r\n    const messageBuffer = Buffer.from(message)\r\n    const preamble = `\\x19Klaytn Signed Message:\\n${message.length}`\r\n    const preambleBuffer = Buffer.from(preamble)\r\n    // klayMessage is concatenated buffer (preambleBuffer + messageBuffer)\r\n    const klayMessage = Buffer.concat([preambleBuffer, messageBuffer])\r\n    // Finally, run keccak256 on klayMessage.\r\n    return Hash.keccak256(klayMessage)\r\n}\r\n\r\n/**\r\n * Recovers the public key that was used to sign the given data.\r\n *\r\n * @example\r\n * const message = 'Some data'\r\n * const signature = { v: '0x1c', r: '0xd0b8d...', s: '0x5472e...' } // You can get a signature via `keyring.signMessage(...).signatures[0]`.\r\n * const recoveredPublicKey = caver.utils.recoverPublicKey(message, signature)\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} message The raw message string. If this message is hased with Klaytn specific prefix, the third parameter should be passed as `true`.\r\n * @param {SignatureData|Array.<string>|object} signature An instance of `SignatureData`, `[v, r, s]` or `{v, r, s}`.\r\n * @param {boolean} [isHashed] (optional, default: `false`) If the `isHashed` is true, the given message will NOT automatically be prefixed with \"\\x19Klaytn Signed Message:\\n\" + message.length + message, and be assumed as already prefixed.\r\n * @return {string}\r\n */\r\nconst recoverPublicKey = (message, signature, isHashed = false) => {\r\n    if (!isHashed) message = hashMessage(message)\r\n\r\n    if (_.isArray(signature)) signature = { v: signature[0], r: signature[1], s: signature[2] }\r\n    const vrs = { v: parseInt(signature.v.slice(2), 16), r: signature.r.slice(2), s: signature.s.slice(2) }\r\n\r\n    const ecPublicKey = secp256k1.recoverPubKey(Buffer.from(message.slice(2), 'hex'), vrs, vrs.v < 2 ? vrs.v : 1 - (vrs.v % 2))\r\n    return `0x${ecPublicKey.encode('hex', false).slice(2)}`\r\n}\r\n\r\n/**\r\n * Recovers the Klaytn address that was used to sign the given data.\r\n *\r\n * @example\r\n * const message = 'Some data'\r\n * const signature = { v: '0x1c', r: '0xd0b8d...', s: '0x5472e...' } // You can get a signature via `keyring.signMessage(...).signatures[0]`.\r\n * const recoveredPublicKey = caver.utils.recover(message, signature)\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @param {string} message The raw message string. If this message is hased with Klaytn specific prefix, the third parameter should be passed as `true`.\r\n * @param {SignatureData|Array.<string>|object} signature An instance of `SignatureData`, `[v, r, s]` or `{v, r, s}`.\r\n * @param {boolean} [isHashed] (optional, default: `false`) If the `isHashed` is true, the given message will NOT automatically be prefixed with \"\\x19Klaytn Signed Message:\\n\" + message.length + message, and be assumed as already prefixed.\r\n * @return {string}\r\n */\r\nconst recover = (message, signature, isHashed = false) => {\r\n    if (!isHashed) {\r\n        message = hashMessage(message)\r\n    }\r\n\r\n    return Account.recover(message, Account.encodeSignature(resolveSignature(signature))).toLowerCase()\r\n}\r\n\r\n/**\r\n * Returns an address which is derived by a public key.\r\n * This function simply converts the public key string into address form by hashing it.\r\n * It has nothing to do with the actual account in the Klaytn.\r\n *\r\n * @example\r\n * const address = caver.utils.publicKeyToAddress('0x{public key}')\r\n *\r\n * @memberof module:utils\r\n * @inner\r\n *\r\n * @method publicKeyToAddress\r\n * @param {string} pubKey The public key string to get the address.\r\n * @return {string}\r\n */\r\nconst publicKeyToAddress = pubKey => {\r\n    let publicKey = pubKey.slice(0, 2) === '0x' ? pubKey : `0x${pubKey}`\r\n\r\n    if (isCompressedPublicKey(publicKey)) publicKey = decompressPublicKey(publicKey)\r\n\r\n    // With '0x' prefix, 65 bytes in uncompressed format.\r\n    if (Buffer.byteLength(publicKey, 'hex') !== 65) throw new Error(`Invalid public key: ${pubKey}`)\r\n\r\n    const publicHash = Hash.keccak256(publicKey)\r\n    const address = `0x${publicHash.slice(-40)}`\r\n\r\n    const addressHash = Hash.keccak256s(address.slice(2))\r\n    let checksumAddress = '0x'\r\n    for (let i = 0; i < 40; i++) checksumAddress += parseInt(addressHash[i + 2], 16) > 7 ? address[i + 2].toUpperCase() : address[i + 2]\r\n    return checksumAddress\r\n}\r\n\r\nmodule.exports = {\r\n    BN: BN,\r\n    isBN: isBN,\r\n    BigNumber: BigNumber,\r\n    isBigNumber: isBigNumber,\r\n    toBN: toBN,\r\n    isAddress: isAddress,\r\n    isBloom: isBloom, // TODO UNDOCUMENTED\r\n    isTopic: isTopic, // TODO UNDOCUMENTED\r\n    checkAddressChecksum: checkAddressChecksum,\r\n    utf8ToHex: utf8ToHex,\r\n    hexToUtf8: hexToUtf8,\r\n    hexToNumber: hexToNumber,\r\n    hexToNumberString: hexToNumberString,\r\n    numberToHex: numberToHex,\r\n    toHex: toHex,\r\n    bufferToHex: bufferToHex,\r\n    toBuffer: toBuffer,\r\n    numberToBuffer: numberToBuffer,\r\n    hexToBytes: hexToBytes,\r\n    bytesToHex: bytesToHex,\r\n    isHex: isHex,\r\n    isHexStrict: isHexStrict,\r\n    leftPad: leftPad,\r\n    rightPad: rightPad,\r\n    toTwosComplement: toTwosComplement,\r\n    sha3: sha3,\r\n    parsePredefinedBlockNumber: parsePredefinedBlockNumber,\r\n    isPredefinedBlockNumber: isPredefinedBlockNumber,\r\n    isValidBlockNumberCandidate: isValidBlockNumberCandidate,\r\n    isValidPrivateKey: isValidPrivateKey,\r\n    isValidNSHSN: isValidNSHSN,\r\n    parsePrivateKey: parsePrivateKey,\r\n    parseKlaytnWalletKey: parseKlaytnWalletKey,\r\n    isKlaytnWalletKey: isKlaytnWalletKey,\r\n    isContractDeployment: isContractDeployment,\r\n\r\n    rlpEncode: rlpEncode,\r\n    rlpDecode: rlpDecode,\r\n    xyPointFromPublicKey: xyPointFromPublicKey,\r\n    resolveSignature: resolveSignature,\r\n    transformSignaturesToObject: transformSignaturesToObject,\r\n    getTxTypeStringFromRawTransaction,\r\n    trimLeadingZero,\r\n    makeEven,\r\n    txTypeToString,\r\n    isValidPublicKey,\r\n    isCompressedPublicKey,\r\n    compressPublicKey,\r\n    decompressPublicKey,\r\n    isTxHash,\r\n    isTxHashStrict,\r\n    isValidHash,\r\n    isValidHashStrict,\r\n\r\n    isValidRole: isValidRole,\r\n\r\n    isEmptySig: isEmptySig,\r\n\r\n    hashMessage: hashMessage,\r\n    recover: recover,\r\n    recoverPublicKey: recoverPublicKey,\r\n    publicKeyToAddress: publicKeyToAddress,\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}