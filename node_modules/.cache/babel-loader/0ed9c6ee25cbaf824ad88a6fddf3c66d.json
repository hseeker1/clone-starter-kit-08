{"ast":null,"code":"/* eslint-disable class-methods-use-this */\n\n/*\r\n    Copyright 2020 The caver-js Authors\r\n    This file is part of the caver-js library.\r\n\r\n    The caver-js library is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    The caver-js library is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\r\n*/\nconst lodash = require('lodash');\n\nconst fs = require('fs');\n\nconst ipfsClient = require('ipfs-http-client');\n\nconst multihash = require('multihashes');\n/**\r\n * Representing a class for uploading and loading files to IPFS.\r\n * @hideconstructor\r\n * @class\r\n */\n\n\nclass IPFS {\n  /**\r\n   * Create an IPFS instance.\r\n   * @param {string} [host] The IPFS Node url to connect with.\r\n   * @param {number} [port] The port number to use.\r\n   * @param {boolean} [ssl] With or without SSL. If true, the https protocol is used. Otherwise, the http protocol is used.\r\n   */\n  constructor(host, port, ssl) {\n    if (host !== undefined && port !== undefined && ssl !== undefined) {\n      this.setIPFSNode(host, port, ssl);\n    }\n  }\n  /**\r\n   * Initializes a connection with an IPFS Node.\r\n   * When an IPFS Node information is set through this function, you can upload files to IPFS or load files from IPFS.\r\n   *\r\n   * @example\r\n   * caver.ipfs.setIPFSNode('localhost', 5001, false)\r\n   *\r\n   * @param {string} host The IPFS Node url to connect with.\r\n   * @param {number} port The port number to use.\r\n   * @param {boolean} ssl With or without SSL. If true, the https protocol is used. Otherwise, the http protocol is used.\r\n   * @return {void}\r\n   */\n\n\n  setIPFSNode(host, port, ssl) {\n    const protocol = ssl ? 'https' : 'http';\n    this.ipfs = ipfsClient({\n      host,\n      port,\n      protocol\n    });\n  }\n  /**\r\n   * Adds a file to IPFS. The {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} of the uploaded file is returned.\r\n   * If the path of a file is passed, the contents of the file are loaded from the path and uploaded to IPFS. If a buffer is passed, it is uploaded to IPFS directly.\r\n   *\r\n   * If the `data` parameter is a `Buffer` or `ArrayBuffer`, upload to IPFS directly without using `fs`.\r\n   * If the `data` parameter is a string, use `fs` to read the file.\r\n   * Since `fs` is a module that can only be used on the server side, if it is client-side code,\r\n   * it must read the file in advance and pass the file contents in the format of `ArrayBuffer`.\r\n   *\r\n   * If you get a \"Error: Can't resolve 'fs'\" error when building your client code, add the following to your \"webpack.config.json\" file.\r\n   * ```\r\n   * module.exports = {\r\n   *     ...\r\n   *     node: {\r\n   *         fs: 'empty',\r\n   *     },\r\n   *     ...\r\n   * }\r\n   * ```\r\n   *\r\n   * If you use Next.js web framework(https://nextjs.org/), add the following to your \"next.config.json\" file.\r\n   * ```\r\n   * module.exports = {\r\n   *     ...\r\n   *     webpack: (config, { isServer }) => {\r\n   *         // Fixes npm packages that depend on `fs` module\r\n   *         if (!isServer) {\r\n   *             config.node = {\r\n   *                 fs: 'empty'\r\n   *             }\r\n   *         }\r\n   *         return config\r\n   *     },\r\n   *     ...\r\n   * }\r\n   * ```\r\n   *\r\n   * @example\r\n   * const cid = await caver.ipfs.add('./test.txt')\r\n   * const cid = await caver.ipfs.add(Buffer.from('test data'))\r\n   *\r\n   * @param {string|Buffer|ArrayBuffer} data The file path string or file contents.\r\n   * @return {Promise<string>}\r\n   */\n\n\n  async add(data) {\n    if (!this.ipfs) throw new Error(`Please set IPFS Node through 'caver.ipfs.setIPFSNode'.`); // Read file\n\n    if (lodash.isString(data)) {\n      if (typeof window !== 'undefined') throw new Error(`Cannot use fs module: Please pass the file contents as a parameter of type Buffer or ArrayBuffer.`);\n      data = fs.readFileSync(data);\n    }\n\n    if (!lodash.isBuffer(data) && !lodash.isArrayBuffer(data)) throw new Error(`Invalid data: ${data}`);\n    const ret = await this.ipfs.add(Buffer.from(data));\n    return ret.path;\n  }\n  /**\r\n   * Returns a file addressed by a valid IPFS path.\r\n   *\r\n   * @example\r\n   * const fileContents = await caver.ipfs.get('Qmd9thymMS6mejhEDZfwXPowSDunzgma9ex4ezpCSRZGwC')\r\n   *\r\n   * @param {string} hash An {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} of the file to download.\r\n   * @return {Promise<Buffer>}\r\n   */\n\n\n  async get(hash) {\n    if (!this.ipfs) throw new Error(`Please set IPFS Node through 'caver.ipfs.setIPFSNode'.`);\n    const ret = await this.ipfs.cat(hash);\n    return (await ret.next(0)).value;\n  }\n  /**\r\n   * Converts a {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} to a {@link https://multiformats.io/multihash/|Multihash}.\r\n   *\r\n   * @example\r\n   * // This will return '0x1220dc1dbe0bcf1e5f6cce80bd3d7e7d873801c5a1732add889c0f25391d53470dc3'\r\n   * const multihash = caver.ipfs.toHex('Qmd9thymMS6mejhEDZfwXPowSDunzgma9ex4ezpCSRZGwC')\r\n   *\r\n   * @param {string} hash A {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} to convert.\r\n   * @return {string}\r\n   */\n\n\n  toHex(hash) {\n    const buf = multihash.fromB58String(hash);\n    return `0x${multihash.toHexString(buf)}`;\n  }\n  /**\r\n   * Converts to {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} from a {@link https://multiformats.io/multihash/|Multihash}.\r\n   *\r\n   * @example\r\n   * // This will return 'Qmd9thymMS6mejhEDZfwXPowSDunzgma9ex4ezpCSRZGwC'\r\n   * const multihash = caver.ipfs.fromHex('0x1220dc1dbe0bcf1e5f6cce80bd3d7e7d873801c5a1732add889c0f25391d53470dc3')\r\n   *\r\n   * @param {string} hash A {@link https://multiformats.io/multihash/|Multihash} to convert.\r\n   * @return {string}\r\n   */\n\n\n  fromHex(contentHash) {\n    const hex = contentHash.substring(2);\n    const buf = multihash.fromHexString(hex);\n    return multihash.toB58String(buf);\n  }\n\n}\n\nmodule.exports = IPFS;","map":{"version":3,"names":["lodash","require","fs","ipfsClient","multihash","IPFS","constructor","host","port","ssl","undefined","setIPFSNode","protocol","ipfs","add","data","Error","isString","window","readFileSync","isBuffer","isArrayBuffer","ret","Buffer","from","path","get","hash","cat","next","value","toHex","buf","fromB58String","toHexString","fromHex","contentHash","hex","substring","fromHexString","toB58String","module","exports"],"sources":["C:/Users/User/Documents/clone-starter-kit-08/node_modules/caver-js/packages/caver-ipfs/src/index.js"],"sourcesContent":["/* eslint-disable class-methods-use-this */\r\n/*\r\n    Copyright 2020 The caver-js Authors\r\n    This file is part of the caver-js library.\r\n\r\n    The caver-js library is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    The caver-js library is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst lodash = require('lodash')\r\nconst fs = require('fs')\r\nconst ipfsClient = require('ipfs-http-client')\r\nconst multihash = require('multihashes')\r\n\r\n/**\r\n * Representing a class for uploading and loading files to IPFS.\r\n * @hideconstructor\r\n * @class\r\n */\r\nclass IPFS {\r\n    /**\r\n     * Create an IPFS instance.\r\n     * @param {string} [host] The IPFS Node url to connect with.\r\n     * @param {number} [port] The port number to use.\r\n     * @param {boolean} [ssl] With or without SSL. If true, the https protocol is used. Otherwise, the http protocol is used.\r\n     */\r\n    constructor(host, port, ssl) {\r\n        if (host !== undefined && port !== undefined && ssl !== undefined) {\r\n            this.setIPFSNode(host, port, ssl)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes a connection with an IPFS Node.\r\n     * When an IPFS Node information is set through this function, you can upload files to IPFS or load files from IPFS.\r\n     *\r\n     * @example\r\n     * caver.ipfs.setIPFSNode('localhost', 5001, false)\r\n     *\r\n     * @param {string} host The IPFS Node url to connect with.\r\n     * @param {number} port The port number to use.\r\n     * @param {boolean} ssl With or without SSL. If true, the https protocol is used. Otherwise, the http protocol is used.\r\n     * @return {void}\r\n     */\r\n    setIPFSNode(host, port, ssl) {\r\n        const protocol = ssl ? 'https' : 'http'\r\n        this.ipfs = ipfsClient({ host, port, protocol })\r\n    }\r\n\r\n    /**\r\n     * Adds a file to IPFS. The {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} of the uploaded file is returned.\r\n     * If the path of a file is passed, the contents of the file are loaded from the path and uploaded to IPFS. If a buffer is passed, it is uploaded to IPFS directly.\r\n     *\r\n     * If the `data` parameter is a `Buffer` or `ArrayBuffer`, upload to IPFS directly without using `fs`.\r\n     * If the `data` parameter is a string, use `fs` to read the file.\r\n     * Since `fs` is a module that can only be used on the server side, if it is client-side code,\r\n     * it must read the file in advance and pass the file contents in the format of `ArrayBuffer`.\r\n     *\r\n     * If you get a \"Error: Can't resolve 'fs'\" error when building your client code, add the following to your \"webpack.config.json\" file.\r\n     * ```\r\n     * module.exports = {\r\n     *     ...\r\n     *     node: {\r\n     *         fs: 'empty',\r\n     *     },\r\n     *     ...\r\n     * }\r\n     * ```\r\n     *\r\n     * If you use Next.js web framework(https://nextjs.org/), add the following to your \"next.config.json\" file.\r\n     * ```\r\n     * module.exports = {\r\n     *     ...\r\n     *     webpack: (config, { isServer }) => {\r\n     *         // Fixes npm packages that depend on `fs` module\r\n     *         if (!isServer) {\r\n     *             config.node = {\r\n     *                 fs: 'empty'\r\n     *             }\r\n     *         }\r\n     *         return config\r\n     *     },\r\n     *     ...\r\n     * }\r\n     * ```\r\n     *\r\n     * @example\r\n     * const cid = await caver.ipfs.add('./test.txt')\r\n     * const cid = await caver.ipfs.add(Buffer.from('test data'))\r\n     *\r\n     * @param {string|Buffer|ArrayBuffer} data The file path string or file contents.\r\n     * @return {Promise<string>}\r\n     */\r\n    async add(data) {\r\n        if (!this.ipfs) throw new Error(`Please set IPFS Node through 'caver.ipfs.setIPFSNode'.`)\r\n\r\n        // Read file\r\n        if (lodash.isString(data)) {\r\n            if (typeof window !== 'undefined')\r\n                throw new Error(`Cannot use fs module: Please pass the file contents as a parameter of type Buffer or ArrayBuffer.`)\r\n            data = fs.readFileSync(data)\r\n        }\r\n        if (!lodash.isBuffer(data) && !lodash.isArrayBuffer(data)) throw new Error(`Invalid data: ${data}`)\r\n\r\n        const ret = await this.ipfs.add(Buffer.from(data))\r\n        return ret.path\r\n    }\r\n\r\n    /**\r\n     * Returns a file addressed by a valid IPFS path.\r\n     *\r\n     * @example\r\n     * const fileContents = await caver.ipfs.get('Qmd9thymMS6mejhEDZfwXPowSDunzgma9ex4ezpCSRZGwC')\r\n     *\r\n     * @param {string} hash An {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} of the file to download.\r\n     * @return {Promise<Buffer>}\r\n     */\r\n    async get(hash) {\r\n        if (!this.ipfs) throw new Error(`Please set IPFS Node through 'caver.ipfs.setIPFSNode'.`)\r\n\r\n        const ret = await this.ipfs.cat(hash)\r\n\r\n        return (await ret.next(0)).value\r\n    }\r\n\r\n    /**\r\n     * Converts a {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} to a {@link https://multiformats.io/multihash/|Multihash}.\r\n     *\r\n     * @example\r\n     * // This will return '0x1220dc1dbe0bcf1e5f6cce80bd3d7e7d873801c5a1732add889c0f25391d53470dc3'\r\n     * const multihash = caver.ipfs.toHex('Qmd9thymMS6mejhEDZfwXPowSDunzgma9ex4ezpCSRZGwC')\r\n     *\r\n     * @param {string} hash A {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} to convert.\r\n     * @return {string}\r\n     */\r\n    toHex(hash) {\r\n        const buf = multihash.fromB58String(hash)\r\n        return `0x${multihash.toHexString(buf)}`\r\n    }\r\n\r\n    /**\r\n     * Converts to {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} from a {@link https://multiformats.io/multihash/|Multihash}.\r\n     *\r\n     * @example\r\n     * // This will return 'Qmd9thymMS6mejhEDZfwXPowSDunzgma9ex4ezpCSRZGwC'\r\n     * const multihash = caver.ipfs.fromHex('0x1220dc1dbe0bcf1e5f6cce80bd3d7e7d873801c5a1732add889c0f25391d53470dc3')\r\n     *\r\n     * @param {string} hash A {@link https://multiformats.io/multihash/|Multihash} to convert.\r\n     * @return {string}\r\n     */\r\n    fromHex(contentHash) {\r\n        const hex = contentHash.substring(2)\r\n        const buf = multihash.fromHexString(hex)\r\n        return multihash.toB58String(buf)\r\n    }\r\n}\r\n\r\nmodule.exports = IPFS\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}