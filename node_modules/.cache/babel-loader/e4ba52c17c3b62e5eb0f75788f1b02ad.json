{"ast":null,"code":"/*\r\n    Copyright 2021 The caver-js Authors\r\n    This file is part of the caver-js library.\r\n\r\n    The caver-js library is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    The caver-js library is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\r\n*/\nconst _ = require('lodash');\n\nconst BigNumber = require('bignumber.js');\n\nconst Contract = require('../../caver-contract');\n\nconst {\n  kip37JsonInterface,\n  kip37ByteCode,\n  determineSendParams,\n  formatParamForUint256,\n  validateDeployParameterForKIP37,\n  interfaceIds\n} = require('./kctHelper');\n\nconst {\n  isAddress,\n  toBuffer,\n  isHexStrict,\n  toHex,\n  stripHexPrefix,\n  leftPad\n} = require('../../caver-utils');\n\nconst KIP13 = require('./kip13');\n/**\r\n * The KIP37 class that helps you easily handle a smart contract that implements KIP-37 as a JavaScript object on the Klaytn blockchain platform (Klaytn).\r\n * @hideconstructor\r\n * @class\r\n */\n\n\nclass KIP37 extends Contract {\n  /**\r\n   * Creates a new KIP37 instance with its bound methods and events.\r\n   *\r\n   * @example\r\n   * const kip37 = caver.kct.kip37.create('0x{address in hex}')\r\n   *\r\n   * @param {string} tokenAddress - The KIP-37 token contract address.\r\n   * @param {Array} [abi] - The Contract Application Binary Interface (ABI) of the KIP-37.\r\n   * @return {KIP37}\r\n   */\n  static create(tokenAddress, abi) {\n    return new KIP37(tokenAddress, abi);\n  }\n  /**\r\n   * An object that defines the parameters required to deploy the KIP-37 contract.\r\n   *\r\n   * @typedef {object} KIP37.KIP37DeployParams\r\n   * @property {string} uri - The URI for all token types, by relying on the {@link http://kips.klaytn.com/KIPs/kip-37#metadata|token type ID substitution mechanism}.\r\n   */\n\n  /**\r\n   * Deploys a KIP-37 token contract to Klaytn network.\r\n   *\r\n   * By default, it returns a KIP37 instance when the deployment is finished.\r\n   * If you define a custom function in the `contractDeployFormatter` field in {@link Contract.SendOptions|SendOptions}, you can control return type.\r\n   *\r\n   * @example\r\n   * const tokenInfo = { uri: 'uri string' }\r\n   *\r\n   * // Below example will use `caver.wallet`.\r\n   * const deployed = await caver.kct.kip37.deploy(tokenInfo, '0x{deployer address}')\r\n   *\r\n   * // Use sendOptions instead of deployer address.\r\n   * const sendOptions = { from: '0x{deployer address}', feeDelegation: true, feePayer: '0x{fee payer address}' }\r\n   * const deployed = await caver.kct.kip37.deploy(tokenInfo, sendOptions)\r\n   *\r\n   * // If you want to use your own wallet that implements the 'IWallet' interface, pass it into the last parameter.\r\n   * const deployed = await caver.kct.kip37.deploy(tokenInfo, '0x{deployer address}', wallet)\r\n   *\r\n   * @param {KIP37.KIP37DeployParams} tokenInfo The object that defines the uri to deploy.\r\n   * @param {Contract.SendOptions|string} sendOptions An object holding parameters that are required for sending a transaction.\r\n   * @param {IWallet} [wallet] The wallet instance to sign and send a transaction.\r\n   * @return {Promise<*>}\r\n   */\n\n\n  static deploy(tokenInfo, sendOptions, wallet) {\n    validateDeployParameterForKIP37(tokenInfo);\n    const {\n      uri\n    } = tokenInfo;\n    const kip37 = new KIP37();\n    if (wallet !== undefined) kip37.setWallet(wallet); // If sendOptions is string type, sendOptions means deployer's address\n\n    if (_.isString(sendOptions)) sendOptions = {\n      from: sendOptions,\n      gas: 7000000,\n      value: 0\n    };\n    sendOptions.gas = sendOptions.gas !== undefined ? sendOptions.gas : 7000000;\n    return kip37.deploy({\n      data: kip37ByteCode,\n      arguments: [uri]\n    }).send(sendOptions);\n  }\n  /**\r\n   * An object that defines the parameters required to deploy the KIP-37 contract.\r\n   *\r\n   * @typedef {object} KIP37.KIP37DetectedObject\r\n   * @property {boolean} IKIP37 - Whether to implement `IKIP37` interface.\r\n   * @property {boolean} IKIP37Metadata - Whether to implement `IKIP37Metadata` interface.\r\n   * @property {boolean} IKIP37Mintable - Whether to implement `IKIP37Mintable` interface.\r\n   * @property {boolean} IKIP37Burnable - Whether to implement `IKIP37Burnable` interface.\r\n   * @property {boolean} IKIP37Pausable - Whether to implement `IKIP37Pausable` interface.\r\n   */\n\n  /**\r\n   * Returns the information of the interface implemented by the token contract.\r\n   *\r\n   * @example\r\n   * const detected = await caver.kct.kip37.detectInterface('0x{address in hex}')\r\n   *\r\n   * @param {string} contractAddress The address of the KIP-37 token contract to detect.\r\n   * @return {Promise<KIP37.KIP37DetectedObject>}\r\n   */\n\n\n  static detectInterface(contractAddress) {\n    const kip37 = new KIP37(contractAddress);\n    return kip37.detectInterface();\n  }\n\n  constructor(tokenAddress) {\n    let abi = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : kip37JsonInterface;\n\n    if (tokenAddress) {\n      if (_.isString(tokenAddress)) {\n        if (!isAddress(tokenAddress)) throw new Error(`Invalid token address ${tokenAddress}`);\n      } else {\n        abi = tokenAddress;\n        tokenAddress = undefined;\n      }\n    }\n\n    super(abi, tokenAddress);\n    this.setWallet(KIP37.wallet);\n  }\n  /**\r\n   * Clones the current KIP37 instance.\r\n   *\r\n   * @example\r\n   * const cloned = kip37.clone()\r\n   * const cloned = kip37.clone('0x{new kip7 address}')\r\n   *\r\n   * @param {string} [tokenAddress] The address of the token contract.\r\n   * @return {KIP37}\r\n   */\n\n\n  clone() {\n    let tokenAddress = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.address;\n    const cloned = new this.constructor(tokenAddress, this.options.jsonInterface);\n    cloned.setWallet(this._wallet);\n    return cloned;\n  }\n  /**\r\n   * Returns the information of the interface implemented by the token contract.\r\n   *\r\n   * @example\r\n   * const detected = await kip37.detectInterface()\r\n   *\r\n   * @return {Promise<KIP37.KIP37DetectedObject>}\r\n   */\n\n\n  async detectInterface() {\n    const detected = {\n      IKIP37: false,\n      IKIP37Metadata: false,\n      IKIP37Mintable: false,\n      IKIP37Burnable: false,\n      IKIP37Pausable: false\n    };\n    const notSupportedMsg = `This contract does not support KIP-13.`;\n    const contractAddress = this._address;\n\n    try {\n      const isSupported = await KIP13.isImplementedKIP13Interface(contractAddress);\n      if (isSupported !== true) throw new Error(notSupportedMsg); // Since there is an extension that has the same interface id even though it is a different KCT,\n      // it must be checked first whether the contract is a KIP-37 contract.\n\n      detected.IKIP37 = await this.supportsInterface(interfaceIds.kip37.IKIP37);\n      if (detected.IKIP37 === false) return detected;\n      await Promise.all(Object.keys(interfaceIds.kip37).map(async interfaceName => {\n        if (interfaceIds.kip37[interfaceName] !== interfaceIds.kip37.IKIP37) detected[interfaceName] = await this.supportsInterface(interfaceIds.kip37[interfaceName]);\n      }));\n      return detected;\n    } catch (e) {\n      throw new Error(notSupportedMsg);\n    }\n  }\n  /**\r\n   * Returns `true` if this contract implements the interface defined by `interfaceId`.\r\n   *\r\n   * @example\r\n   * const supported = await kip37.supportsInterface('0x6433ca1f')\r\n   *\r\n   * @param {string} interfaceId The interface id to check.\r\n   * @return {Promise<boolean>}\r\n   */\n\n\n  async supportsInterface(interfaceId) {\n    const isSupported = await this.methods.supportsInterface(interfaceId).call();\n    return isSupported;\n  }\n  /**\r\n   * Returns distinct Uniform Resource Identifier (URI) of the given token.\r\n   * If the string {id} exists in any URI, this function will replace this with the actual token ID in hexadecimal form.\r\n   * Please refer to {@link http://kips.klaytn.com/KIPs/kip-37#metadata|KIP-34 Metadata}.\r\n   *\r\n   * @example\r\n   * const uri = await kip37.uri('0x0')\r\n   *\r\n   * @param {BigNumber|string|number} id The token id to get uri.\r\n   * @return {Promise<string>}\r\n   */\n\n\n  async uri(id) {\n    let uri = await this.methods.uri(formatParamForUint256(id)).call(); // Replace {id} to token id in hexadecimal form.\n\n    if (uri.includes('{id}')) {\n      let tokenIdInHex = stripHexPrefix(toHex(id));\n      tokenIdInHex = leftPad(tokenIdInHex, 64, '0');\n      uri = uri.replace('{id}', tokenIdInHex);\n    }\n\n    return uri;\n  }\n  /**\r\n   * Returns the total token supply of the specific token.\r\n   *\r\n   * @example\r\n   * const totalSupply = await kip37.totalSupply(0)\r\n   *\r\n   * @param {BigNumber|string|number} id The token id to see the total supply.\r\n   * @return {Promise<BigNumber>}\r\n   */\n\n\n  async totalSupply(id) {\n    const totalSupply = await this.methods.totalSupply(formatParamForUint256(id)).call();\n    return new BigNumber(totalSupply);\n  }\n  /**\r\n   * Returns the amount of tokens of token type `id` owned by `account`.\r\n   *\r\n   * @example\r\n   * const balance = await kip37.balanceOf('0x{address in hex}', 0)\r\n   *\r\n   * @param {string} account The address of the account for which you want to see balance.\r\n   * @param {BigNumber|string|number} id The token id to see balance.\r\n   * @return {Promise<BigNumber>}\r\n   */\n\n\n  async balanceOf(account, id) {\n    const balance = await this.methods.balanceOf(account, formatParamForUint256(id)).call();\n    return new BigNumber(balance);\n  }\n  /**\r\n   * Returns the balance of multiple account/token pairs.\r\n   * `balanceOfBatch` is a batch operation of {@link balanceOf}, and the length of arrays with `accounts` and `ids` must be the same.\r\n   *\r\n   * @param {Array.<string>} accounts The address of the accounts for which you want to see balance.\r\n   * @param {Array.<BigNumber|string|number>} ids An array of ids of token you want to see balance.\r\n   * @return {Promise<Array.<BigNumber>>}\r\n   */\n\n\n  async balanceOfBatch(accounts, ids) {\n    if (ids.length !== accounts.length) throw new Error(`ids and accounts must have the same length.`);\n    const formattedTokenIds = [];\n\n    for (let i = 0; i < ids.length; i++) {\n      formattedTokenIds.push(formatParamForUint256(ids[i]));\n    }\n\n    const balances = await this.methods.balanceOfBatch(accounts, formattedTokenIds).call();\n    const ret = [];\n\n    for (const bal of balances) {\n      ret.push(new BigNumber(bal));\n    }\n\n    return ret;\n  }\n  /**\r\n   * Queries the approval status of an operator for a given owner. Returns true if an operator is approved by a given owner.\r\n   *\r\n   * @example\r\n   * const isApprovedForAll = await kip37.isApprovedForAll('0x{address in hex}', '0x{address in hex}')\r\n   *\r\n   * @param {string} owner The address of the owner.\r\n   * @param {string} operator The address of the operator.\r\n   * @return {Promise<boolean>}\r\n   */\n\n\n  async isApprovedForAll(owner, operator) {\n    const isApprovedForAll = await this.methods.isApprovedForAll(owner, operator).call();\n    return isApprovedForAll;\n  }\n  /**\r\n   * Returns whether or not the token contract's transaction (or specific token) is paused.\r\n   *\r\n   * If `id` parameter is not defined, return whether the token contract's transaction is paused.\r\n   * If `id` parameter is defined, return whether the specific token is paused.\r\n   *\r\n   * @example\r\n   * // without token id parameter\r\n   * const isPaused = await kip37.paused()\r\n   * // with token id parameter\r\n   * const isPaused = await kip37.paused(0)\r\n   *\r\n   * @param {BigNumber|string|number} [id] The token id to check wether paused or not. If this parameter is omitted, the `paused` function return whether the contract is in paused state.\r\n   * @return {Promise<boolean>}\r\n   */\n\n\n  async paused(id) {\n    const callObject = id !== undefined ? this.methods.paused(formatParamForUint256(id)) : this.methods.paused();\n    const isPaused = await callObject.call();\n    return isPaused;\n  }\n  /**\r\n   * Returns `true` if the given account is a pauser who can suspend transferring tokens.\r\n   *\r\n   * @example\r\n   * const isPauser = await kip37.isPauser('0x{address in hex}')\r\n   *\r\n   * @param {string} account The address of the account to be checked for having the right to suspend transferring tokens.\r\n   * @return {Promise<boolean>}\r\n   */\n\n\n  async isPauser(account) {\n    const isPauser = await this.methods.isPauser(account).call();\n    return isPauser;\n  }\n  /**\r\n   * Returns `true` if the given account is a minter who can issue new KIP37 tokens.\r\n   *\r\n   * @example\r\n   * const isMinter = await kip37.isMinter('0x{address in hex}')\r\n   *\r\n   * @param {string} account The address of the account to be checked for having the minting right.\r\n   * @return {Promise<boolean>}\r\n   */\n\n\n  async isMinter(account) {\n    const isMinter = await this.methods.isMinter(account).call();\n    return isMinter;\n  }\n  /**\r\n   * create creates token and assigns them to account, increasing the total supply.\r\n   *\r\n   * @example\r\n   * // Send via a sendParam object with the from field given\r\n   * const receipt = await kip37.create(2, '1000000000000000000', { from: '0x{address in hex}' })\r\n   *\r\n   * @param {BigNumber|string|number} id The token id to create.\r\n   * @param {BigNumber|string|number} initialSupply The amount of tokens being minted.\r\n   * @param {string} [uri] The token URI of the created token.\r\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n   */\n\n\n  async create(id, initialSupply, uri) {\n    let sendParam = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    if (uri && _.isObject(uri)) {\n      if (uri.gas !== undefined || uri.from !== undefined) {\n        if (Object.keys(sendParam).length > 0) throw new Error(`Invalid parameters`);\n        sendParam = uri;\n        uri = '';\n      }\n    }\n\n    const executableObj = this.methods.create(formatParamForUint256(id), formatParamForUint256(initialSupply), uri);\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\r\n   * Approves the given operator, or disallow the given operator, to transfer all tokens of the owner.\r\n   * An operator is allowed to transfer all tokens of the sender on their behalf.\r\n   *\r\n   * @example\r\n   * const receipt = await kip37.setApprovalForAll('0x{address in hex}', true, { from: '0x{address in hex}' })\r\n   *\r\n   * @param {string} operator The address of an account to be approved/prohibited to transfer the owner's all tokens.\r\n   * @param {boolean} approved This operator will be approved if `true`. The operator will be disallowed if `false`.\r\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n   */\n\n\n  async setApprovalForAll(operator, approved) {\n    let sendParam = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const executableObj = this.methods.setApprovalForAll(operator, approved);\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\r\n   * Safely transfers the given `amount` tokens of specific token type `id` from `from` to the `recipient`.\r\n   *\r\n   * The address who was approved to send the owner's token (the operator) or the token owner itself is expected to execute this token transferring transaction.\r\n   * Thus, the approved one or the token owner should be the sender of this transaction whose address must be given at `sendParam.from` or `kip37.options.from`.\r\n   * Without `sendParam.from` nor `kip37.options.from` being provided, an error would occur.\r\n   *\r\n   * If the `recipient` was a contract address, it should implement `IKIP37Receiver.onKIP37Received`. Otherwise, the transfer is reverted.\r\n   *\r\n   * @example\r\n   * const receipt = await kip37.safeTransferFrom('0x{address in hex}', '0x{address in hex}', 2, 10000, { from: '0x{address in hex}' })\r\n   *\r\n   * @param {string} from The address of the account that owns the token to be sent with allowance mechanism.\r\n   * @param {string} to The address of the account to receive the token.\r\n   * @param {BigNumber|string|number} id The token id to transfer.\r\n   * @param {BigNumber|string|number} amount The amount of token you want to transfer.\r\n   * @param {Buffer|string|number} [data] (optional) The data to send along with the call.\r\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n   */\n\n\n  async safeTransferFrom(from, to, id, amount, data) {\n    let sendParam = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n\n    if (data && _.isObject(data)) {\n      if (data.gas !== undefined || data.from !== undefined) {\n        if (Object.keys(sendParam).length > 0) throw new Error(`Invalid parameters`);\n        sendParam = data;\n        data = Buffer.from('');\n      }\n    }\n\n    if (data && !_.isBuffer(data)) {\n      if (_.isString(data) && !isHexStrict(data)) data = toHex(data);\n      data = toBuffer(data);\n    }\n\n    const executableObj = this.methods.safeTransferFrom(from, to, formatParamForUint256(id), formatParamForUint256(amount), data);\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\r\n   * Safely batch transfers of multiple token ids and values from `from` to the `recipient`.\r\n   *\r\n   * The address who was approved to send the owner's token (the operator) or the token owner itself is expected to execute this token transferring transaction.\r\n   * Thus, the approved one or the token owner should be the sender of this transaction whose address must be given at `sendParam.from` or `kip37.options.from`.\r\n   * Without `sendParam.from` nor `kip37.options.from` being provided, an error would occur.\r\n   *\r\n   * If the `recipient` was a contract address, it should implement `IKIP37Receiver.onKIP37Received`. Otherwise, the transfer is reverted.\r\n   *\r\n   * @example\r\n   * const receipt = await kip37.safeBatchTransferFrom('0x{address in hex}', '0x{address in hex}', [1, 2], [10, 1000], { from: '0x{address in hex}' })\r\n   *\r\n   * @param {string} from The address of the account that owns the token to be sent with allowance mechanism.\r\n   * @param {string} recipient The address of the account to receive the token.\r\n   * @param {Array.<BigNumber|string|number>} ids An array of the token ids to transfer.\r\n   * @param {Array.<BigNumber|string|number>} amounts An array of the token amounts you want to transfer.\r\n   * @param {Buffer|string|number} [data] (optional) The data to send along with the call.\r\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n   */\n\n\n  async safeBatchTransferFrom(from, recipient, ids, amounts, data) {\n    let sendParam = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n\n    if (data && _.isObject(data)) {\n      if (data.gas !== undefined || data.from !== undefined) {\n        if (Object.keys(sendParam).length > 0) throw new Error(`Invalid parameters`);\n        sendParam = data;\n        data = Buffer.from('');\n      }\n    }\n\n    if (data && !_.isBuffer(data)) {\n      if (_.isString(data) && !isHexStrict(data)) data = toHex(data);\n      data = toBuffer(data);\n    }\n\n    if (ids.length !== amounts.length) throw new Error(`ids and amounts must have the same length.`);\n    const formattedTokenIds = [];\n    const formattedTokenAmounts = [];\n\n    for (let i = 0; i < ids.length; i++) {\n      formattedTokenIds.push(formatParamForUint256(ids[i]));\n      formattedTokenAmounts.push(formatParamForUint256(amounts[i]));\n    }\n\n    const executableObj = this.methods.safeBatchTransferFrom(from, recipient, formattedTokenIds, formattedTokenAmounts, data);\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\r\n   * Mints the token of the specific token type `id` and assigns the tokens according to the variables `to` and `value`.\r\n   * The mint function allows you to mint specific token to multiple accounts at once by passing arrays `to` to and `value` as parameters.\r\n   *\r\n   * If `sendParam.from` or `kip37.options.from` were given, it should be a minter with MinterRole.\r\n   *\r\n   * @example\r\n   * const receipt = await kip37.mint('0x{address in hex}', 2, 1000, { from: '0x{address in hex}' })\r\n   *\r\n   * @param {string|Array.<string>} toList An address of the account or an array of addresses to which the minted token will be issued.\r\n   * @param {BigNumber|string|number} id The token id to mint.\r\n   * @param {BigNumber|string|number|Array.<BigNumber|string|number>} values The amount of token to be minted. If an array containing multiple addresses is delivered to `to` parameter, the value must be delivered in the form of an array.\r\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n   */\n\n\n  async mint(toList, id, values) {\n    let sendParam = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    if (_.isArray(toList) !== _.isArray(values)) throw new Error(`If you want to minting a specific token to multiple accounts, both toList and values both must be arrays.`);\n    let executableObj;\n\n    if (_.isArray(toList)) {\n      if (toList.length !== values.length) throw new Error(`toList and values must have the same length.`);\n      const formattedTokenValues = [];\n\n      for (const val of values) {\n        formattedTokenValues.push(formatParamForUint256(val));\n      }\n\n      executableObj = this.methods.mint(formatParamForUint256(id), toList, formattedTokenValues);\n    } else {\n      executableObj = this.methods.mint(formatParamForUint256(id), toList, formatParamForUint256(values));\n    }\n\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\r\n   * Mints the multiple KIP-37 tokens of the specific token types `ids` in a batch and assigns the tokens according to the variables `to` and `values`.\r\n   *\r\n   * If `sendParam.from` or `kip37.options.from` were given, it should be a minter with MinterRole.\r\n   *\r\n   * @example\r\n   * const receipt = await kip37.mintBatch('0x{address in hex}', [1, 2], [100, 200], { from: '0x{address in hex}' })\r\n   *\r\n   * @param {string} to An address of the account to which the minted tokens will be issued.\r\n   * @param {Array.<BigNumber|string|number>} ids An array of the token ids to mint.\r\n   * @param {Array.<BigNumber|string|number>} values An array of the token amounts to mint.\r\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n   */\n\n\n  async mintBatch(to, ids, values) {\n    let sendParam = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    if (ids.length !== values.length) throw new Error(`ids and values must have the same length.`);\n    const formattedTokenIds = [];\n    const formattedTokenValues = [];\n\n    for (let i = 0; i < ids.length; i++) {\n      formattedTokenIds.push(formatParamForUint256(ids[i]));\n      formattedTokenValues.push(formatParamForUint256(values[i]));\n    }\n\n    const executableObj = this.methods.mintBatch(to, formattedTokenIds, formattedTokenValues);\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\r\n   * Adds an account as a minter, who are permitted to mint tokens.\r\n   *\r\n   * If `sendParam.from` or `kip37.options.from` were given, it should be a minter with MinterRole.\r\n   *\r\n   * @example\r\n   * const receipt = await kip37.addMinter('0x{address in hex}', { from: '0x{address in hex}' })\r\n   *\r\n   * @param {string} account The address of the account to be added as a minter.\r\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n   */\n\n\n  async addMinter(account) {\n    let sendParam = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const executableObj = this.methods.addMinter(account);\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\r\n   * Renounces the right to mint tokens. Only a minter address can renounce the minting right.\r\n   *\r\n   * If `sendParam.from` or `kip37.options.from` were given, it should be a minter with MinterRole.\r\n   *\r\n   * @example\r\n   * const receipt = await kip37.renounceMinter({ from: '0x{address in hex}' })\r\n   *\r\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n   */\n\n\n  async renounceMinter() {\n    let sendParam = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const executableObj = this.methods.renounceMinter();\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\r\n   * Burns specific KIP-37 tokens.\r\n   *\r\n   * The address who was approved to operate the owner's token (the operator) or the token owner itself is expected to execute this token transferring transaction.\r\n   * Thus, the approved one or the token owner should be the sender of this transaction whose address must be given at `sendParam.from` or `kip37.options.from`.\r\n   * Without `sendParam.from` nor `kip37.options.from` being provided, an error would occur.\r\n   *\r\n   * @example\r\n   * const receipt = await kip37.burn('0x{address in hex}', 2, 10, { from: '0x{address in hex}' })\r\n   *\r\n   * @param {string} account The address of the account that owns the token to be destroyed.\r\n   * @param {BigNumber|string|number} id The id of token to be destroyed.\r\n   * @param {BigNumber|string|number} value The amount of token to be destroyed.\r\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-7 token contract.\r\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-7 abi.\r\n   */\n\n\n  async burn(account, id, value) {\n    let sendParam = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const executableObj = this.methods.burn(account, formatParamForUint256(id), formatParamForUint256(value));\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\r\n   * Burns the multiple KIP-37 tokens.\r\n   *\r\n   * The address who was approved to operate the owner's token (the operator) or the token owner itself is expected to execute this token transferring transaction.\r\n   * Thus, the approved one or the token owner should be the sender of this transaction whose address must be given at `sendParam.from` or `kip37.options.from`.\r\n   * Without `sendParam.from` nor `kip37.options.from` being provided, an error would occur.\r\n   *\r\n   * @example\r\n   * const receipt = await kip37.burnBatch('0x{address in hex}', [1, 2], [100, 200], { from: '0x{address in hex}' })\r\n   *\r\n   * @param {string} account The address of the account that owns the token to be destroyed.\r\n   * @param {Array.<BigNumber|string|number>} ids An array of the token ids to burn.\r\n   * @param {Array.<BigNumber|string|number>} values An array of the token amounts to burn.\r\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n   */\n\n\n  async burnBatch(account, ids, values) {\n    let sendParam = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    if (ids.length !== values.length) throw new Error(`ids and values must have the same length.`);\n    const formattedTokenIds = [];\n    const formattedTokenValues = [];\n\n    for (let i = 0; i < ids.length; i++) {\n      formattedTokenIds.push(formatParamForUint256(ids[i]));\n      formattedTokenValues.push(formatParamForUint256(values[i]));\n    }\n\n    const executableObj = this.methods.burnBatch(account, formattedTokenIds, formattedTokenValues);\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\r\n   * Suspends functions related to token operation.\r\n   * If `id` parameter is defined, pause the specific token. Otherwise pause the token contract.\r\n   *\r\n   * If `sendParam.from` or `kip37.options.from` were given, it should be a pauser with PauserRole.\r\n   *\r\n   * @example\r\n   * const receipt = await kip37.pause({ from: '0x{address in hex}' })\r\n   *\r\n   * @param {BigNumber|string|number} [id] The token id to pause. If this parameter is omitted, the `pause` function pause the token contract.\r\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n   */\n\n\n  async pause(id) {\n    let sendParam = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (Object.keys(sendParam).length === 0 && _.isObject(id)) {\n      sendParam = id;\n      id = undefined;\n    }\n\n    const executableObj = id !== undefined ? this.methods.pause(formatParamForUint256(id)) : this.methods.pause();\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\r\n   * Resumes the paused contract or specific token.\r\n   * If `id` parameter is defined, unpause the specific token. Otherwise unpause the token contract.\r\n   *\r\n   * If `sendParam.from` or `kip37.options.from` were given, it should be a pauser with PauserRole.\r\n   *\r\n   * @example\r\n   * const receipt = await kip37.unpause({ from: '0x{address in hex}' })\r\n   *\r\n   * @param {BigNumber|string|number} [id] The token id to unpause. If this parameter is omitted, the `unpause` function unpause the token contract.\r\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n   */\n\n\n  async unpause(id) {\n    let sendParam = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (Object.keys(sendParam).length === 0 && _.isObject(id)) {\n      sendParam = id;\n      id = undefined;\n    }\n\n    const executableObj = id !== undefined ? this.methods.unpause(formatParamForUint256(id)) : this.methods.unpause();\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\r\n   * Adds an account as a pauser that has the right to suspend the contract.\r\n   *\r\n   * If `sendParam.from` or `kip37.options.from` were given, it should be a pauser with PauserRole.\r\n   *\r\n   * @example\r\n   * const receipt = await kip37.addPauser('0x{address in hex}', { from: '0x{address in hex}' })\r\n   *\r\n   * @param {string} account The address of the account to be a new pauser.\r\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n   */\n\n\n  async addPauser(account) {\n    let sendParam = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const executableObj = this.methods.addPauser(account);\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\r\n   * Renounces the right to pause the contract. Only a pauser address can renounce the pausing right.\r\n   *\r\n   * If `sendParam.from` or `kip37.options.from` were given, it should be a pauser with PauserRole.\r\n   *\r\n   * @example\r\n   * const receipt = await kip37.renouncePauser({ from: '0x{address in hex}' })\r\n   *\r\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n   */\n\n\n  async renouncePauser() {\n    let sendParam = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const executableObj = this.methods.renouncePauser();\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n\n}\n/**\r\n * The byte code of the KIP-37 token contract.\r\n *\r\n * @example\r\n * caver.kct.kip37.byteCode\r\n *\r\n * @static\r\n * @type {string}\r\n */\n\n\nKIP37.byteCode = kip37ByteCode;\n/**\r\n * The abi of the KIP-37 token contract.\r\n *\r\n * @example\r\n * caver.kct.kip37.abi\r\n *\r\n * @static\r\n * @type {Array.<object>}\r\n */\n\nKIP37.abi = kip37JsonInterface;\nmodule.exports = KIP37;","map":{"version":3,"names":["_","require","BigNumber","Contract","kip37JsonInterface","kip37ByteCode","determineSendParams","formatParamForUint256","validateDeployParameterForKIP37","interfaceIds","isAddress","toBuffer","isHexStrict","toHex","stripHexPrefix","leftPad","KIP13","KIP37","create","tokenAddress","abi","deploy","tokenInfo","sendOptions","wallet","uri","kip37","undefined","setWallet","isString","from","gas","value","data","arguments","send","detectInterface","contractAddress","constructor","Error","clone","options","address","cloned","jsonInterface","_wallet","detected","IKIP37","IKIP37Metadata","IKIP37Mintable","IKIP37Burnable","IKIP37Pausable","notSupportedMsg","_address","isSupported","isImplementedKIP13Interface","supportsInterface","Promise","all","Object","keys","map","interfaceName","e","interfaceId","methods","call","id","includes","tokenIdInHex","replace","totalSupply","balanceOf","account","balance","balanceOfBatch","accounts","ids","length","formattedTokenIds","i","push","balances","ret","bal","isApprovedForAll","owner","operator","paused","callObject","isPaused","isPauser","isMinter","initialSupply","sendParam","isObject","executableObj","setApprovalForAll","approved","safeTransferFrom","to","amount","Buffer","isBuffer","safeBatchTransferFrom","recipient","amounts","formattedTokenAmounts","mint","toList","values","isArray","formattedTokenValues","val","mintBatch","addMinter","renounceMinter","burn","burnBatch","pause","unpause","addPauser","renouncePauser","byteCode","module","exports"],"sources":["C:/Users/User/Documents/clone-starter-kit-08/node_modules/caver-js/packages/caver-kct/src/kip37.js"],"sourcesContent":["/*\r\n    Copyright 2021 The caver-js Authors\r\n    This file is part of the caver-js library.\r\n\r\n    The caver-js library is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    The caver-js library is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst _ = require('lodash')\r\nconst BigNumber = require('bignumber.js')\r\n\r\nconst Contract = require('../../caver-contract')\r\nconst {\r\n    kip37JsonInterface,\r\n    kip37ByteCode,\r\n    determineSendParams,\r\n    formatParamForUint256,\r\n    validateDeployParameterForKIP37,\r\n    interfaceIds,\r\n} = require('./kctHelper')\r\nconst { isAddress, toBuffer, isHexStrict, toHex, stripHexPrefix, leftPad } = require('../../caver-utils')\r\nconst KIP13 = require('./kip13')\r\n\r\n/**\r\n * The KIP37 class that helps you easily handle a smart contract that implements KIP-37 as a JavaScript object on the Klaytn blockchain platform (Klaytn).\r\n * @hideconstructor\r\n * @class\r\n */\r\nclass KIP37 extends Contract {\r\n    /**\r\n     * Creates a new KIP37 instance with its bound methods and events.\r\n     *\r\n     * @example\r\n     * const kip37 = caver.kct.kip37.create('0x{address in hex}')\r\n     *\r\n     * @param {string} tokenAddress - The KIP-37 token contract address.\r\n     * @param {Array} [abi] - The Contract Application Binary Interface (ABI) of the KIP-37.\r\n     * @return {KIP37}\r\n     */\r\n    static create(tokenAddress, abi) {\r\n        return new KIP37(tokenAddress, abi)\r\n    }\r\n\r\n    /**\r\n     * An object that defines the parameters required to deploy the KIP-37 contract.\r\n     *\r\n     * @typedef {object} KIP37.KIP37DeployParams\r\n     * @property {string} uri - The URI for all token types, by relying on the {@link http://kips.klaytn.com/KIPs/kip-37#metadata|token type ID substitution mechanism}.\r\n     */\r\n    /**\r\n     * Deploys a KIP-37 token contract to Klaytn network.\r\n     *\r\n     * By default, it returns a KIP37 instance when the deployment is finished.\r\n     * If you define a custom function in the `contractDeployFormatter` field in {@link Contract.SendOptions|SendOptions}, you can control return type.\r\n     *\r\n     * @example\r\n     * const tokenInfo = { uri: 'uri string' }\r\n     *\r\n     * // Below example will use `caver.wallet`.\r\n     * const deployed = await caver.kct.kip37.deploy(tokenInfo, '0x{deployer address}')\r\n     *\r\n     * // Use sendOptions instead of deployer address.\r\n     * const sendOptions = { from: '0x{deployer address}', feeDelegation: true, feePayer: '0x{fee payer address}' }\r\n     * const deployed = await caver.kct.kip37.deploy(tokenInfo, sendOptions)\r\n     *\r\n     * // If you want to use your own wallet that implements the 'IWallet' interface, pass it into the last parameter.\r\n     * const deployed = await caver.kct.kip37.deploy(tokenInfo, '0x{deployer address}', wallet)\r\n     *\r\n     * @param {KIP37.KIP37DeployParams} tokenInfo The object that defines the uri to deploy.\r\n     * @param {Contract.SendOptions|string} sendOptions An object holding parameters that are required for sending a transaction.\r\n     * @param {IWallet} [wallet] The wallet instance to sign and send a transaction.\r\n     * @return {Promise<*>}\r\n     */\r\n    static deploy(tokenInfo, sendOptions, wallet) {\r\n        validateDeployParameterForKIP37(tokenInfo)\r\n\r\n        const { uri } = tokenInfo\r\n        const kip37 = new KIP37()\r\n        if (wallet !== undefined) kip37.setWallet(wallet)\r\n\r\n        // If sendOptions is string type, sendOptions means deployer's address\r\n        if (_.isString(sendOptions)) sendOptions = { from: sendOptions, gas: 7000000, value: 0 }\r\n        sendOptions.gas = sendOptions.gas !== undefined ? sendOptions.gas : 7000000\r\n\r\n        return kip37\r\n            .deploy({\r\n                data: kip37ByteCode,\r\n                arguments: [uri],\r\n            })\r\n            .send(sendOptions)\r\n    }\r\n\r\n    /**\r\n     * An object that defines the parameters required to deploy the KIP-37 contract.\r\n     *\r\n     * @typedef {object} KIP37.KIP37DetectedObject\r\n     * @property {boolean} IKIP37 - Whether to implement `IKIP37` interface.\r\n     * @property {boolean} IKIP37Metadata - Whether to implement `IKIP37Metadata` interface.\r\n     * @property {boolean} IKIP37Mintable - Whether to implement `IKIP37Mintable` interface.\r\n     * @property {boolean} IKIP37Burnable - Whether to implement `IKIP37Burnable` interface.\r\n     * @property {boolean} IKIP37Pausable - Whether to implement `IKIP37Pausable` interface.\r\n     */\r\n    /**\r\n     * Returns the information of the interface implemented by the token contract.\r\n     *\r\n     * @example\r\n     * const detected = await caver.kct.kip37.detectInterface('0x{address in hex}')\r\n     *\r\n     * @param {string} contractAddress The address of the KIP-37 token contract to detect.\r\n     * @return {Promise<KIP37.KIP37DetectedObject>}\r\n     */\r\n    static detectInterface(contractAddress) {\r\n        const kip37 = new KIP37(contractAddress)\r\n        return kip37.detectInterface()\r\n    }\r\n\r\n    constructor(tokenAddress, abi = kip37JsonInterface) {\r\n        if (tokenAddress) {\r\n            if (_.isString(tokenAddress)) {\r\n                if (!isAddress(tokenAddress)) throw new Error(`Invalid token address ${tokenAddress}`)\r\n            } else {\r\n                abi = tokenAddress\r\n                tokenAddress = undefined\r\n            }\r\n        }\r\n        super(abi, tokenAddress)\r\n        this.setWallet(KIP37.wallet)\r\n    }\r\n\r\n    /**\r\n     * Clones the current KIP37 instance.\r\n     *\r\n     * @example\r\n     * const cloned = kip37.clone()\r\n     * const cloned = kip37.clone('0x{new kip7 address}')\r\n     *\r\n     * @param {string} [tokenAddress] The address of the token contract.\r\n     * @return {KIP37}\r\n     */\r\n    clone(tokenAddress = this.options.address) {\r\n        const cloned = new this.constructor(tokenAddress, this.options.jsonInterface)\r\n        cloned.setWallet(this._wallet)\r\n        return cloned\r\n    }\r\n\r\n    /**\r\n     * Returns the information of the interface implemented by the token contract.\r\n     *\r\n     * @example\r\n     * const detected = await kip37.detectInterface()\r\n     *\r\n     * @return {Promise<KIP37.KIP37DetectedObject>}\r\n     */\r\n    async detectInterface() {\r\n        const detected = {\r\n            IKIP37: false,\r\n            IKIP37Metadata: false,\r\n            IKIP37Mintable: false,\r\n            IKIP37Burnable: false,\r\n            IKIP37Pausable: false,\r\n        }\r\n\r\n        const notSupportedMsg = `This contract does not support KIP-13.`\r\n        const contractAddress = this._address\r\n\r\n        try {\r\n            const isSupported = await KIP13.isImplementedKIP13Interface(contractAddress)\r\n            if (isSupported !== true) throw new Error(notSupportedMsg)\r\n\r\n            // Since there is an extension that has the same interface id even though it is a different KCT,\r\n            // it must be checked first whether the contract is a KIP-37 contract.\r\n            detected.IKIP37 = await this.supportsInterface(interfaceIds.kip37.IKIP37)\r\n            if (detected.IKIP37 === false) return detected\r\n\r\n            await Promise.all(\r\n                Object.keys(interfaceIds.kip37).map(async interfaceName => {\r\n                    if (interfaceIds.kip37[interfaceName] !== interfaceIds.kip37.IKIP37)\r\n                        detected[interfaceName] = await this.supportsInterface(interfaceIds.kip37[interfaceName])\r\n                })\r\n            )\r\n            return detected\r\n        } catch (e) {\r\n            throw new Error(notSupportedMsg)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if this contract implements the interface defined by `interfaceId`.\r\n     *\r\n     * @example\r\n     * const supported = await kip37.supportsInterface('0x6433ca1f')\r\n     *\r\n     * @param {string} interfaceId The interface id to check.\r\n     * @return {Promise<boolean>}\r\n     */\r\n    async supportsInterface(interfaceId) {\r\n        const isSupported = await this.methods.supportsInterface(interfaceId).call()\r\n        return isSupported\r\n    }\r\n\r\n    /**\r\n     * Returns distinct Uniform Resource Identifier (URI) of the given token.\r\n     * If the string {id} exists in any URI, this function will replace this with the actual token ID in hexadecimal form.\r\n     * Please refer to {@link http://kips.klaytn.com/KIPs/kip-37#metadata|KIP-34 Metadata}.\r\n     *\r\n     * @example\r\n     * const uri = await kip37.uri('0x0')\r\n     *\r\n     * @param {BigNumber|string|number} id The token id to get uri.\r\n     * @return {Promise<string>}\r\n     */\r\n    async uri(id) {\r\n        let uri = await this.methods.uri(formatParamForUint256(id)).call()\r\n\r\n        // Replace {id} to token id in hexadecimal form.\r\n        if (uri.includes('{id}')) {\r\n            let tokenIdInHex = stripHexPrefix(toHex(id))\r\n            tokenIdInHex = leftPad(tokenIdInHex, 64, '0')\r\n            uri = uri.replace('{id}', tokenIdInHex)\r\n        }\r\n        return uri\r\n    }\r\n\r\n    /**\r\n     * Returns the total token supply of the specific token.\r\n     *\r\n     * @example\r\n     * const totalSupply = await kip37.totalSupply(0)\r\n     *\r\n     * @param {BigNumber|string|number} id The token id to see the total supply.\r\n     * @return {Promise<BigNumber>}\r\n     */\r\n    async totalSupply(id) {\r\n        const totalSupply = await this.methods.totalSupply(formatParamForUint256(id)).call()\r\n        return new BigNumber(totalSupply)\r\n    }\r\n\r\n    /**\r\n     * Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * @example\r\n     * const balance = await kip37.balanceOf('0x{address in hex}', 0)\r\n     *\r\n     * @param {string} account The address of the account for which you want to see balance.\r\n     * @param {BigNumber|string|number} id The token id to see balance.\r\n     * @return {Promise<BigNumber>}\r\n     */\r\n    async balanceOf(account, id) {\r\n        const balance = await this.methods.balanceOf(account, formatParamForUint256(id)).call()\r\n        return new BigNumber(balance)\r\n    }\r\n\r\n    /**\r\n     * Returns the balance of multiple account/token pairs.\r\n     * `balanceOfBatch` is a batch operation of {@link balanceOf}, and the length of arrays with `accounts` and `ids` must be the same.\r\n     *\r\n     * @param {Array.<string>} accounts The address of the accounts for which you want to see balance.\r\n     * @param {Array.<BigNumber|string|number>} ids An array of ids of token you want to see balance.\r\n     * @return {Promise<Array.<BigNumber>>}\r\n     */\r\n    async balanceOfBatch(accounts, ids) {\r\n        if (ids.length !== accounts.length) throw new Error(`ids and accounts must have the same length.`)\r\n\r\n        const formattedTokenIds = []\r\n        for (let i = 0; i < ids.length; i++) {\r\n            formattedTokenIds.push(formatParamForUint256(ids[i]))\r\n        }\r\n\r\n        const balances = await this.methods.balanceOfBatch(accounts, formattedTokenIds).call()\r\n\r\n        const ret = []\r\n        for (const bal of balances) {\r\n            ret.push(new BigNumber(bal))\r\n        }\r\n\r\n        return ret\r\n    }\r\n\r\n    /**\r\n     * Queries the approval status of an operator for a given owner. Returns true if an operator is approved by a given owner.\r\n     *\r\n     * @example\r\n     * const isApprovedForAll = await kip37.isApprovedForAll('0x{address in hex}', '0x{address in hex}')\r\n     *\r\n     * @param {string} owner The address of the owner.\r\n     * @param {string} operator The address of the operator.\r\n     * @return {Promise<boolean>}\r\n     */\r\n    async isApprovedForAll(owner, operator) {\r\n        const isApprovedForAll = await this.methods.isApprovedForAll(owner, operator).call()\r\n        return isApprovedForAll\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the token contract's transaction (or specific token) is paused.\r\n     *\r\n     * If `id` parameter is not defined, return whether the token contract's transaction is paused.\r\n     * If `id` parameter is defined, return whether the specific token is paused.\r\n     *\r\n     * @example\r\n     * // without token id parameter\r\n     * const isPaused = await kip37.paused()\r\n     * // with token id parameter\r\n     * const isPaused = await kip37.paused(0)\r\n     *\r\n     * @param {BigNumber|string|number} [id] The token id to check wether paused or not. If this parameter is omitted, the `paused` function return whether the contract is in paused state.\r\n     * @return {Promise<boolean>}\r\n     */\r\n    async paused(id) {\r\n        const callObject = id !== undefined ? this.methods.paused(formatParamForUint256(id)) : this.methods.paused()\r\n        const isPaused = await callObject.call()\r\n        return isPaused\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if the given account is a pauser who can suspend transferring tokens.\r\n     *\r\n     * @example\r\n     * const isPauser = await kip37.isPauser('0x{address in hex}')\r\n     *\r\n     * @param {string} account The address of the account to be checked for having the right to suspend transferring tokens.\r\n     * @return {Promise<boolean>}\r\n     */\r\n    async isPauser(account) {\r\n        const isPauser = await this.methods.isPauser(account).call()\r\n        return isPauser\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if the given account is a minter who can issue new KIP37 tokens.\r\n     *\r\n     * @example\r\n     * const isMinter = await kip37.isMinter('0x{address in hex}')\r\n     *\r\n     * @param {string} account The address of the account to be checked for having the minting right.\r\n     * @return {Promise<boolean>}\r\n     */\r\n    async isMinter(account) {\r\n        const isMinter = await this.methods.isMinter(account).call()\r\n        return isMinter\r\n    }\r\n\r\n    /**\r\n     * create creates token and assigns them to account, increasing the total supply.\r\n     *\r\n     * @example\r\n     * // Send via a sendParam object with the from field given\r\n     * const receipt = await kip37.create(2, '1000000000000000000', { from: '0x{address in hex}' })\r\n     *\r\n     * @param {BigNumber|string|number} id The token id to create.\r\n     * @param {BigNumber|string|number} initialSupply The amount of tokens being minted.\r\n     * @param {string} [uri] The token URI of the created token.\r\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n     */\r\n    async create(id, initialSupply, uri, sendParam = {}) {\r\n        if (uri && _.isObject(uri)) {\r\n            if (uri.gas !== undefined || uri.from !== undefined) {\r\n                if (Object.keys(sendParam).length > 0) throw new Error(`Invalid parameters`)\r\n                sendParam = uri\r\n                uri = ''\r\n            }\r\n        }\r\n\r\n        const executableObj = this.methods.create(formatParamForUint256(id), formatParamForUint256(initialSupply), uri)\r\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\r\n\r\n        return executableObj.send(sendParam)\r\n    }\r\n\r\n    /**\r\n     * Approves the given operator, or disallow the given operator, to transfer all tokens of the owner.\r\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\r\n     *\r\n     * @example\r\n     * const receipt = await kip37.setApprovalForAll('0x{address in hex}', true, { from: '0x{address in hex}' })\r\n     *\r\n     * @param {string} operator The address of an account to be approved/prohibited to transfer the owner's all tokens.\r\n     * @param {boolean} approved This operator will be approved if `true`. The operator will be disallowed if `false`.\r\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n     */\r\n    async setApprovalForAll(operator, approved, sendParam = {}) {\r\n        const executableObj = this.methods.setApprovalForAll(operator, approved)\r\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\r\n\r\n        return executableObj.send(sendParam)\r\n    }\r\n\r\n    /**\r\n     * Safely transfers the given `amount` tokens of specific token type `id` from `from` to the `recipient`.\r\n     *\r\n     * The address who was approved to send the owner's token (the operator) or the token owner itself is expected to execute this token transferring transaction.\r\n     * Thus, the approved one or the token owner should be the sender of this transaction whose address must be given at `sendParam.from` or `kip37.options.from`.\r\n     * Without `sendParam.from` nor `kip37.options.from` being provided, an error would occur.\r\n     *\r\n     * If the `recipient` was a contract address, it should implement `IKIP37Receiver.onKIP37Received`. Otherwise, the transfer is reverted.\r\n     *\r\n     * @example\r\n     * const receipt = await kip37.safeTransferFrom('0x{address in hex}', '0x{address in hex}', 2, 10000, { from: '0x{address in hex}' })\r\n     *\r\n     * @param {string} from The address of the account that owns the token to be sent with allowance mechanism.\r\n     * @param {string} to The address of the account to receive the token.\r\n     * @param {BigNumber|string|number} id The token id to transfer.\r\n     * @param {BigNumber|string|number} amount The amount of token you want to transfer.\r\n     * @param {Buffer|string|number} [data] (optional) The data to send along with the call.\r\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n     */\r\n    async safeTransferFrom(from, to, id, amount, data, sendParam = {}) {\r\n        if (data && _.isObject(data)) {\r\n            if (data.gas !== undefined || data.from !== undefined) {\r\n                if (Object.keys(sendParam).length > 0) throw new Error(`Invalid parameters`)\r\n                sendParam = data\r\n                data = Buffer.from('')\r\n            }\r\n        }\r\n\r\n        if (data && !_.isBuffer(data)) {\r\n            if (_.isString(data) && !isHexStrict(data)) data = toHex(data)\r\n            data = toBuffer(data)\r\n        }\r\n\r\n        const executableObj = this.methods.safeTransferFrom(from, to, formatParamForUint256(id), formatParamForUint256(amount), data)\r\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\r\n\r\n        return executableObj.send(sendParam)\r\n    }\r\n\r\n    /**\r\n     * Safely batch transfers of multiple token ids and values from `from` to the `recipient`.\r\n     *\r\n     * The address who was approved to send the owner's token (the operator) or the token owner itself is expected to execute this token transferring transaction.\r\n     * Thus, the approved one or the token owner should be the sender of this transaction whose address must be given at `sendParam.from` or `kip37.options.from`.\r\n     * Without `sendParam.from` nor `kip37.options.from` being provided, an error would occur.\r\n     *\r\n     * If the `recipient` was a contract address, it should implement `IKIP37Receiver.onKIP37Received`. Otherwise, the transfer is reverted.\r\n     *\r\n     * @example\r\n     * const receipt = await kip37.safeBatchTransferFrom('0x{address in hex}', '0x{address in hex}', [1, 2], [10, 1000], { from: '0x{address in hex}' })\r\n     *\r\n     * @param {string} from The address of the account that owns the token to be sent with allowance mechanism.\r\n     * @param {string} recipient The address of the account to receive the token.\r\n     * @param {Array.<BigNumber|string|number>} ids An array of the token ids to transfer.\r\n     * @param {Array.<BigNumber|string|number>} amounts An array of the token amounts you want to transfer.\r\n     * @param {Buffer|string|number} [data] (optional) The data to send along with the call.\r\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n     */\r\n    async safeBatchTransferFrom(from, recipient, ids, amounts, data, sendParam = {}) {\r\n        if (data && _.isObject(data)) {\r\n            if (data.gas !== undefined || data.from !== undefined) {\r\n                if (Object.keys(sendParam).length > 0) throw new Error(`Invalid parameters`)\r\n                sendParam = data\r\n                data = Buffer.from('')\r\n            }\r\n        }\r\n\r\n        if (data && !_.isBuffer(data)) {\r\n            if (_.isString(data) && !isHexStrict(data)) data = toHex(data)\r\n            data = toBuffer(data)\r\n        }\r\n\r\n        if (ids.length !== amounts.length) throw new Error(`ids and amounts must have the same length.`)\r\n\r\n        const formattedTokenIds = []\r\n        const formattedTokenAmounts = []\r\n        for (let i = 0; i < ids.length; i++) {\r\n            formattedTokenIds.push(formatParamForUint256(ids[i]))\r\n            formattedTokenAmounts.push(formatParamForUint256(amounts[i]))\r\n        }\r\n\r\n        const executableObj = this.methods.safeBatchTransferFrom(from, recipient, formattedTokenIds, formattedTokenAmounts, data)\r\n\r\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\r\n\r\n        return executableObj.send(sendParam)\r\n    }\r\n\r\n    /**\r\n     * Mints the token of the specific token type `id` and assigns the tokens according to the variables `to` and `value`.\r\n     * The mint function allows you to mint specific token to multiple accounts at once by passing arrays `to` to and `value` as parameters.\r\n     *\r\n     * If `sendParam.from` or `kip37.options.from` were given, it should be a minter with MinterRole.\r\n     *\r\n     * @example\r\n     * const receipt = await kip37.mint('0x{address in hex}', 2, 1000, { from: '0x{address in hex}' })\r\n     *\r\n     * @param {string|Array.<string>} toList An address of the account or an array of addresses to which the minted token will be issued.\r\n     * @param {BigNumber|string|number} id The token id to mint.\r\n     * @param {BigNumber|string|number|Array.<BigNumber|string|number>} values The amount of token to be minted. If an array containing multiple addresses is delivered to `to` parameter, the value must be delivered in the form of an array.\r\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n     */\r\n    async mint(toList, id, values, sendParam = {}) {\r\n        if (_.isArray(toList) !== _.isArray(values))\r\n            throw new Error(`If you want to minting a specific token to multiple accounts, both toList and values both must be arrays.`)\r\n\r\n        let executableObj\r\n        if (_.isArray(toList)) {\r\n            if (toList.length !== values.length) throw new Error(`toList and values must have the same length.`)\r\n\r\n            const formattedTokenValues = []\r\n            for (const val of values) {\r\n                formattedTokenValues.push(formatParamForUint256(val))\r\n            }\r\n\r\n            executableObj = this.methods.mint(formatParamForUint256(id), toList, formattedTokenValues)\r\n        } else {\r\n            executableObj = this.methods.mint(formatParamForUint256(id), toList, formatParamForUint256(values))\r\n        }\r\n\r\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\r\n\r\n        return executableObj.send(sendParam)\r\n    }\r\n\r\n    /**\r\n     * Mints the multiple KIP-37 tokens of the specific token types `ids` in a batch and assigns the tokens according to the variables `to` and `values`.\r\n     *\r\n     * If `sendParam.from` or `kip37.options.from` were given, it should be a minter with MinterRole.\r\n     *\r\n     * @example\r\n     * const receipt = await kip37.mintBatch('0x{address in hex}', [1, 2], [100, 200], { from: '0x{address in hex}' })\r\n     *\r\n     * @param {string} to An address of the account to which the minted tokens will be issued.\r\n     * @param {Array.<BigNumber|string|number>} ids An array of the token ids to mint.\r\n     * @param {Array.<BigNumber|string|number>} values An array of the token amounts to mint.\r\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n     */\r\n    async mintBatch(to, ids, values, sendParam = {}) {\r\n        if (ids.length !== values.length) throw new Error(`ids and values must have the same length.`)\r\n\r\n        const formattedTokenIds = []\r\n        const formattedTokenValues = []\r\n        for (let i = 0; i < ids.length; i++) {\r\n            formattedTokenIds.push(formatParamForUint256(ids[i]))\r\n            formattedTokenValues.push(formatParamForUint256(values[i]))\r\n        }\r\n\r\n        const executableObj = this.methods.mintBatch(to, formattedTokenIds, formattedTokenValues)\r\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\r\n\r\n        return executableObj.send(sendParam)\r\n    }\r\n\r\n    /**\r\n     * Adds an account as a minter, who are permitted to mint tokens.\r\n     *\r\n     * If `sendParam.from` or `kip37.options.from` were given, it should be a minter with MinterRole.\r\n     *\r\n     * @example\r\n     * const receipt = await kip37.addMinter('0x{address in hex}', { from: '0x{address in hex}' })\r\n     *\r\n     * @param {string} account The address of the account to be added as a minter.\r\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n     */\r\n    async addMinter(account, sendParam = {}) {\r\n        const executableObj = this.methods.addMinter(account)\r\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\r\n\r\n        return executableObj.send(sendParam)\r\n    }\r\n\r\n    /**\r\n     * Renounces the right to mint tokens. Only a minter address can renounce the minting right.\r\n     *\r\n     * If `sendParam.from` or `kip37.options.from` were given, it should be a minter with MinterRole.\r\n     *\r\n     * @example\r\n     * const receipt = await kip37.renounceMinter({ from: '0x{address in hex}' })\r\n     *\r\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n     */\r\n    async renounceMinter(sendParam = {}) {\r\n        const executableObj = this.methods.renounceMinter()\r\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\r\n\r\n        return executableObj.send(sendParam)\r\n    }\r\n\r\n    /**\r\n     * Burns specific KIP-37 tokens.\r\n     *\r\n     * The address who was approved to operate the owner's token (the operator) or the token owner itself is expected to execute this token transferring transaction.\r\n     * Thus, the approved one or the token owner should be the sender of this transaction whose address must be given at `sendParam.from` or `kip37.options.from`.\r\n     * Without `sendParam.from` nor `kip37.options.from` being provided, an error would occur.\r\n     *\r\n     * @example\r\n     * const receipt = await kip37.burn('0x{address in hex}', 2, 10, { from: '0x{address in hex}' })\r\n     *\r\n     * @param {string} account The address of the account that owns the token to be destroyed.\r\n     * @param {BigNumber|string|number} id The id of token to be destroyed.\r\n     * @param {BigNumber|string|number} value The amount of token to be destroyed.\r\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-7 token contract.\r\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-7 abi.\r\n     */\r\n    async burn(account, id, value, sendParam = {}) {\r\n        const executableObj = this.methods.burn(account, formatParamForUint256(id), formatParamForUint256(value))\r\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\r\n\r\n        return executableObj.send(sendParam)\r\n    }\r\n\r\n    /**\r\n     * Burns the multiple KIP-37 tokens.\r\n     *\r\n     * The address who was approved to operate the owner's token (the operator) or the token owner itself is expected to execute this token transferring transaction.\r\n     * Thus, the approved one or the token owner should be the sender of this transaction whose address must be given at `sendParam.from` or `kip37.options.from`.\r\n     * Without `sendParam.from` nor `kip37.options.from` being provided, an error would occur.\r\n     *\r\n     * @example\r\n     * const receipt = await kip37.burnBatch('0x{address in hex}', [1, 2], [100, 200], { from: '0x{address in hex}' })\r\n     *\r\n     * @param {string} account The address of the account that owns the token to be destroyed.\r\n     * @param {Array.<BigNumber|string|number>} ids An array of the token ids to burn.\r\n     * @param {Array.<BigNumber|string|number>} values An array of the token amounts to burn.\r\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n     */\r\n    async burnBatch(account, ids, values, sendParam = {}) {\r\n        if (ids.length !== values.length) throw new Error(`ids and values must have the same length.`)\r\n\r\n        const formattedTokenIds = []\r\n        const formattedTokenValues = []\r\n        for (let i = 0; i < ids.length; i++) {\r\n            formattedTokenIds.push(formatParamForUint256(ids[i]))\r\n            formattedTokenValues.push(formatParamForUint256(values[i]))\r\n        }\r\n\r\n        const executableObj = this.methods.burnBatch(account, formattedTokenIds, formattedTokenValues)\r\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\r\n\r\n        return executableObj.send(sendParam)\r\n    }\r\n\r\n    /**\r\n     * Suspends functions related to token operation.\r\n     * If `id` parameter is defined, pause the specific token. Otherwise pause the token contract.\r\n     *\r\n     * If `sendParam.from` or `kip37.options.from` were given, it should be a pauser with PauserRole.\r\n     *\r\n     * @example\r\n     * const receipt = await kip37.pause({ from: '0x{address in hex}' })\r\n     *\r\n     * @param {BigNumber|string|number} [id] The token id to pause. If this parameter is omitted, the `pause` function pause the token contract.\r\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n     */\r\n    async pause(id, sendParam = {}) {\r\n        if (Object.keys(sendParam).length === 0 && _.isObject(id)) {\r\n            sendParam = id\r\n            id = undefined\r\n        }\r\n\r\n        const executableObj = id !== undefined ? this.methods.pause(formatParamForUint256(id)) : this.methods.pause()\r\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\r\n\r\n        return executableObj.send(sendParam)\r\n    }\r\n\r\n    /**\r\n     * Resumes the paused contract or specific token.\r\n     * If `id` parameter is defined, unpause the specific token. Otherwise unpause the token contract.\r\n     *\r\n     * If `sendParam.from` or `kip37.options.from` were given, it should be a pauser with PauserRole.\r\n     *\r\n     * @example\r\n     * const receipt = await kip37.unpause({ from: '0x{address in hex}' })\r\n     *\r\n     * @param {BigNumber|string|number} [id] The token id to unpause. If this parameter is omitted, the `unpause` function unpause the token contract.\r\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n     */\r\n    async unpause(id, sendParam = {}) {\r\n        if (Object.keys(sendParam).length === 0 && _.isObject(id)) {\r\n            sendParam = id\r\n            id = undefined\r\n        }\r\n\r\n        const executableObj = id !== undefined ? this.methods.unpause(formatParamForUint256(id)) : this.methods.unpause()\r\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\r\n\r\n        return executableObj.send(sendParam)\r\n    }\r\n\r\n    /**\r\n     * Adds an account as a pauser that has the right to suspend the contract.\r\n     *\r\n     * If `sendParam.from` or `kip37.options.from` were given, it should be a pauser with PauserRole.\r\n     *\r\n     * @example\r\n     * const receipt = await kip37.addPauser('0x{address in hex}', { from: '0x{address in hex}' })\r\n     *\r\n     * @param {string} account The address of the account to be a new pauser.\r\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n     */\r\n    async addPauser(account, sendParam = {}) {\r\n        const executableObj = this.methods.addPauser(account)\r\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\r\n\r\n        return executableObj.send(sendParam)\r\n    }\r\n\r\n    /**\r\n     * Renounces the right to pause the contract. Only a pauser address can renounce the pausing right.\r\n     *\r\n     * If `sendParam.from` or `kip37.options.from` were given, it should be a pauser with PauserRole.\r\n     *\r\n     * @example\r\n     * const receipt = await kip37.renouncePauser({ from: '0x{address in hex}' })\r\n     *\r\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\r\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\r\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\r\n     */\r\n    async renouncePauser(sendParam = {}) {\r\n        const executableObj = this.methods.renouncePauser()\r\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\r\n\r\n        return executableObj.send(sendParam)\r\n    }\r\n}\r\n\r\n/**\r\n * The byte code of the KIP-37 token contract.\r\n *\r\n * @example\r\n * caver.kct.kip37.byteCode\r\n *\r\n * @static\r\n * @type {string}\r\n */\r\nKIP37.byteCode = kip37ByteCode\r\n\r\n/**\r\n * The abi of the KIP-37 token contract.\r\n *\r\n * @example\r\n * caver.kct.kip37.abi\r\n *\r\n * @static\r\n * @type {Array.<object>}\r\n */\r\nKIP37.abi = kip37JsonInterface\r\n\r\nmodule.exports = KIP37\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}