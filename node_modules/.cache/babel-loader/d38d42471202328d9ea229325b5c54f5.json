{"ast":null,"code":"var _objectSpread = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\n/*\r\n    Modifications copyright 2018 The caver-js Authors\r\n    This file is part of web3.js.\r\n\r\n    web3.js is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    web3.js is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n    This file is derived from web3.js/packages/web3-eth-abi/src/index.js (2019/06/12).\r\n    Modified and improved for the caver-js development.\r\n*/\n\n/**\r\n * @file index.js\r\n * @author Marek Kotewicz <marek@parity.io>\r\n * @author Fabian Vogelsteller <fabian@frozeman.de>\r\n * @date 2017\r\n */\nvar _ = require('lodash');\n\nvar EthersAbiCoder = require('@ethersproject/abi').AbiCoder;\n\nvar ParamType = require('@ethersproject/abi').ParamType;\n\nvar utils = require('../../caver-utils');\n\nvar ethersAbiCoder = new EthersAbiCoder(function (type, value) {\n  if (type.match(/^u?int/) && !_.isArray(value) && (!_.isObject(value) || value.constructor.name !== 'BN')) {\n    return value.toString();\n  }\n\n  return value;\n}); // result method\n\nfunction Result() {}\n\nvar ABI = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function ABI() {\n    _classCallCheck(this, ABI);\n  }\n\n  _createClass(ABI, [{\n    key: \"encodeFunctionSignature\",\n    value:\n    /**\r\n     * Encodes the function signature to its ABI signature, which are the first 4 bytes of the sha3 hash of the function name including parameter types.\r\n     *\r\n     * @example\r\n     * caver.abi.encodeFunctionSignature({ name: 'myMethod', type: 'function', inputs: [{ type: 'uint256', name: 'myNumber' },{ type: 'string', name: 'mystring' }]})\r\n     *\r\n     * caver.abi.encodeFunctionSignature('myMethod(uint256,string)')\r\n     *\r\n     * @method encodeFunctionSignature\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {string|object} functionSignature The function signature or the JSON interface object of the function to encode. If this is a string, it has to be in the form `function(type, type,...)`, e.g: `myFunction(uint256,uint32[],bytes10,bytes)`.\r\n     * @return {string} function signature\r\n     */\n    function encodeFunctionSignature(functionSignature) {\n      if (_.isObject(functionSignature)) {\n        functionSignature = utils._jsonInterfaceMethodToString(functionSignature);\n      }\n\n      return utils.sha3(functionSignature).slice(0, 10);\n    }\n    /**\r\n     * Encodes the event signature to its ABI signature, which is the sha3 hash of the event name including input parameter types.\r\n     *\r\n     * @example\r\n     * caver.abi.encodeEventSignature({ name: 'myEvent', type: 'event', inputs: [{ type: 'uint256', name: 'myNumber' },{ type: 'string', name: 'mystring' }]})\r\n     *\r\n     * caver.abi.encodeEventSignature('myEvent(uint256,bytes32)')\r\n     *\r\n     * @method encodeEventSignature\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {string|object} eventSignature The event signature or the JSON interface object of the event to encode. If this is a string, it has to be in the form `event(type,type,...)`, e.g: `myEvent(uint256,uint32[],bytes10,bytes)`.\r\n     * @return {string} event signature\r\n     */\n\n  }, {\n    key: \"encodeEventSignature\",\n    value: function encodeEventSignature(eventSignature) {\n      if (_.isObject(eventSignature)) {\n        eventSignature = utils._jsonInterfaceMethodToString(eventSignature);\n      }\n\n      return utils.sha3(eventSignature);\n    }\n    /**\r\n     * Encodes a parameter based on its type to its ABI representation.\r\n     *\r\n     * @example\r\n     * caver.abi.encodeParameter('uint256', '2345675643')\r\n     * caver.abi.encodeParameter('bytes32[]', [caver.utils.rightPad('0xdf3234', 64), caver.utils.rightPad('0xfdfd', 64)])\r\n     * caver.abi.encodeParameter('tuple(bytes32,bool)', ['0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a18', true])\r\n     *\r\n     * @method encodeParameter\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {string|object} type The type of the parameter, see the {@link http://solidity.readthedocs.io/en/develop/types.html|solidity documentation}  for a list of types.\r\n     * @param {*} param The actual parameter to encode.\r\n     * @return {string} encoded plain param\r\n     */\n\n  }, {\n    key: \"encodeParameter\",\n    value: function encodeParameter(type, param) {\n      return this.encodeParameters([type], [param]);\n    }\n    /**\r\n     * Encodes function parameters based on its JSON interface object.\r\n     *\r\n     * @example\r\n     * caver.abi.encodeParameters(['uint256','string'], ['2345675643', 'Hello!%'])\r\n     *\r\n     * caver.abi.encodeParameters(\r\n     *      ['tuple(bytes32,bool)', 'tuple(bool,address)'],\r\n     *      [['0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a18', true], [true, '0x77656c636f6d6520746f20657468657265756d2e']]\r\n     * )\r\n     *\r\n     * caver.abi.encodeParameters(\r\n     *   [\r\n     *       {\r\n     *           components: [{ name: 'a', type: 'bytes32' }, { name: 'b', type: 'bool' }],\r\n     *           name: 'tupleExample',\r\n     *           type: 'tuple',\r\n     *       },\r\n     *       {\r\n     *           components: [{ name: 'c', type: 'bool' }, { name: 'd', type: 'address' }],\r\n     *           name: 'tupleExample2',\r\n     *          type: 'tuple',\r\n     *      },\r\n     *  ],\r\n     *  [\r\n     *      ['0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a18', true],\r\n     *      [true, '0x77656c636f6d6520746f20657468657265756d2e']\r\n     *  ]\r\n     *)\r\n     *\r\n     * @method encodeParameters\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {Array.<string|object>} types An array with types or a JSON interface of a function. See the {@link http://solidity.readthedocs.io/en/develop/types.html|solidity documentation} for a list of types.\r\n     * @param {Array.<*>} params The parameters to encode.\r\n     * @return {string} encoded list of params\r\n     */\n\n  }, {\n    key: \"encodeParameters\",\n    value: function encodeParameters(types, params) {\n      var self = this;\n      types = self.mapTypes(types);\n      params = params.map(function (param, index) {\n        var type = types[index]; // { components: [[Object], [Object]], name: 'b', type: 'tuple' }\n\n        if (typeof type === 'object' && type.type) {\n          // We may get a named type of shape {name, type}\n          type = type.type;\n        }\n\n        param = self.formatParam(type, param); // If the type is string but number comes in, ethersAbiCoder ignores the type and encodes successfully.\n        // To avoid invalid encoding value, adding error handling.\n\n        if (type === 'string' && typeof param !== 'string') throw new Error(\"Invalid parameter: Parameter value and type do not match.\"); // Format params for tuples\n\n        if (typeof type === 'string' && type.includes('tuple')) {\n          var coder = ethersAbiCoder._getCoder(ParamType.from(type)); // eslint-disable-next-line no-shadow\n\n\n          var modifyParams = function modifyParams(coder, param) {\n            if (coder.name === 'array') {\n              return param.map(function (p) {\n                // `coder.type.replace('[]','')` can handle'tuple(string,string)[]', but cannot handle `tuple(string,string)[3]'.\n                // Therefore, in order to handle tuple arrays of fixed length, the logic is changed to handle strings using regular expression expressions.\n                var replacedType = coder.type.replace(/\\[[1-9]*\\]/g, '');\n                var parameterType = ParamType.from(replacedType);\n\n                var gotCoder = ethersAbiCoder._getCoder(parameterType);\n\n                modifyParams(gotCoder, p);\n              });\n            }\n\n            coder.coders.forEach(function (c, i) {\n              if (c.name === 'tuple') {\n                modifyParams(c, param[i]);\n              } else {\n                param[i] = self.formatParam(c.name, param[i]);\n              }\n            });\n          };\n\n          modifyParams(coder, param);\n        }\n\n        return param;\n      });\n      return ethersAbiCoder.encode(types, params);\n    }\n    /**\r\n     * Should be used to encode smart contract deployment with constructor arguments.\r\n     *\r\n     * @example\r\n     * // There is no argument for constructor\r\n     * caver.abi.encodeContractDeploy([\r\n     *     { \"constant\": true, \"inputs\": [], \"name\": \"count\", \"outputs\": [ { \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" },\r\n     *     { \"constant\": true, \"inputs\": [], \"name\": \"getBlockNumber\", \"outputs\": [ { \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" },\r\n     *     { \"constant\": false, \"inputs\": [ { \"name\": \"_count\", \"type\": \"uint256\" } ], \"name\": \"setCount\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" }\r\n     * ],'0x{byte code}')\r\n     *\r\n     * // There is one argument for constructor\r\n     * caver.abi.encodeContractDeploy([\r\n     *     { \"constant\": true, \"inputs\": [], \"name\": \"count\", \"outputs\": [ { \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" },\r\n     *     { \"constant\": true, \"inputs\": [], \"name\": \"getBlockNumber\", \"outputs\": [ { \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" },\r\n     *     { \"constant\": false, \"inputs\": [ { \"name\": \"_count\", \"type\": \"uint256\" } ], \"name\": \"setCount\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" },\r\n     *     { \"inputs\": [ { \"name\": \"_a\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"constructor\" }\r\n     * ],'0x{byte code}', 1)\r\n     *\r\n     * @method encodeContractDeploy\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {Array.<object>} jsonInterface The JSON interface of the contract.\r\n     * @param {string} bytecode A bytecode of smart contract to be deployed.\r\n     * @param {...*} [args] Arguments to pass to the constructor.\r\n     * @return {string} bytecode + args\r\n     */\n\n  }, {\n    key: \"encodeContractDeploy\",\n    value: function encodeContractDeploy(jsonInterface, bytecode) {\n      if (!jsonInterface) {\n        throw new Error('jsonInterface should be provided for encoding contract deployment.');\n      }\n\n      if (!bytecode) {\n        throw new Error('bytecode should be provided for encoding contract deployment.');\n      }\n\n      var constructorInterface = jsonInterface.filter(function (_ref) {\n        var type = _ref.type;\n        return type === 'constructor';\n      })[0];\n      var constructorInputs = constructorInterface && constructorInterface.inputs; // If constructor doesn't exist in smart contract, only bytecode is needed for deploying.\n\n      if (!constructorInterface || !constructorInputs || _.isEmpty(constructorInputs)) {\n        return bytecode;\n      }\n\n      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n\n      if (constructorInputs.length !== args.length) {\n        throw new Error(\"invalid number of parameters for deploying. Got \".concat(args.length, \" expected \").concat(constructorInputs.length, \"!\"));\n      }\n\n      var constructorTypes = constructorInputs.map(function (_ref2) {\n        var type = _ref2.type;\n        return type;\n      });\n      return bytecode + this.encodeParameters(constructorTypes, args).replace('0x', '');\n    }\n    /**\r\n     * Map types if simplified format is used\r\n     *\r\n     * @method mapTypes\r\n     * @memberof ABI\r\n     * @ignore\r\n     * @instance\r\n     * @param {Array} types\r\n     * @return {Array}\r\n     */\n\n  }, {\n    key: \"mapTypes\",\n    value: function mapTypes(types) {\n      var self = this;\n      var mappedTypes = [];\n      types.forEach(function (type) {\n        // Remap `function` type params to bytes24 since Ethers does not\n        // recognize former type. Solidity docs say `Function` is a bytes24\n        // encoding the contract address followed by the function selector hash.\n        if (typeof type === 'object' && type.type === 'function') {\n          type = _objectSpread(_objectSpread({}, type), {}, {\n            type: 'bytes24'\n          });\n        }\n\n        if (self.isSimplifiedStructFormat(type)) {\n          var structName = Object.keys(type)[0];\n          mappedTypes.push(Object.assign(self.mapStructNameAndType(structName), {\n            components: self.mapStructToCoderFormat(type[structName])\n          }));\n          return;\n        }\n\n        mappedTypes.push(type);\n      });\n      return mappedTypes;\n    }\n    /**\r\n     * Check if type is simplified struct format\r\n     *\r\n     * @method isSimplifiedStructFormat\r\n     * @memberof ABI\r\n     * @ignore\r\n     * @instance\r\n     * @param {string|Object} type\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isSimplifiedStructFormat\",\n    value: function isSimplifiedStructFormat(type) {\n      return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n    }\n    /**\r\n     * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\r\n     *\r\n     * @method mapStructNameAndType\r\n     * @memberof ABI\r\n     * @ignore\r\n     * @instance\r\n     * @param {string} structName\r\n     * @return {{type: string, name: *}}\r\n     */\n\n  }, {\n    key: \"mapStructNameAndType\",\n    value: function mapStructNameAndType(structName) {\n      var type = 'tuple';\n\n      if (structName.indexOf('[]') > -1) {\n        type = 'tuple[]';\n        structName = structName.slice(0, -2);\n      }\n\n      return {\n        type: type,\n        name: structName\n      };\n    }\n    /**\r\n     * Maps the simplified format in to the expected format of the ABI\r\n     *\r\n     * @method mapStructToCoderFormat\r\n     * @memberof ABI\r\n     * @ignore\r\n     * @instance\r\n     * @param {object} struct\r\n     * @return {Array}\r\n     */\n\n  }, {\n    key: \"mapStructToCoderFormat\",\n    value: function mapStructToCoderFormat(struct) {\n      var self = this;\n      var components = [];\n      Object.keys(struct).forEach(function (key) {\n        if (typeof struct[key] === 'object') {\n          components.push(Object.assign(self.mapStructNameAndType(key), {\n            components: self.mapStructToCoderFormat(struct[key])\n          }));\n          return;\n        }\n\n        components.push({\n          name: key,\n          type: struct[key]\n        });\n      });\n      return components;\n    }\n    /**\r\n     * Handle some formatting of params for backwards compatability with Ethers V4\r\n     *\r\n     * @method formatParam\r\n     * @memberof ABI\r\n     * @ignore\r\n     * @param {string} - type\r\n     * @param {any} - param\r\n     * @return {string|Array.<string>} - The formatted param\r\n     */\n\n  }, {\n    key: \"formatParam\",\n    value: function formatParam(type, param) {\n      var _this2 = this;\n\n      var paramTypeBytes = /^bytes([0-9]*)$/;\n      var paramTypeBytesArray = /^bytes([0-9]*)\\[\\]$/;\n      var paramTypeNumber = /^(u?int)([0-9]*)$/;\n      var paramTypeNumberArray = /^(u?int)([0-9]*)\\[\\]$/; // Format BN to string\n\n      if (utils.isBN(param) || utils.isBigNumber(param)) {\n        return param.toString(10);\n      }\n\n      if (type.match(paramTypeBytesArray) || type.match(paramTypeNumberArray)) {\n        return param.map(function (p) {\n          return _this2.formatParam(type.replace('[]', ''), p);\n        });\n      } // Format correct width for u?int[0-9]*\n\n\n      var match = type.match(paramTypeNumber);\n\n      if (match) {\n        var size = parseInt(match[2] || '256');\n\n        if (size / 8 < param.length) {\n          // pad to correct bit width\n          param = utils.leftPad(param, size);\n        }\n      } // Format correct length for bytes[0-9]+\n\n\n      match = type.match(paramTypeBytes);\n\n      if (match) {\n        if (Buffer.isBuffer(param)) {\n          param = utils.toHex(param);\n        } // format to correct length\n\n\n        var _size = parseInt(match[1]);\n\n        if (_size) {\n          var maxSize = _size * 2;\n\n          if (param.substring(0, 2) === '0x') {\n            maxSize += 2;\n          }\n\n          if (param.length < maxSize) {\n            // pad to correct length\n            param = utils.rightPad(param, _size * 2);\n          }\n        } // format odd-length bytes to even-length\n\n\n        if (param.length % 2 === 1) {\n          param = \"0x0\".concat(param.substring(2));\n        }\n      }\n\n      return param;\n    }\n    /**\r\n     * Encodes a function call from its json interface and parameters.\r\n     *\r\n     * @example\r\n     * caver.abi.encodeFunctionCall({\r\n     *     name: 'myMethod',\r\n     *     type: 'function',\r\n     *     inputs: [{\r\n     *         type: 'uint256',\r\n     *         name: 'myNumber'\r\n     * },{\r\n     *         type: 'string',\r\n     *         name: 'mystring'\r\n     *     }]\r\n     * }, ['2345675643', 'Hello!%'])\r\n     *\r\n     * @method encodeFunctionCall\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {object} jsonInterface The JSON interface object of a function.\r\n     * @param {Array.<*>} [params] The parameters to encode.\r\n     * @return {string} The encoded ABI for this function call\r\n     */\n\n  }, {\n    key: \"encodeFunctionCall\",\n    value: function encodeFunctionCall(jsonInterface, params) {\n      params = params || [];\n      return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');\n    }\n    /**\r\n     * Decodes a function call from its abi object of a function and returns parameters.\r\n     * If the function signature of the `abi` passed as a parameter does not match the function signature of the `functionCall`, an error is returned.\r\n     *\r\n     * @example\r\n     * const abi = {\r\n     *    name: 'myMethod',\r\n     *    type: 'function',\r\n     *    inputs: [\r\n     *        {\r\n     *            type: 'uint256',\r\n     *           name: 'myNumber',\r\n     *       },\r\n     *       {\r\n     *           type: 'string',\r\n     *           name: 'mystring',\r\n     *       },\r\n     *   ],\r\n     * }\r\n     * const functionCall = '0x24ef0...'\r\n     * caver.abi.decodeFunctionCall(abi, functionCall)\r\n     *\r\n     * @method decodeFunctionCall\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {object} abi The abi object of a function.\r\n     * @param {string} functionCall The encoded function call string.\r\n     * @return {object} An object which includes plain params. You can use `result[0]` as it is provided to be accessed like an array in the order of the parameters.\r\n     */\n\n  }, {\n    key: \"decodeFunctionCall\",\n    value: function decodeFunctionCall(abi, functionCall) {\n      functionCall = utils.addHexPrefix(functionCall);\n      if (!_.isObject(abi) || _.isArray(abi)) throw new Error(\"Invalid abi parameter type: To decode function call, you need to pass an abi object of the function as a first parameter.\");\n      if (!abi.name || !abi.inputs) throw new Error(\"Insufficient info in abi object: The function name and inputs must be defined inside the abi function object.\");\n      var funcSig = this.encodeFunctionSignature(abi);\n      var extractFuncSig = functionCall.slice(0, funcSig.length);\n      if (funcSig !== extractFuncSig) throw new Error(\"Invalid function signature: The function signature of the abi as a parameter and the function signatures extracted from the function call string do not match.\");\n      return this.decodeParameters(abi.inputs, \"0x\".concat(functionCall.slice(funcSig.length)));\n    }\n    /**\r\n     * Decodes an ABI encoded parameter to its JavaScript type.\r\n     *\r\n     * @example\r\n     * caver.abi.decodeParameter('uint256', '0x0000000000000000000000000000000000000000000000000000000000000010')\r\n     *\r\n     * caver.abi.decodeParameter('string', '0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000848656c6c6f212521000000000000000000000000000000000000000000000000')\r\n     *\r\n     * caver.abi.decodeParameter('tuple(bytes32,bool)', '0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a180000000000000000000000000000000000000000000000000000000000000001')\r\n     *\r\n     * caver.abi.decodeParameter(\r\n     *     {\r\n     *         components: [{ name: 'a', type: 'bytes32' }, { name: 'b', type: 'bool' }],\r\n     *         name: 'tupleExample',\r\n     *         type: 'tuple',\r\n     *     }, '0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a180000000000000000000000000000000000000000000000000000000000000001'\r\n     * )\r\n     *\r\n     * @method decodeParameter\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {string|object} type The type of the parameter, see the {@link http://solidity.readthedocs.io/en/develop/types.html|solidity documentation} for a list of types.\r\n     * @param {string} encodedString The ABI byte code to decode.\r\n     * @return {string} plain param\r\n     */\n\n  }, {\n    key: \"decodeParameter\",\n    value: function decodeParameter(type, encodedString) {\n      return this.decodeParameters([type], encodedString)[0];\n    }\n    /**\r\n     * Decodes ABI encoded parameters to its JavaScript types.\r\n     *\r\n     * @example\r\n     * caver.abi.decodeParameters(['string', 'uint256'], '0x000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000ea000000000000000000000000000000000000000000000000000000000000000848656c6c6f212521000000000000000000000000000000000000000000000000')\r\n     *\r\n     * caver.abi.decodeParameters(\r\n     *  ['tuple(bytes32,bool)', 'tuple(bool,address)'],\r\n     *  '0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a180000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000077656c636f6d6520746f20657468657265756d2e'\r\n     * )\r\n     *\r\n     * caver.abi.decodeParameters([{\r\n     *     type: 'string',\r\n     *     name: 'mystring'\r\n     * },{\r\n     *     type: 'uint256',\r\n     *     name: 'myNumber'\r\n     * }], '0x000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000ea000000000000000000000000000000000000000000000000000000000000000848656c6c6f212521000000000000000000000000000000000000000000000000')\r\n     *\r\n     * caver.abi.decodeParameters(\r\n     *     [\r\n     *         {\r\n     *             components: [{ name: 'a', type: 'bytes32' }, { name: 'b', type: 'bool' }],\r\n     *             name: 'tupleExample',\r\n     *             type: 'tuple',\r\n     *         },\r\n     *         {\r\n     *             components: [{ name: 'c', type: 'bool' }, { name: 'd', type: 'address' }],\r\n     *             name: 'tupleExample2',\r\n     *             type: 'tuple',\r\n     *         },\r\n     *     ],\r\n     *     '0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a180000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000077656c636f6d6520746f20657468657265756d2e'\r\n     * )\r\n     *\r\n     * @method decodeParameters\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {Array.<string|object>} typesArray An array with types or an array of JSON interface outputs. See the {@link http://solidity.readthedocs.io/en/develop/types.html|solidity documentation} for a list of types.\r\n     * @param {string} encodedString The ABI byte code to decode.\r\n     * @return {object} An object which includes plain params. You can use `result[0]` as it is provided to be accessed like an array in the order of the parameters.\r\n     */\n\n  }, {\n    key: \"decodeParameters\",\n    value: function decodeParameters(outputs, encodedString) {\n      return this.decodeParametersWith(outputs, encodedString, false);\n    }\n    /**\r\n     * Should be used to decode list of params\r\n     *\r\n     * @method decodeParametersWith\r\n     * @memberof ABI\r\n     * @instance\r\n     * @ignore\r\n     * @param {Array} outputs\r\n     * @param {string} bytes\r\n     * @param {Boolean} loose must be passed for decoding bytes and string parameters for logs emitted with solc 0.4.x\r\n     *                        Please refer to https://github.com/ChainSafe/web3.js/commit/e80337e16e5c04683fc40148378775234c28e0fb.\r\n     * @return {object} An object which includes plain params. You can use `result[0]` as it is provided to be accessed like an array in the order of the parameters.\r\n     */\n\n  }, {\n    key: \"decodeParametersWith\",\n    value: function decodeParametersWith(outputs, bytes, loose) {\n      if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\n        throw new Error(\"Returned values aren't valid, did it run Out of Gas? \" + 'You might also see this error if you are not using the ' + 'correct ABI for the contract you are retrieving data from, ' + 'requesting data from a block number that does not exist, ' + 'or querying a node which is not fully synced.');\n      }\n\n      var res = ethersAbiCoder.decode(this.mapTypes(outputs), \"0x\".concat(bytes.replace(/0x/i, '')), loose);\n      var returnValue = new Result();\n      returnValue.__length__ = 0;\n      outputs.forEach(function (output, i) {\n        var decodedValue = res[returnValue.__length__];\n        decodedValue = decodedValue === '0x' ? null : decodedValue;\n        returnValue[i] = decodedValue;\n\n        if (_.isObject(output) && output.name) {\n          returnValue[output.name] = decodedValue;\n        }\n\n        returnValue.__length__++;\n      });\n      return returnValue;\n    }\n    /**\r\n     * Decodes ABI encoded log data and indexed topic data.\r\n     *\r\n     * @example\r\n     * caver.abi.decodeLog(\r\n     *     [\r\n     *         {\r\n     *             type: 'string',\r\n     *             name: 'mystring'\r\n     *         },{\r\n     *             type: 'uint256',\r\n     *             name: 'myNumber',\r\n     *             indexed: true\r\n     *         },{\r\n     *             type: 'uint8',\r\n     *             name: 'mySmallNumber',\r\n     *             indexed: true\r\n     *          }\r\n     *     ],\r\n     *     '0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000748656c6c6f252100000000000000000000000000000000000000000000000000',\r\n     *      ['0x000000000000000000000000000000000000000000000000000000000000f310', '0x0000000000000000000000000000000000000000000000000000000000000010']\r\n     * )\r\n     *\r\n     *\r\n     * @method decodeLog\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {Array.<object>} inputs An array of JSON interface inputs. See the solidity documentation for a list of types.\r\n     * @param {string} data The ABI byte code in the data field of a log.\r\n     * @param {*} topics An array of the index parameter topics of the log. This array doesn't have topic[0] if it is a non-anonymous event, or otherwise, it has topic[0].\r\n     * @return {object} An object which includes plain params. You can use `result[0]` as it is provided to be accessed like an array in the order of the parameters.\r\n     */\n\n  }, {\n    key: \"decodeLog\",\n    value: function decodeLog(inputs, data, topics) {\n      var _this = this;\n\n      topics = _.isArray(topics) ? topics : [topics];\n      data = data || '';\n      var notIndexedInputs = [];\n      var indexedParams = [];\n      var topicCount = 0; // TODO check for anonymous logs?\n\n      inputs.forEach(function (input, i) {\n        if (input.indexed) {\n          indexedParams[i] = ['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function (staticType) {\n            return input.type.indexOf(staticType) !== -1;\n          }) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];\n          topicCount++;\n        } else {\n          notIndexedInputs[i] = input;\n        }\n      });\n      var nonIndexedData = data;\n      var notIndexedParams = nonIndexedData ? this.decodeParametersWith(notIndexedInputs, nonIndexedData, true) : [];\n      var returnValue = new Result();\n      returnValue.__length__ = 0;\n      inputs.forEach(function (res, i) {\n        returnValue[i] = res.type === 'string' ? '' : null;\n\n        if (typeof notIndexedParams[i] !== 'undefined') {\n          returnValue[i] = notIndexedParams[i];\n        }\n\n        if (typeof indexedParams[i] !== 'undefined') {\n          returnValue[i] = indexedParams[i];\n        }\n\n        if (res.name) {\n          returnValue[res.name] = returnValue[i];\n        }\n\n        returnValue.__length__++;\n      });\n      return returnValue;\n    }\n  }]);\n\n  return ABI;\n}();\n/** @instance */\n\n\nvar abi = new ABI();\nmodule.exports = abi;","map":{"version":3,"names":["_","require","EthersAbiCoder","AbiCoder","ParamType","utils","ethersAbiCoder","type","value","match","isArray","isObject","constructor","name","toString","Result","ABI","functionSignature","_jsonInterfaceMethodToString","sha3","slice","eventSignature","param","encodeParameters","types","params","self","mapTypes","map","index","formatParam","Error","includes","coder","_getCoder","from","modifyParams","p","replacedType","replace","parameterType","gotCoder","coders","forEach","c","i","encode","jsonInterface","bytecode","constructorInterface","filter","constructorInputs","inputs","isEmpty","args","length","constructorTypes","mappedTypes","isSimplifiedStructFormat","structName","Object","keys","push","assign","mapStructNameAndType","components","mapStructToCoderFormat","indexOf","struct","key","paramTypeBytes","paramTypeBytesArray","paramTypeNumber","paramTypeNumberArray","isBN","isBigNumber","size","parseInt","leftPad","Buffer","isBuffer","toHex","maxSize","substring","rightPad","encodeFunctionSignature","abi","functionCall","addHexPrefix","funcSig","extractFuncSig","decodeParameters","encodedString","outputs","decodeParametersWith","bytes","loose","res","decode","returnValue","__length__","output","decodedValue","data","topics","_this","notIndexedInputs","indexedParams","topicCount","input","indexed","find","staticType","decodeParameter","nonIndexedData","notIndexedParams","module","exports"],"sources":["C:/Users/User/Documents/clone-starter-kit-08/node_modules/caver-js/packages/caver-abi/src/index.js"],"sourcesContent":["/*\r\n    Modifications copyright 2018 The caver-js Authors\r\n    This file is part of web3.js.\r\n\r\n    web3.js is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    web3.js is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n    This file is derived from web3.js/packages/web3-eth-abi/src/index.js (2019/06/12).\r\n    Modified and improved for the caver-js development.\r\n*/\r\n/**\r\n * @file index.js\r\n * @author Marek Kotewicz <marek@parity.io>\r\n * @author Fabian Vogelsteller <fabian@frozeman.de>\r\n * @date 2017\r\n */\r\n\r\nconst _ = require('lodash')\r\n\r\nconst EthersAbiCoder = require('@ethersproject/abi').AbiCoder\r\nconst ParamType = require('@ethersproject/abi').ParamType\r\nconst utils = require('../../caver-utils')\r\n\r\nconst ethersAbiCoder = new EthersAbiCoder(function(type, value) {\r\n    if (type.match(/^u?int/) && !_.isArray(value) && (!_.isObject(value) || value.constructor.name !== 'BN')) {\r\n        return value.toString()\r\n    }\r\n    return value\r\n})\r\n\r\n// result method\r\nfunction Result() {}\r\n\r\nclass ABI {\r\n    /**\r\n     * Encodes the function signature to its ABI signature, which are the first 4 bytes of the sha3 hash of the function name including parameter types.\r\n     *\r\n     * @example\r\n     * caver.abi.encodeFunctionSignature({ name: 'myMethod', type: 'function', inputs: [{ type: 'uint256', name: 'myNumber' },{ type: 'string', name: 'mystring' }]})\r\n     *\r\n     * caver.abi.encodeFunctionSignature('myMethod(uint256,string)')\r\n     *\r\n     * @method encodeFunctionSignature\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {string|object} functionSignature The function signature or the JSON interface object of the function to encode. If this is a string, it has to be in the form `function(type, type,...)`, e.g: `myFunction(uint256,uint32[],bytes10,bytes)`.\r\n     * @return {string} function signature\r\n     */\r\n    encodeFunctionSignature(functionSignature) {\r\n        if (_.isObject(functionSignature)) {\r\n            functionSignature = utils._jsonInterfaceMethodToString(functionSignature)\r\n        }\r\n\r\n        return utils.sha3(functionSignature).slice(0, 10)\r\n    }\r\n\r\n    /**\r\n     * Encodes the event signature to its ABI signature, which is the sha3 hash of the event name including input parameter types.\r\n     *\r\n     * @example\r\n     * caver.abi.encodeEventSignature({ name: 'myEvent', type: 'event', inputs: [{ type: 'uint256', name: 'myNumber' },{ type: 'string', name: 'mystring' }]})\r\n     *\r\n     * caver.abi.encodeEventSignature('myEvent(uint256,bytes32)')\r\n     *\r\n     * @method encodeEventSignature\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {string|object} eventSignature The event signature or the JSON interface object of the event to encode. If this is a string, it has to be in the form `event(type,type,...)`, e.g: `myEvent(uint256,uint32[],bytes10,bytes)`.\r\n     * @return {string} event signature\r\n     */\r\n    encodeEventSignature(eventSignature) {\r\n        if (_.isObject(eventSignature)) {\r\n            eventSignature = utils._jsonInterfaceMethodToString(eventSignature)\r\n        }\r\n\r\n        return utils.sha3(eventSignature)\r\n    }\r\n\r\n    /**\r\n     * Encodes a parameter based on its type to its ABI representation.\r\n     *\r\n     * @example\r\n     * caver.abi.encodeParameter('uint256', '2345675643')\r\n     * caver.abi.encodeParameter('bytes32[]', [caver.utils.rightPad('0xdf3234', 64), caver.utils.rightPad('0xfdfd', 64)])\r\n     * caver.abi.encodeParameter('tuple(bytes32,bool)', ['0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a18', true])\r\n     *\r\n     * @method encodeParameter\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {string|object} type The type of the parameter, see the {@link http://solidity.readthedocs.io/en/develop/types.html|solidity documentation}  for a list of types.\r\n     * @param {*} param The actual parameter to encode.\r\n     * @return {string} encoded plain param\r\n     */\r\n    encodeParameter(type, param) {\r\n        return this.encodeParameters([type], [param])\r\n    }\r\n\r\n    /**\r\n     * Encodes function parameters based on its JSON interface object.\r\n     *\r\n     * @example\r\n     * caver.abi.encodeParameters(['uint256','string'], ['2345675643', 'Hello!%'])\r\n     *\r\n     * caver.abi.encodeParameters(\r\n     *      ['tuple(bytes32,bool)', 'tuple(bool,address)'],\r\n     *      [['0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a18', true], [true, '0x77656c636f6d6520746f20657468657265756d2e']]\r\n     * )\r\n     *\r\n     * caver.abi.encodeParameters(\r\n     *   [\r\n     *       {\r\n     *           components: [{ name: 'a', type: 'bytes32' }, { name: 'b', type: 'bool' }],\r\n     *           name: 'tupleExample',\r\n     *           type: 'tuple',\r\n     *       },\r\n     *       {\r\n     *           components: [{ name: 'c', type: 'bool' }, { name: 'd', type: 'address' }],\r\n     *           name: 'tupleExample2',\r\n     *          type: 'tuple',\r\n     *      },\r\n     *  ],\r\n     *  [\r\n     *      ['0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a18', true],\r\n     *      [true, '0x77656c636f6d6520746f20657468657265756d2e']\r\n     *  ]\r\n     *)\r\n     *\r\n     * @method encodeParameters\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {Array.<string|object>} types An array with types or a JSON interface of a function. See the {@link http://solidity.readthedocs.io/en/develop/types.html|solidity documentation} for a list of types.\r\n     * @param {Array.<*>} params The parameters to encode.\r\n     * @return {string} encoded list of params\r\n     */\r\n    encodeParameters(types, params) {\r\n        const self = this\r\n        types = self.mapTypes(types)\r\n\r\n        params = params.map(function(param, index) {\r\n            let type = types[index]\r\n\r\n            // { components: [[Object], [Object]], name: 'b', type: 'tuple' }\r\n            if (typeof type === 'object' && type.type) {\r\n                // We may get a named type of shape {name, type}\r\n                type = type.type\r\n            }\r\n\r\n            param = self.formatParam(type, param)\r\n\r\n            // If the type is string but number comes in, ethersAbiCoder ignores the type and encodes successfully.\r\n            // To avoid invalid encoding value, adding error handling.\r\n            if (type === 'string' && typeof param !== 'string') throw new Error(`Invalid parameter: Parameter value and type do not match.`)\r\n\r\n            // Format params for tuples\r\n            if (typeof type === 'string' && type.includes('tuple')) {\r\n                const coder = ethersAbiCoder._getCoder(ParamType.from(type))\r\n                // eslint-disable-next-line no-shadow\r\n                const modifyParams = (coder, param) => {\r\n                    if (coder.name === 'array') {\r\n                        return param.map(p => {\r\n                            // `coder.type.replace('[]','')` can handle'tuple(string,string)[]', but cannot handle `tuple(string,string)[3]'.\r\n                            // Therefore, in order to handle tuple arrays of fixed length, the logic is changed to handle strings using regular expression expressions.\r\n                            const replacedType = coder.type.replace(/\\[[1-9]*\\]/g, '')\r\n                            const parameterType = ParamType.from(replacedType)\r\n                            const gotCoder = ethersAbiCoder._getCoder(parameterType)\r\n                            modifyParams(gotCoder, p)\r\n                        })\r\n                    }\r\n                    coder.coders.forEach((c, i) => {\r\n                        if (c.name === 'tuple') {\r\n                            modifyParams(c, param[i])\r\n                        } else {\r\n                            param[i] = self.formatParam(c.name, param[i])\r\n                        }\r\n                    })\r\n                }\r\n                modifyParams(coder, param)\r\n            }\r\n\r\n            return param\r\n        })\r\n\r\n        return ethersAbiCoder.encode(types, params)\r\n    }\r\n\r\n    /**\r\n     * Should be used to encode smart contract deployment with constructor arguments.\r\n     *\r\n     * @example\r\n     * // There is no argument for constructor\r\n     * caver.abi.encodeContractDeploy([\r\n     *     { \"constant\": true, \"inputs\": [], \"name\": \"count\", \"outputs\": [ { \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" },\r\n     *     { \"constant\": true, \"inputs\": [], \"name\": \"getBlockNumber\", \"outputs\": [ { \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" },\r\n     *     { \"constant\": false, \"inputs\": [ { \"name\": \"_count\", \"type\": \"uint256\" } ], \"name\": \"setCount\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" }\r\n     * ],'0x{byte code}')\r\n     *\r\n     * // There is one argument for constructor\r\n     * caver.abi.encodeContractDeploy([\r\n     *     { \"constant\": true, \"inputs\": [], \"name\": \"count\", \"outputs\": [ { \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" },\r\n     *     { \"constant\": true, \"inputs\": [], \"name\": \"getBlockNumber\", \"outputs\": [ { \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" },\r\n     *     { \"constant\": false, \"inputs\": [ { \"name\": \"_count\", \"type\": \"uint256\" } ], \"name\": \"setCount\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" },\r\n     *     { \"inputs\": [ { \"name\": \"_a\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"constructor\" }\r\n     * ],'0x{byte code}', 1)\r\n     *\r\n     * @method encodeContractDeploy\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {Array.<object>} jsonInterface The JSON interface of the contract.\r\n     * @param {string} bytecode A bytecode of smart contract to be deployed.\r\n     * @param {...*} [args] Arguments to pass to the constructor.\r\n     * @return {string} bytecode + args\r\n     */\r\n    encodeContractDeploy(jsonInterface, bytecode, ...args) {\r\n        if (!jsonInterface) {\r\n            throw new Error('jsonInterface should be provided for encoding contract deployment.')\r\n        }\r\n\r\n        if (!bytecode) {\r\n            throw new Error('bytecode should be provided for encoding contract deployment.')\r\n        }\r\n\r\n        const constructorInterface = jsonInterface.filter(({ type }) => type === 'constructor')[0]\r\n        const constructorInputs = constructorInterface && constructorInterface.inputs\r\n\r\n        // If constructor doesn't exist in smart contract, only bytecode is needed for deploying.\r\n        if (!constructorInterface || !constructorInputs || _.isEmpty(constructorInputs)) {\r\n            return bytecode\r\n        }\r\n\r\n        if (constructorInputs.length !== args.length) {\r\n            throw new Error(`invalid number of parameters for deploying. Got ${args.length} expected ${constructorInputs.length}!`)\r\n        }\r\n\r\n        const constructorTypes = constructorInputs.map(({ type }) => type)\r\n\r\n        return bytecode + this.encodeParameters(constructorTypes, args).replace('0x', '')\r\n    }\r\n\r\n    /**\r\n     * Map types if simplified format is used\r\n     *\r\n     * @method mapTypes\r\n     * @memberof ABI\r\n     * @ignore\r\n     * @instance\r\n     * @param {Array} types\r\n     * @return {Array}\r\n     */\r\n    mapTypes(types) {\r\n        const self = this\r\n        const mappedTypes = []\r\n        types.forEach(function(type) {\r\n            // Remap `function` type params to bytes24 since Ethers does not\r\n            // recognize former type. Solidity docs say `Function` is a bytes24\r\n            // encoding the contract address followed by the function selector hash.\r\n            if (typeof type === 'object' && type.type === 'function') {\r\n                type = { ...type, type: 'bytes24' }\r\n            }\r\n            if (self.isSimplifiedStructFormat(type)) {\r\n                const structName = Object.keys(type)[0]\r\n                mappedTypes.push(\r\n                    Object.assign(self.mapStructNameAndType(structName), {\r\n                        components: self.mapStructToCoderFormat(type[structName]),\r\n                    })\r\n                )\r\n\r\n                return\r\n            }\r\n\r\n            mappedTypes.push(type)\r\n        })\r\n        return mappedTypes\r\n    }\r\n\r\n    /**\r\n     * Check if type is simplified struct format\r\n     *\r\n     * @method isSimplifiedStructFormat\r\n     * @memberof ABI\r\n     * @ignore\r\n     * @instance\r\n     * @param {string|Object} type\r\n     * @returns {boolean}\r\n     */\r\n    isSimplifiedStructFormat(type) {\r\n        return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined'\r\n    }\r\n\r\n    /**\r\n     * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\r\n     *\r\n     * @method mapStructNameAndType\r\n     * @memberof ABI\r\n     * @ignore\r\n     * @instance\r\n     * @param {string} structName\r\n     * @return {{type: string, name: *}}\r\n     */\r\n    mapStructNameAndType(structName) {\r\n        let type = 'tuple'\r\n\r\n        if (structName.indexOf('[]') > -1) {\r\n            type = 'tuple[]'\r\n            structName = structName.slice(0, -2)\r\n        }\r\n\r\n        return { type: type, name: structName }\r\n    }\r\n\r\n    /**\r\n     * Maps the simplified format in to the expected format of the ABI\r\n     *\r\n     * @method mapStructToCoderFormat\r\n     * @memberof ABI\r\n     * @ignore\r\n     * @instance\r\n     * @param {object} struct\r\n     * @return {Array}\r\n     */\r\n    mapStructToCoderFormat(struct) {\r\n        const self = this\r\n        const components = []\r\n        Object.keys(struct).forEach(function(key) {\r\n            if (typeof struct[key] === 'object') {\r\n                components.push(\r\n                    Object.assign(self.mapStructNameAndType(key), {\r\n                        components: self.mapStructToCoderFormat(struct[key]),\r\n                    })\r\n                )\r\n\r\n                return\r\n            }\r\n\r\n            components.push({\r\n                name: key,\r\n                type: struct[key],\r\n            })\r\n        })\r\n\r\n        return components\r\n    }\r\n\r\n    /**\r\n     * Handle some formatting of params for backwards compatability with Ethers V4\r\n     *\r\n     * @method formatParam\r\n     * @memberof ABI\r\n     * @ignore\r\n     * @param {string} - type\r\n     * @param {any} - param\r\n     * @return {string|Array.<string>} - The formatted param\r\n     */\r\n    formatParam(type, param) {\r\n        const paramTypeBytes = /^bytes([0-9]*)$/\r\n        const paramTypeBytesArray = /^bytes([0-9]*)\\[\\]$/\r\n        const paramTypeNumber = /^(u?int)([0-9]*)$/\r\n        const paramTypeNumberArray = /^(u?int)([0-9]*)\\[\\]$/\r\n\r\n        // Format BN to string\r\n        if (utils.isBN(param) || utils.isBigNumber(param)) {\r\n            return param.toString(10)\r\n        }\r\n\r\n        if (type.match(paramTypeBytesArray) || type.match(paramTypeNumberArray)) {\r\n            return param.map(p => this.formatParam(type.replace('[]', ''), p))\r\n        }\r\n\r\n        // Format correct width for u?int[0-9]*\r\n        let match = type.match(paramTypeNumber)\r\n        if (match) {\r\n            const size = parseInt(match[2] || '256')\r\n            if (size / 8 < param.length) {\r\n                // pad to correct bit width\r\n                param = utils.leftPad(param, size)\r\n            }\r\n        }\r\n\r\n        // Format correct length for bytes[0-9]+\r\n        match = type.match(paramTypeBytes)\r\n        if (match) {\r\n            if (Buffer.isBuffer(param)) {\r\n                param = utils.toHex(param)\r\n            }\r\n\r\n            // format to correct length\r\n            const size = parseInt(match[1])\r\n            if (size) {\r\n                let maxSize = size * 2\r\n                if (param.substring(0, 2) === '0x') {\r\n                    maxSize += 2\r\n                }\r\n                if (param.length < maxSize) {\r\n                    // pad to correct length\r\n                    param = utils.rightPad(param, size * 2)\r\n                }\r\n            }\r\n\r\n            // format odd-length bytes to even-length\r\n            if (param.length % 2 === 1) {\r\n                param = `0x0${param.substring(2)}`\r\n            }\r\n        }\r\n\r\n        return param\r\n    }\r\n\r\n    /**\r\n     * Encodes a function call from its json interface and parameters.\r\n     *\r\n     * @example\r\n     * caver.abi.encodeFunctionCall({\r\n     *     name: 'myMethod',\r\n     *     type: 'function',\r\n     *     inputs: [{\r\n     *         type: 'uint256',\r\n     *         name: 'myNumber'\r\n     * },{\r\n     *         type: 'string',\r\n     *         name: 'mystring'\r\n     *     }]\r\n     * }, ['2345675643', 'Hello!%'])\r\n     *\r\n     * @method encodeFunctionCall\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {object} jsonInterface The JSON interface object of a function.\r\n     * @param {Array.<*>} [params] The parameters to encode.\r\n     * @return {string} The encoded ABI for this function call\r\n     */\r\n    encodeFunctionCall(jsonInterface, params) {\r\n        params = params || []\r\n        return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '')\r\n    }\r\n\r\n    /**\r\n     * Decodes a function call from its abi object of a function and returns parameters.\r\n     * If the function signature of the `abi` passed as a parameter does not match the function signature of the `functionCall`, an error is returned.\r\n     *\r\n     * @example\r\n     * const abi = {\r\n     *    name: 'myMethod',\r\n     *    type: 'function',\r\n     *    inputs: [\r\n     *        {\r\n     *            type: 'uint256',\r\n     *           name: 'myNumber',\r\n     *       },\r\n     *       {\r\n     *           type: 'string',\r\n     *           name: 'mystring',\r\n     *       },\r\n     *   ],\r\n     * }\r\n     * const functionCall = '0x24ef0...'\r\n     * caver.abi.decodeFunctionCall(abi, functionCall)\r\n     *\r\n     * @method decodeFunctionCall\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {object} abi The abi object of a function.\r\n     * @param {string} functionCall The encoded function call string.\r\n     * @return {object} An object which includes plain params. You can use `result[0]` as it is provided to be accessed like an array in the order of the parameters.\r\n     */\r\n    decodeFunctionCall(abi, functionCall) {\r\n        functionCall = utils.addHexPrefix(functionCall)\r\n\r\n        if (!_.isObject(abi) || _.isArray(abi))\r\n            throw new Error(\r\n                `Invalid abi parameter type: To decode function call, you need to pass an abi object of the function as a first parameter.`\r\n            )\r\n        if (!abi.name || !abi.inputs)\r\n            throw new Error(`Insufficient info in abi object: The function name and inputs must be defined inside the abi function object.`)\r\n\r\n        const funcSig = this.encodeFunctionSignature(abi)\r\n        const extractFuncSig = functionCall.slice(0, funcSig.length)\r\n\r\n        if (funcSig !== extractFuncSig)\r\n            throw new Error(\r\n                `Invalid function signature: The function signature of the abi as a parameter and the function signatures extracted from the function call string do not match.`\r\n            )\r\n\r\n        return this.decodeParameters(abi.inputs, `0x${functionCall.slice(funcSig.length)}`)\r\n    }\r\n\r\n    /**\r\n     * Decodes an ABI encoded parameter to its JavaScript type.\r\n     *\r\n     * @example\r\n     * caver.abi.decodeParameter('uint256', '0x0000000000000000000000000000000000000000000000000000000000000010')\r\n     *\r\n     * caver.abi.decodeParameter('string', '0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000848656c6c6f212521000000000000000000000000000000000000000000000000')\r\n     *\r\n     * caver.abi.decodeParameter('tuple(bytes32,bool)', '0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a180000000000000000000000000000000000000000000000000000000000000001')\r\n     *\r\n     * caver.abi.decodeParameter(\r\n     *     {\r\n     *         components: [{ name: 'a', type: 'bytes32' }, { name: 'b', type: 'bool' }],\r\n     *         name: 'tupleExample',\r\n     *         type: 'tuple',\r\n     *     }, '0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a180000000000000000000000000000000000000000000000000000000000000001'\r\n     * )\r\n     *\r\n     * @method decodeParameter\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {string|object} type The type of the parameter, see the {@link http://solidity.readthedocs.io/en/develop/types.html|solidity documentation} for a list of types.\r\n     * @param {string} encodedString The ABI byte code to decode.\r\n     * @return {string} plain param\r\n     */\r\n    decodeParameter(type, encodedString) {\r\n        return this.decodeParameters([type], encodedString)[0]\r\n    }\r\n\r\n    /**\r\n     * Decodes ABI encoded parameters to its JavaScript types.\r\n     *\r\n     * @example\r\n     * caver.abi.decodeParameters(['string', 'uint256'], '0x000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000ea000000000000000000000000000000000000000000000000000000000000000848656c6c6f212521000000000000000000000000000000000000000000000000')\r\n     *\r\n     * caver.abi.decodeParameters(\r\n     *  ['tuple(bytes32,bool)', 'tuple(bool,address)'],\r\n     *  '0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a180000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000077656c636f6d6520746f20657468657265756d2e'\r\n     * )\r\n     *\r\n     * caver.abi.decodeParameters([{\r\n     *     type: 'string',\r\n     *     name: 'mystring'\r\n     * },{\r\n     *     type: 'uint256',\r\n     *     name: 'myNumber'\r\n     * }], '0x000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000ea000000000000000000000000000000000000000000000000000000000000000848656c6c6f212521000000000000000000000000000000000000000000000000')\r\n     *\r\n     * caver.abi.decodeParameters(\r\n     *     [\r\n     *         {\r\n     *             components: [{ name: 'a', type: 'bytes32' }, { name: 'b', type: 'bool' }],\r\n     *             name: 'tupleExample',\r\n     *             type: 'tuple',\r\n     *         },\r\n     *         {\r\n     *             components: [{ name: 'c', type: 'bool' }, { name: 'd', type: 'address' }],\r\n     *             name: 'tupleExample2',\r\n     *             type: 'tuple',\r\n     *         },\r\n     *     ],\r\n     *     '0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a180000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000077656c636f6d6520746f20657468657265756d2e'\r\n     * )\r\n     *\r\n     * @method decodeParameters\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {Array.<string|object>} typesArray An array with types or an array of JSON interface outputs. See the {@link http://solidity.readthedocs.io/en/develop/types.html|solidity documentation} for a list of types.\r\n     * @param {string} encodedString The ABI byte code to decode.\r\n     * @return {object} An object which includes plain params. You can use `result[0]` as it is provided to be accessed like an array in the order of the parameters.\r\n     */\r\n    decodeParameters(outputs, encodedString) {\r\n        return this.decodeParametersWith(outputs, encodedString, false)\r\n    }\r\n\r\n    /**\r\n     * Should be used to decode list of params\r\n     *\r\n     * @method decodeParametersWith\r\n     * @memberof ABI\r\n     * @instance\r\n     * @ignore\r\n     * @param {Array} outputs\r\n     * @param {string} bytes\r\n     * @param {Boolean} loose must be passed for decoding bytes and string parameters for logs emitted with solc 0.4.x\r\n     *                        Please refer to https://github.com/ChainSafe/web3.js/commit/e80337e16e5c04683fc40148378775234c28e0fb.\r\n     * @return {object} An object which includes plain params. You can use `result[0]` as it is provided to be accessed like an array in the order of the parameters.\r\n     */\r\n    decodeParametersWith(outputs, bytes, loose) {\r\n        if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\r\n            throw new Error(\r\n                \"Returned values aren't valid, did it run Out of Gas? \" +\r\n                    'You might also see this error if you are not using the ' +\r\n                    'correct ABI for the contract you are retrieving data from, ' +\r\n                    'requesting data from a block number that does not exist, ' +\r\n                    'or querying a node which is not fully synced.'\r\n            )\r\n        }\r\n\r\n        const res = ethersAbiCoder.decode(this.mapTypes(outputs), `0x${bytes.replace(/0x/i, '')}`, loose)\r\n        const returnValue = new Result()\r\n        returnValue.__length__ = 0\r\n\r\n        outputs.forEach(function(output, i) {\r\n            let decodedValue = res[returnValue.__length__]\r\n            decodedValue = decodedValue === '0x' ? null : decodedValue\r\n\r\n            returnValue[i] = decodedValue\r\n\r\n            if (_.isObject(output) && output.name) {\r\n                returnValue[output.name] = decodedValue\r\n            }\r\n\r\n            returnValue.__length__++\r\n        })\r\n\r\n        return returnValue\r\n    }\r\n\r\n    /**\r\n     * Decodes ABI encoded log data and indexed topic data.\r\n     *\r\n     * @example\r\n     * caver.abi.decodeLog(\r\n     *     [\r\n     *         {\r\n     *             type: 'string',\r\n     *             name: 'mystring'\r\n     *         },{\r\n     *             type: 'uint256',\r\n     *             name: 'myNumber',\r\n     *             indexed: true\r\n     *         },{\r\n     *             type: 'uint8',\r\n     *             name: 'mySmallNumber',\r\n     *             indexed: true\r\n     *          }\r\n     *     ],\r\n     *     '0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000748656c6c6f252100000000000000000000000000000000000000000000000000',\r\n     *      ['0x000000000000000000000000000000000000000000000000000000000000f310', '0x0000000000000000000000000000000000000000000000000000000000000010']\r\n     * )\r\n     *\r\n     *\r\n     * @method decodeLog\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {Array.<object>} inputs An array of JSON interface inputs. See the solidity documentation for a list of types.\r\n     * @param {string} data The ABI byte code in the data field of a log.\r\n     * @param {*} topics An array of the index parameter topics of the log. This array doesn't have topic[0] if it is a non-anonymous event, or otherwise, it has topic[0].\r\n     * @return {object} An object which includes plain params. You can use `result[0]` as it is provided to be accessed like an array in the order of the parameters.\r\n     */\r\n    decodeLog(inputs, data, topics) {\r\n        const _this = this\r\n        topics = _.isArray(topics) ? topics : [topics]\r\n\r\n        data = data || ''\r\n\r\n        const notIndexedInputs = []\r\n        const indexedParams = []\r\n        let topicCount = 0\r\n\r\n        // TODO check for anonymous logs?\r\n\r\n        inputs.forEach(function(input, i) {\r\n            if (input.indexed) {\r\n                indexedParams[i] = ['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function(staticType) {\r\n                    return input.type.indexOf(staticType) !== -1\r\n                })\r\n                    ? _this.decodeParameter(input.type, topics[topicCount])\r\n                    : topics[topicCount]\r\n                topicCount++\r\n            } else {\r\n                notIndexedInputs[i] = input\r\n            }\r\n        })\r\n\r\n        const nonIndexedData = data\r\n        const notIndexedParams = nonIndexedData ? this.decodeParametersWith(notIndexedInputs, nonIndexedData, true) : []\r\n\r\n        const returnValue = new Result()\r\n        returnValue.__length__ = 0\r\n\r\n        inputs.forEach(function(res, i) {\r\n            returnValue[i] = res.type === 'string' ? '' : null\r\n\r\n            if (typeof notIndexedParams[i] !== 'undefined') {\r\n                returnValue[i] = notIndexedParams[i]\r\n            }\r\n            if (typeof indexedParams[i] !== 'undefined') {\r\n                returnValue[i] = indexedParams[i]\r\n            }\r\n\r\n            if (res.name) {\r\n                returnValue[res.name] = returnValue[i]\r\n            }\r\n\r\n            returnValue.__length__++\r\n        })\r\n\r\n        return returnValue\r\n    }\r\n}\r\n\r\n/** @instance */\r\nconst abi = new ABI()\r\n\r\nmodule.exports = abi\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}