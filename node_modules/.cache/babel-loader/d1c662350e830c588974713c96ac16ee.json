{"ast":null,"code":"var _createForOfIteratorHelper = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _get = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createSuper\");\n\nvar _wrapNativeSuper = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/wrapNativeSuper\");\n\n/*\r\n    Copyright 2022 The caver-js Authors\r\n    This file is part of the caver-js library.\r\n\r\n    The caver-js library is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    The caver-js library is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\r\n*/\nvar AccessTuple = require('./accessTuple');\n/**\r\n * Represents an access list.\r\n * AccessList is an EIP-2930 access list.\r\n * @class\r\n */\n\n\nvar AccessList = /*#__PURE__*/function (_Array) {\n  \"use strict\";\n\n  _inherits(AccessList, _Array);\n\n  var _super = _createSuper(AccessList);\n\n  function AccessList() {\n    _classCallCheck(this, AccessList);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(AccessList, [{\n    key: \"push\",\n    value:\n    /**\r\n     * Added access tuple in access list.\r\n     *\r\n     * @example\r\n     * accessList.push(caver.transaction.utils.accessTuple.create('0x{address in hex}', [ '0x{storage key}' ]))\r\n     * accessList.push({ address: '0x{address in hex}', storageKeys: [ '0x{storage key}' ] })\r\n     *\r\n     * @param {AccessTuple | module:Transaction.AccessTupleObject} item - An object of the access list item.\r\n     * @return {number}\r\n     */\n    function push(item) {\n      if (!(item instanceof AccessTuple)) item = AccessTuple.create(item);\n      return _get(_getPrototypeOf(AccessList.prototype), \"push\", this).call(this, item);\n    }\n    /**\r\n     * Returns an encoded access list.\r\n     *\r\n     * @example\r\n     * const result = accessList.encodeToBytes()\r\n     *\r\n     * @return {Array.<Array.<string|Array.<string>>>} An encoded access list.\r\n     */\n\n  }, {\n    key: \"encodeToBytes\",\n    value: function encodeToBytes() {\n      var bufferAccessList = [];\n\n      for (var i = 0; i < this.length; i++) {\n        var item = this[i];\n        bufferAccessList.push(item.encodeToBytes());\n      }\n\n      return bufferAccessList;\n    }\n    /**\r\n     * Returns whether the AccessList object is the same as the accessList passed as a parameter.\r\n     *\r\n     * @example\r\n     * const result = accessList.isEqual(acl)\r\n     *\r\n     * @return {boolean} Returns `true` is accessList has value with a param.\r\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(acl) {\n      if (this.length !== acl.length) return false;\n\n      for (var i = 0; i < this.length; i++) {\n        var item = this[i];\n        var target = acl[i];\n        if (!item.isEqual(target)) return false;\n      }\n\n      return true;\n    }\n    /**\r\n     * Returns a JSON object without _ prefix variable name.\r\n     *\r\n     * @example\r\n     * const result = accessList.toObject()\r\n     *\r\n     * @return {Array.<module:Transaction.AccessTupleObject>} An access list object.\r\n     */\n\n  }, {\n    key: \"toObject\",\n    value: function toObject() {\n      var accessListObject = [];\n\n      for (var i = 0; i < this.length; i++) {\n        accessListObject.push(this[i].toObject());\n      }\n\n      return accessListObject;\n    }\n  }], [{\n    key: \"create\",\n    value:\n    /**\r\n     * Creates an access list.\r\n     *\r\n     * @example\r\n     * const items = [\r\n     *      caver.transaction.utils.accessTuple.create('0x{address in hex}', [ '0x{storage key}' ]),\r\n     *      caver.transaction.utils.accessTuple.create('0x{address in hex}', [ '0x{storage key}' ]),\r\n     * ]\r\n     * const result = caver.transaction.utils.accessList.create(items)\r\n     *\r\n     *\r\n     * const items = [\r\n     *      { address: '0x{address in hex}', storageKeys: [ '0x{storage key}' ] },\r\n     *      { address: '0x{address in hex}', storageKeys: [ '0x{storage key}' ] },\r\n     * ]\r\n     * const result = caver.transaction.utils.accessList.create(items)\r\n     *\r\n     * @param {Array.<AccessTuple> | Array.<module:Transaction.AccessTupleObject>} items - An array of the access list items.\r\n     * @return {AccessList} An access list.\r\n     */\n    function create(items) {\n      var accessList = new AccessList();\n\n      var _iterator = _createForOfIteratorHelper(items),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n          accessList.push(AccessTuple.create(item.address, item.storageKeys));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return accessList;\n    }\n    /**\r\n     * Returns a decoded access list.\r\n     *\r\n     * @example\r\n     * const encoded = [\r\n     *      [\r\n     *          '0xac60c5e6d2a8f3fe856ad0a39522098e03065893',\r\n     *          [\r\n     *              '0x0000000000000000000000000000000000000000000000000000000000000000'\r\n     *          ]\r\n     *      ]\r\n     * ]\r\n     * const result = caver.transaction.utils.accessList.decode(encoded)\r\n     *\r\n     * @param {Array.<Array.<string|Array.<string>>> items - An encoded access list.\r\n     * @return {AccessList} An access list.\r\n     */\n\n  }, {\n    key: \"decode\",\n    value: function decode(encoded) {\n      var accessList = new AccessList();\n\n      var _iterator2 = _createForOfIteratorHelper(encoded),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var item = _step2.value;\n          accessList.push(AccessTuple.create(item[0], item[1]));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return accessList;\n    }\n  }]);\n\n  return AccessList;\n}( /*#__PURE__*/_wrapNativeSuper(Array));\n\nmodule.exports = AccessList;","map":{"version":3,"names":["AccessTuple","require","AccessList","item","create","bufferAccessList","i","length","push","encodeToBytes","acl","target","isEqual","accessListObject","toObject","items","accessList","address","storageKeys","encoded","Array","module","exports"],"sources":["C:/Users/User/Documents/clone-starter-kit-08/node_modules/caver-js/packages/caver-transaction/src/utils/accessList.js"],"sourcesContent":["/*\r\n    Copyright 2022 The caver-js Authors\r\n    This file is part of the caver-js library.\r\n\r\n    The caver-js library is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    The caver-js library is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst AccessTuple = require('./accessTuple')\r\n\r\n/**\r\n * Represents an access list.\r\n * AccessList is an EIP-2930 access list.\r\n * @class\r\n */\r\nclass AccessList extends Array {\r\n    /**\r\n     * Creates an access list.\r\n     *\r\n     * @example\r\n     * const items = [\r\n     *      caver.transaction.utils.accessTuple.create('0x{address in hex}', [ '0x{storage key}' ]),\r\n     *      caver.transaction.utils.accessTuple.create('0x{address in hex}', [ '0x{storage key}' ]),\r\n     * ]\r\n     * const result = caver.transaction.utils.accessList.create(items)\r\n     *\r\n     *\r\n     * const items = [\r\n     *      { address: '0x{address in hex}', storageKeys: [ '0x{storage key}' ] },\r\n     *      { address: '0x{address in hex}', storageKeys: [ '0x{storage key}' ] },\r\n     * ]\r\n     * const result = caver.transaction.utils.accessList.create(items)\r\n     *\r\n     * @param {Array.<AccessTuple> | Array.<module:Transaction.AccessTupleObject>} items - An array of the access list items.\r\n     * @return {AccessList} An access list.\r\n     */\r\n    static create(items) {\r\n        const accessList = new AccessList()\r\n        for (const item of items) {\r\n            accessList.push(AccessTuple.create(item.address, item.storageKeys))\r\n        }\r\n        return accessList\r\n    }\r\n\r\n    /**\r\n     * Returns a decoded access list.\r\n     *\r\n     * @example\r\n     * const encoded = [\r\n     *      [\r\n     *          '0xac60c5e6d2a8f3fe856ad0a39522098e03065893',\r\n     *          [\r\n     *              '0x0000000000000000000000000000000000000000000000000000000000000000'\r\n     *          ]\r\n     *      ]\r\n     * ]\r\n     * const result = caver.transaction.utils.accessList.decode(encoded)\r\n     *\r\n     * @param {Array.<Array.<string|Array.<string>>> items - An encoded access list.\r\n     * @return {AccessList} An access list.\r\n     */\r\n    static decode(encoded) {\r\n        const accessList = new AccessList()\r\n        for (const item of encoded) {\r\n            accessList.push(AccessTuple.create(item[0], item[1]))\r\n        }\r\n        return accessList\r\n    }\r\n\r\n    /**\r\n     * Added access tuple in access list.\r\n     *\r\n     * @example\r\n     * accessList.push(caver.transaction.utils.accessTuple.create('0x{address in hex}', [ '0x{storage key}' ]))\r\n     * accessList.push({ address: '0x{address in hex}', storageKeys: [ '0x{storage key}' ] })\r\n     *\r\n     * @param {AccessTuple | module:Transaction.AccessTupleObject} item - An object of the access list item.\r\n     * @return {number}\r\n     */\r\n    push(item) {\r\n        if (!(item instanceof AccessTuple)) item = AccessTuple.create(item)\r\n        return super.push(item)\r\n    }\r\n\r\n    /**\r\n     * Returns an encoded access list.\r\n     *\r\n     * @example\r\n     * const result = accessList.encodeToBytes()\r\n     *\r\n     * @return {Array.<Array.<string|Array.<string>>>} An encoded access list.\r\n     */\r\n    encodeToBytes() {\r\n        const bufferAccessList = []\r\n        for (let i = 0; i < this.length; i++) {\r\n            const item = this[i]\r\n            bufferAccessList.push(item.encodeToBytes())\r\n        }\r\n        return bufferAccessList\r\n    }\r\n\r\n    /**\r\n     * Returns whether the AccessList object is the same as the accessList passed as a parameter.\r\n     *\r\n     * @example\r\n     * const result = accessList.isEqual(acl)\r\n     *\r\n     * @return {boolean} Returns `true` is accessList has value with a param.\r\n     */\r\n    isEqual(acl) {\r\n        if (this.length !== acl.length) return false\r\n\r\n        for (let i = 0; i < this.length; i++) {\r\n            const item = this[i]\r\n            const target = acl[i]\r\n            if (!item.isEqual(target)) return false\r\n        }\r\n        return true\r\n    }\r\n\r\n    /**\r\n     * Returns a JSON object without _ prefix variable name.\r\n     *\r\n     * @example\r\n     * const result = accessList.toObject()\r\n     *\r\n     * @return {Array.<module:Transaction.AccessTupleObject>} An access list object.\r\n     */\r\n    toObject() {\r\n        const accessListObject = []\r\n        for (let i = 0; i < this.length; i++) {\r\n            accessListObject.push(this[i].toObject())\r\n        }\r\n        return accessListObject\r\n    }\r\n}\r\n\r\nmodule.exports = AccessList\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}