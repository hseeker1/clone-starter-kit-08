{"ast":null,"code":"'use strict';\n/** @typedef {import('./types').CodecFactory} CodecFactory */\n\n/**\r\n * @param {string} string\r\n * @param {string} alphabet\r\n * @param {number} bitsPerChar\r\n * @returns {Uint8Array}\r\n */\n\nconst decode = (string, alphabet, bitsPerChar) => {\n  // Build the character lookup table:\n\n  /** @type {Record<string, number>} */\n  const codes = {};\n\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  } // Count the padding bytes:\n\n\n  let end = string.length;\n\n  while (string[end - 1] === '=') {\n    --end;\n  } // Allocate the output:\n\n\n  const out = new Uint8Array(end * bitsPerChar / 8 | 0); // Parse the data:\n\n  let bits = 0; // Number of bits currently in the buffer\n\n  let buffer = 0; // Bits waiting to be written out, MSB first\n\n  let written = 0; // Next byte to write\n\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]];\n\n    if (value === undefined) {\n      throw new SyntaxError('Invalid character ' + string[i]);\n    } // Append the bits to the buffer:\n\n\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar; // Write out some bits if the buffer has a byte's worth:\n\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 0xff & buffer >> bits;\n    }\n  } // Verify that we have received just enough bits:\n\n\n  if (bits >= bitsPerChar || 0xff & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n\n  return out;\n};\n/**\r\n * @param {Uint8Array} data\r\n * @param {string} alphabet\r\n * @param {number} bitsPerChar\r\n * @returns {string}\r\n */\n\n\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '=';\n  const mask = (1 << bitsPerChar) - 1;\n  let out = '';\n  let bits = 0; // Number of bits currently in the buffer\n\n  let buffer = 0; // Bits waiting to be written out, MSB first\n\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = buffer << 8 | data[i];\n    bits += 8; // Write out as much as we can:\n\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  } // Partial character:\n\n\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  } // Add padding characters until we hit a byte boundary:\n\n\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n\n  return out;\n};\n/**\r\n * RFC4648 Factory\r\n *\r\n * @param {number} bitsPerChar\r\n * @returns {CodecFactory}\r\n */\n\n\nconst rfc4648 = bitsPerChar => alphabet => {\n  return {\n    /**\r\n     * @param {Uint8Array} input\r\n     * @returns {string}\r\n     */\n    encode(input) {\n      return encode(input, alphabet, bitsPerChar);\n    },\n\n    /**\r\n     * @param {string} input\r\n     * @returns {Uint8Array}\r\n     */\n    decode(input) {\n      return decode(input, alphabet, bitsPerChar);\n    }\n\n  };\n};\n\nmodule.exports = {\n  rfc4648\n};","map":{"version":3,"names":["decode","string","alphabet","bitsPerChar","codes","i","length","end","out","Uint8Array","bits","buffer","written","value","undefined","SyntaxError","encode","data","pad","mask","rfc4648","input","module","exports"],"sources":["C:/Users/User/Documents/clone-starter-kit-08/node_modules/ipld-dag-pb/node_modules/multibase/src/rfc4648.js"],"sourcesContent":["'use strict'\r\n\r\n/** @typedef {import('./types').CodecFactory} CodecFactory */\r\n\r\n/**\r\n * @param {string} string\r\n * @param {string} alphabet\r\n * @param {number} bitsPerChar\r\n * @returns {Uint8Array}\r\n */\r\nconst decode = (string, alphabet, bitsPerChar) => {\r\n  // Build the character lookup table:\r\n  /** @type {Record<string, number>} */\r\n  const codes = {}\r\n  for (let i = 0; i < alphabet.length; ++i) {\r\n    codes[alphabet[i]] = i\r\n  }\r\n\r\n  // Count the padding bytes:\r\n  let end = string.length\r\n  while (string[end - 1] === '=') {\r\n    --end\r\n  }\r\n\r\n  // Allocate the output:\r\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\r\n\r\n  // Parse the data:\r\n  let bits = 0 // Number of bits currently in the buffer\r\n  let buffer = 0 // Bits waiting to be written out, MSB first\r\n  let written = 0 // Next byte to write\r\n  for (let i = 0; i < end; ++i) {\r\n    // Read one character from the string:\r\n    const value = codes[string[i]]\r\n    if (value === undefined) {\r\n      throw new SyntaxError('Invalid character ' + string[i])\r\n    }\r\n\r\n    // Append the bits to the buffer:\r\n    buffer = (buffer << bitsPerChar) | value\r\n    bits += bitsPerChar\r\n\r\n    // Write out some bits if the buffer has a byte's worth:\r\n    if (bits >= 8) {\r\n      bits -= 8\r\n      out[written++] = 0xff & (buffer >> bits)\r\n    }\r\n  }\r\n\r\n  // Verify that we have received just enough bits:\r\n  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {\r\n    throw new SyntaxError('Unexpected end of data')\r\n  }\r\n\r\n  return out\r\n}\r\n\r\n/**\r\n * @param {Uint8Array} data\r\n * @param {string} alphabet\r\n * @param {number} bitsPerChar\r\n * @returns {string}\r\n */\r\nconst encode = (data, alphabet, bitsPerChar) => {\r\n  const pad = alphabet[alphabet.length - 1] === '='\r\n  const mask = (1 << bitsPerChar) - 1\r\n  let out = ''\r\n\r\n  let bits = 0 // Number of bits currently in the buffer\r\n  let buffer = 0 // Bits waiting to be written out, MSB first\r\n  for (let i = 0; i < data.length; ++i) {\r\n    // Slurp data into the buffer:\r\n    buffer = (buffer << 8) | data[i]\r\n    bits += 8\r\n\r\n    // Write out as much as we can:\r\n    while (bits > bitsPerChar) {\r\n      bits -= bitsPerChar\r\n      out += alphabet[mask & (buffer >> bits)]\r\n    }\r\n  }\r\n\r\n  // Partial character:\r\n  if (bits) {\r\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\r\n  }\r\n\r\n  // Add padding characters until we hit a byte boundary:\r\n  if (pad) {\r\n    while ((out.length * bitsPerChar) & 7) {\r\n      out += '='\r\n    }\r\n  }\r\n\r\n  return out\r\n}\r\n\r\n/**\r\n * RFC4648 Factory\r\n *\r\n * @param {number} bitsPerChar\r\n * @returns {CodecFactory}\r\n */\r\nconst rfc4648 = (bitsPerChar) => (alphabet) => {\r\n  return {\r\n    /**\r\n     * @param {Uint8Array} input\r\n     * @returns {string}\r\n     */\r\n    encode (input) {\r\n      return encode(input, alphabet, bitsPerChar)\r\n    },\r\n    /**\r\n     * @param {string} input\r\n     * @returns {Uint8Array}\r\n     */\r\n    decode (input) {\r\n      return decode(input, alphabet, bitsPerChar)\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = { rfc4648 }\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}