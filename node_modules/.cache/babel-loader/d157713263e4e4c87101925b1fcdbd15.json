{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nvar codec = require('./codec');\n\nvar protocols = require('./protocols-table');\n\nvar varint = require('varint');\n\nvar CID = require('cids');\n\nvar withIs = require('class-is');\n\nvar errCode = require('err-code');\n\nvar inspect = Symbol.for('nodejs.util.inspect.custom');\n\nvar uint8ArrayToString = require('uint8arrays/to-string');\n\nvar uint8ArrayEquals = require('uint8arrays/equals');\n\nvar resolvers = new Map();\n/**\r\n * Creates a [multiaddr](https://github.com/multiformats/multiaddr) from\r\n * a Uint8Array, String or another Multiaddr instance\r\n * public key.\r\n *\r\n * @class Multiaddr\r\n * @param {(string | Uint8Array | Multiaddr)} addr - If String or Uint8Array, needs to adhere\r\n * to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n */\n\nvar Multiaddr = withIs.proto(function (addr) {\n  if (!(this instanceof Multiaddr)) {\n    return new Multiaddr(addr);\n  } // default\n\n\n  if (addr == null) {\n    addr = '';\n  }\n\n  if (addr instanceof Uint8Array) {\n    /**\r\n     * @type {Uint8Array} - The raw bytes representing this multiaddress\r\n     */\n    this.bytes = codec.fromBytes(addr);\n  } else if (typeof addr === 'string' || addr instanceof String) {\n    if (addr.length > 0 && addr.charAt(0) !== '/') {\n      throw new Error(\"multiaddr \\\"\".concat(addr, \"\\\" must start with a \\\"/\\\"\"));\n    }\n\n    this.bytes = codec.fromString(addr);\n  } else if (addr.bytes && addr.protos && addr.protoCodes) {\n    // Multiaddr\n    this.bytes = codec.fromBytes(addr.bytes); // validate + copy buffer\n  } else {\n    throw new Error('addr must be a string, Buffer, or another Multiaddr');\n  }\n}, {\n  className: 'Multiaddr',\n  symbolName: '@multiformats/js-multiaddr/multiaddr'\n});\n/**\r\n * Returns Multiaddr as a String\r\n *\r\n * @returns {string}\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').toString()\r\n * // '/ip4/127.0.0.1/tcp/4001'\r\n */\n\nMultiaddr.prototype.toString = function toString() {\n  return codec.bytesToString(this.bytes);\n};\n/**\r\n * Returns Multiaddr as a JSON encoded object\r\n *\r\n * @returns {string}\r\n * @example\r\n * JSON.stringify(Multiaddr('/ip4/127.0.0.1/tcp/4001'))\r\n * // '/ip4/127.0.0.1/tcp/4001'\r\n */\n\n\nMultiaddr.prototype.toJSON = Multiaddr.prototype.toString;\n/**\r\n * Returns Multiaddr as a convinient options object to be used with net.createConnection\r\n *\r\n * @returns {{family: string, host: string, transport: string, port: number}}\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').toOptions()\r\n * // { family: 'ipv4', host: '127.0.0.1', transport: 'tcp', port: 4001 }\r\n */\n\nMultiaddr.prototype.toOptions = function toOptions() {\n  var opts = {};\n  var parsed = this.toString().split('/');\n  opts.family = parsed[1] === 'ip4' ? 'ipv4' : 'ipv6';\n  opts.host = parsed[2];\n  opts.transport = parsed[3];\n  opts.port = parseInt(parsed[4]);\n  return opts;\n};\n/**\r\n * Returns Multiaddr as a human-readable string.\r\n * For post Node.js v10.0.0.\r\n * https://nodejs.org/api/deprecations.html#deprecations_dep0079_custom_inspection_function_on_objects_via_inspect\r\n *\r\n * @returns {string}\r\n * @example\r\n * console.log(Multiaddr('/ip4/127.0.0.1/tcp/4001'))\r\n * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'\r\n */\n\n\nMultiaddr.prototype[inspect] = function inspectCustom() {\n  return '<Multiaddr ' + uint8ArrayToString(this.bytes, 'base16') + ' - ' + codec.bytesToString(this.bytes) + '>';\n};\n/**\r\n * Returns Multiaddr as a human-readable string.\r\n * Fallback for pre Node.js v10.0.0.\r\n * https://nodejs.org/api/deprecations.html#deprecations_dep0079_custom_inspection_function_on_objects_via_inspect\r\n *\r\n * @returns {string}\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').inspect()\r\n * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'\r\n */\n\n\nMultiaddr.prototype.inspect = function inspect() {\n  return '<Multiaddr ' + uint8ArrayToString(this.bytes, 'base16') + ' - ' + codec.bytesToString(this.bytes) + '>';\n};\n/**\r\n * @typedef {object} protocol\r\n * @property {number} code\r\n * @property {number} size\r\n * @property {string} name\r\n * @property {boolean} [resolvable]\r\n * @property {boolean} [path]\r\n */\n\n/**\r\n * Returns the protocols the Multiaddr is defined with, as an array of objects, in\r\n * left-to-right order. Each object contains the protocol code, protocol name,\r\n * and the size of its address space in bits.\r\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\r\n *\r\n * @returns {protocol[]} protocols - All the protocols the address is composed of\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protos()\r\n * // [ { code: 4, size: 32, name: 'ip4' },\r\n * //   { code: 6, size: 16, name: 'tcp' } ]\r\n */\n\n\nMultiaddr.prototype.protos = function protos() {\n  return this.protoCodes().map(function (code) {\n    return Object.assign({}, protocols(code));\n  });\n};\n/**\r\n * Returns the codes of the protocols in left-to-right order.\r\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\r\n *\r\n * @returns {Array<number>} protocol codes\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoCodes()\r\n * // [ 4, 6 ]\r\n */\n\n\nMultiaddr.prototype.protoCodes = function protoCodes() {\n  var codes = [];\n  var buf = this.bytes;\n  var i = 0;\n\n  while (i < buf.length) {\n    var code = varint.decode(buf, i);\n    var n = varint.decode.bytes;\n    var p = protocols(code);\n    var size = codec.sizeForAddr(p, buf.slice(i + n));\n    i += size + n;\n    codes.push(code);\n  }\n\n  return codes;\n};\n/**\r\n * Returns the names of the protocols in left-to-right order.\r\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\r\n *\r\n * @returns {Array.<string>} protocol names\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoNames()\r\n * // [ 'ip4', 'tcp' ]\r\n */\n\n\nMultiaddr.prototype.protoNames = function protoNames() {\n  return this.protos().map(function (proto) {\n    return proto.name;\n  });\n};\n/**\r\n * Returns a tuple of parts\r\n *\r\n * @returns {[number, Uint8Array][]} tuples\r\n * @example\r\n * Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").tuples()\r\n * // [ [ 4, <Buffer 7f 00 00 01> ], [ 6, <Buffer 0f a1> ] ]\r\n */\n\n\nMultiaddr.prototype.tuples = function tuples() {\n  return codec.bytesToTuples(this.bytes);\n};\n/**\r\n * Returns a tuple of string/number parts\r\n * - tuples[][0] = code of protocol\r\n * - tuples[][1] = contents of address\r\n *\r\n * @returns {[number, string|number][]} tuples\r\n * @example\r\n * Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").stringTuples()\r\n * // [ [ 4, '127.0.0.1' ], [ 6, 4001 ] ]\r\n */\n\n\nMultiaddr.prototype.stringTuples = function stringTuples() {\n  var t = codec.bytesToTuples(this.bytes);\n  return codec.tuplesToStringTuples(t);\n};\n/**\r\n * Encapsulates a Multiaddr in another Multiaddr\r\n *\r\n * @param {Multiaddr} addr - Multiaddr to add into this Multiaddr\r\n * @returns {Multiaddr}\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\r\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\r\n *\r\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n *\r\n * const mh3 = mh1.encapsulate(mh2)\r\n * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\r\n *\r\n * mh3.toString()\r\n * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'\r\n */\n\n\nMultiaddr.prototype.encapsulate = function encapsulate(addr) {\n  addr = Multiaddr(addr);\n  return Multiaddr(this.toString() + addr.toString());\n};\n/**\r\n * Decapsulates a Multiaddr from another Multiaddr\r\n *\r\n * @param {Multiaddr} addr - Multiaddr to remove from this Multiaddr\r\n * @returns {Multiaddr}\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\r\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\r\n *\r\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n *\r\n * const mh3 = mh1.encapsulate(mh2)\r\n * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\r\n *\r\n * mh3.decapsulate(mh2).toString()\r\n * // '/ip4/8.8.8.8/tcp/1080'\r\n */\n\n\nMultiaddr.prototype.decapsulate = function decapsulate(addr) {\n  addr = addr.toString();\n  var s = this.toString();\n  var i = s.lastIndexOf(addr);\n\n  if (i < 0) {\n    throw new Error('Address ' + this + ' does not contain subaddress: ' + addr);\n  }\n\n  return Multiaddr(s.slice(0, i));\n};\n/**\r\n * A more reliable version of `decapsulate` if you are targeting a\r\n * specific code, such as 421 (the `p2p` protocol code). The last index of the code\r\n * will be removed from the `Multiaddr`, and a new instance will be returned.\r\n * If the code is not present, the original `Multiaddr` is returned.\r\n *\r\n * @param {number} code - The code of the protocol to decapsulate from this Multiaddr\r\n * @returns {Multiaddr}\r\n * @example\r\n * const addr = Multiaddr('/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC')\r\n * // <Multiaddr 0400... - /ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC>\r\n *\r\n * addr.decapsulateCode(421).toString()\r\n * // '/ip4/0.0.0.0/tcp/8080'\r\n *\r\n * Multiaddr('/ip4/127.0.0.1/tcp/8080').decapsulateCode(421).toString()\r\n * // '/ip4/127.0.0.1/tcp/8080'\r\n */\n\n\nMultiaddr.prototype.decapsulateCode = function decapsulateCode(code) {\n  var tuples = this.tuples();\n\n  for (var i = tuples.length - 1; i >= 0; i--) {\n    if (tuples[i][0] === code) {\n      return Multiaddr(codec.tuplesToBytes(tuples.slice(0, i)));\n    }\n  }\n\n  return this;\n};\n/**\r\n * Extract the peerId if the multiaddr contains one\r\n *\r\n * @returns {string | null} peerId - The id of the peer or null if invalid or missing from the ma\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string')\r\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string>\r\n *\r\n * // should return QmValidBase58string or null if the id is missing or invalid\r\n * const peerId = mh1.getPeerId()\r\n */\n\n\nMultiaddr.prototype.getPeerId = function getPeerId() {\n  var b58str = null;\n\n  try {\n    var tuples = this.stringTuples().filter(function (tuple) {\n      if (tuple[0] === protocols.names.ipfs.code) {\n        return true;\n      }\n    }); // Get the last id\n\n    b58str = tuples.pop()[1]; // Get multihash, unwrap from CID if needed\n\n    b58str = uint8ArrayToString(new CID(b58str).multihash, 'base58btc');\n  } catch (e) {\n    b58str = null;\n  }\n\n  return b58str;\n};\n/**\r\n * Extract the path if the multiaddr contains one\r\n *\r\n * @returns {string | null} path - The path of the multiaddr, or null if no path protocol is present\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock')\r\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock>\r\n *\r\n * // should return utf8 string or null if the id is missing or invalid\r\n * const path = mh1.getPath()\r\n */\n\n\nMultiaddr.prototype.getPath = function getPath() {\n  var path = null;\n\n  try {\n    path = this.stringTuples().filter(function (tuple) {\n      var proto = protocols(tuple[0]);\n\n      if (proto.path) {\n        return true;\n      }\n    })[0][1];\n  } catch (e) {\n    path = null;\n  }\n\n  return path;\n};\n/**\r\n * Checks if two Multiaddrs are the same\r\n *\r\n * @param {Multiaddr} addr\r\n * @returns {Bool}\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\r\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\r\n *\r\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n *\r\n * mh1.equals(mh1)\r\n * // true\r\n *\r\n * mh1.equals(mh2)\r\n * // false\r\n */\n\n\nMultiaddr.prototype.equals = function equals(addr) {\n  return uint8ArrayEquals(this.bytes, addr.bytes);\n};\n/**\r\n * Resolve multiaddr if containing resolvable hostname.\r\n *\r\n * @returns {Promise<Array<Multiaddr>>}\r\n * @example\r\n * Multiaddr.resolvers.set('dnsaddr', resolverFunction)\r\n * const mh1 = Multiaddr('/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb')\r\n * const resolvedMultiaddrs = await mh1.resolve()\r\n * // [\r\n * //   <Multiaddr 04934b5353060fa1a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/tcp/4001/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>,\r\n * //   <Multiaddr 04934b53530601bbde03a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/tcp/443/wss/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>,\r\n * //   <Multiaddr 04934b535391020fa1cc03a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/udp/4001/quic/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>\r\n * // ]\r\n */\n\n\nMultiaddr.prototype.resolve = /*#__PURE__*/function () {\n  var _resolve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var resolvableProto, resolver, addresses;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            resolvableProto = this.protos().find(function (p) {\n              return p.resolvable;\n            }); // Multiaddr is not resolvable?\n\n            if (resolvableProto) {\n              _context.next = 3;\n              break;\n            }\n\n            return _context.abrupt(\"return\", [this]);\n\n          case 3:\n            resolver = resolvers.get(resolvableProto.name);\n\n            if (resolver) {\n              _context.next = 6;\n              break;\n            }\n\n            throw errCode(new Error(\"no available resolver for \".concat(resolvableProto.name)), 'ERR_NO_AVAILABLE_RESOLVER');\n\n          case 6:\n            _context.next = 8;\n            return resolver(this);\n\n          case 8:\n            addresses = _context.sent;\n            return _context.abrupt(\"return\", addresses.map(function (a) {\n              return Multiaddr(a);\n            }));\n\n          case 10:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n\n  function resolve() {\n    return _resolve.apply(this, arguments);\n  }\n\n  return resolve;\n}();\n/**\r\n * Gets a Multiaddrs node-friendly address object. Note that protocol information\r\n * is left out: in Node (and most network systems) the protocol is unknowable\r\n * given only the address.\r\n *\r\n * Has to be a ThinWaist Address, otherwise throws error\r\n *\r\n * @returns {{family: string, address: string, port: number}}\r\n * @throws {Error} Throws error if Multiaddr is not a Thin Waist address\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').nodeAddress()\r\n * // {family: 'IPv4', address: '127.0.0.1', port: '4001'}\r\n */\n\n\nMultiaddr.prototype.nodeAddress = function nodeAddress() {\n  var codes = this.protoCodes();\n  var names = this.protoNames();\n  var parts = this.toString().split('/').slice(1);\n\n  if (parts.length < 4) {\n    throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}\".');\n  } else if (codes[0] !== 4 && codes[0] !== 41 && codes[0] !== 54 && codes[0] !== 55) {\n    throw new Error(\"no protocol with name: \\\"'\".concat(names[0], \"'\\\". Must have a valid family name: \\\"{ip4, ip6, dns4, dns6}\\\".\"));\n  } else if (parts[2] !== 'tcp' && parts[2] !== 'udp') {\n    throw new Error(\"no protocol with name: \\\"'\".concat(names[1], \"'\\\". Must have a valid transport protocol: \\\"{tcp, udp}\\\".\"));\n  }\n\n  return {\n    family: codes[0] === 41 || codes[0] === 55 ? 6 : 4,\n    address: parts[1],\n    // ip addr\n    port: parseInt(parts[3]) // tcp or udp port\n\n  };\n};\n/**\r\n * Creates a Multiaddr from a node-friendly address object\r\n *\r\n * @param {{family: string, address: string, port: number}} addr\r\n * @param {string} transport\r\n * @returns {Multiaddr} multiaddr\r\n * @throws {Error} Throws error if addr is not truthy\r\n * @throws {Error} Throws error if transport is not truthy\r\n * @example\r\n * Multiaddr.fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n */\n\n\nMultiaddr.fromNodeAddress = function fromNodeAddress(addr, transport) {\n  if (!addr) throw new Error('requires node address object');\n  if (!transport) throw new Error('requires transport protocol');\n  var ip;\n\n  switch (addr.family) {\n    case 'IPv4':\n      ip = 'ip4';\n      break;\n\n    case 'IPv6':\n      ip = 'ip6';\n      break;\n\n    default:\n      throw Error(\"Invalid addr family. Got '\".concat(addr.family, \"' instead of 'IPv4' or 'IPv6'\"));\n  }\n\n  return Multiaddr('/' + [ip, addr.address, transport, addr.port].join('/'));\n}; // TODO find a better example, not sure about it's good enough\n\n/**\r\n * Returns if a Multiaddr is a Thin Waist address or not.\r\n *\r\n * Thin Waist is if a Multiaddr adheres to the standard combination of:\r\n *\r\n * `{IPv4, IPv6}/{TCP, UDP}`\r\n *\r\n * @param {Multiaddr} [addr] - Defaults to using `this` instance\r\n * @returns {boolean} isThinWaistAddress\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n * const mh2 = Multiaddr('/ip4/192.168.2.1/tcp/5001')\r\n * // <Multiaddr 04c0a80201061389 - /ip4/192.168.2.1/tcp/5001>\r\n * const mh3 = mh1.encapsulate(mh2)\r\n * // <Multiaddr 047f000001060fa104c0a80201061389 - /ip4/127.0.0.1/tcp/4001/ip4/192.168.2.1/tcp/5001>\r\n * mh1.isThinWaistAddress()\r\n * // true\r\n * mh2.isThinWaistAddress()\r\n * // true\r\n * mh3.isThinWaistAddress()\r\n * // false\r\n */\n\n\nMultiaddr.prototype.isThinWaistAddress = function isThinWaistAddress(addr) {\n  var protos = (addr || this).protos();\n\n  if (protos.length !== 2) {\n    return false;\n  }\n\n  if (protos[0].code !== 4 && protos[0].code !== 41) {\n    return false;\n  }\n\n  if (protos[1].code !== 6 && protos[1].code !== 273) {\n    return false;\n  }\n\n  return true;\n};\n/**\r\n * Object containing table, names and codes of all supported protocols.\r\n * To get the protocol values from a Multiaddr, you can use\r\n * [`.protos()`](#multiaddrprotos),\r\n * [`.protoCodes()`](#multiaddrprotocodes) or\r\n * [`.protoNames()`](#multiaddrprotonames)\r\n *\r\n * @instance\r\n * @returns {{table: Array, names: Object, codes: Object}}\r\n *\r\n */\n\n\nMultiaddr.protocols = protocols;\n/**\r\n * Returns if something is a Multiaddr that is a name\r\n *\r\n * @param {Multiaddr} addr\r\n * @returns {Bool} isName\r\n */\n\nMultiaddr.isName = function isName(addr) {\n  if (!Multiaddr.isMultiaddr(addr)) {\n    return false;\n  } // if a part of the multiaddr is resolvable, then return true\n\n\n  return addr.protos().some(function (proto) {\n    return proto.resolvable;\n  });\n};\n/**\r\n * Returns an array of multiaddrs, by resolving the multiaddr that is a name\r\n *\r\n * @async\r\n * @param {Multiaddr} addr\r\n * @returns {Multiaddr[]}\r\n */\n\n\nMultiaddr.resolve = function resolve(addr) {\n  if (!Multiaddr.isMultiaddr(addr) || !Multiaddr.isName(addr)) {\n    return Promise.reject(Error('not a valid name'));\n  }\n  /*\r\n   * Needs more consideration from spec design:\r\n   *   - what to return\r\n   *   - how to achieve it in the browser?\r\n   */\n\n\n  return Promise.reject(new Error('not implemented yet'));\n};\n\nMultiaddr.resolvers = resolvers;\nexports = module.exports = Multiaddr;","map":{"version":3,"names":["codec","require","protocols","varint","CID","withIs","errCode","inspect","Symbol","for","uint8ArrayToString","uint8ArrayEquals","resolvers","Map","Multiaddr","proto","addr","Uint8Array","bytes","fromBytes","String","length","charAt","Error","fromString","protos","protoCodes","className","symbolName","prototype","toString","bytesToString","toJSON","toOptions","opts","parsed","split","family","host","transport","port","parseInt","inspectCustom","map","code","Object","assign","codes","buf","i","decode","n","p","size","sizeForAddr","slice","push","protoNames","name","tuples","bytesToTuples","stringTuples","t","tuplesToStringTuples","encapsulate","decapsulate","s","lastIndexOf","decapsulateCode","tuplesToBytes","getPeerId","b58str","filter","tuple","names","ipfs","pop","multihash","e","getPath","path","equals","resolve","resolvableProto","find","resolvable","resolver","get","addresses","a","nodeAddress","parts","address","fromNodeAddress","ip","join","isThinWaistAddress","isName","isMultiaddr","some","Promise","reject","exports","module"],"sources":["C:/Users/User/Documents/clone-starter-kit-08/node_modules/multiaddr/src/index.js"],"sourcesContent":["'use strict'\r\n\r\nconst codec = require('./codec')\r\nconst protocols = require('./protocols-table')\r\nconst varint = require('varint')\r\nconst CID = require('cids')\r\nconst withIs = require('class-is')\r\nconst errCode = require('err-code')\r\nconst inspect = Symbol.for('nodejs.util.inspect.custom')\r\nconst uint8ArrayToString = require('uint8arrays/to-string')\r\nconst uint8ArrayEquals = require('uint8arrays/equals')\r\n\r\nconst resolvers = new Map()\r\n\r\n/**\r\n * Creates a [multiaddr](https://github.com/multiformats/multiaddr) from\r\n * a Uint8Array, String or another Multiaddr instance\r\n * public key.\r\n *\r\n * @class Multiaddr\r\n * @param {(string | Uint8Array | Multiaddr)} addr - If String or Uint8Array, needs to adhere\r\n * to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n */\r\nconst Multiaddr = withIs.proto(function (addr) {\r\n  if (!(this instanceof Multiaddr)) {\r\n    return new Multiaddr(addr)\r\n  }\r\n\r\n  // default\r\n  if (addr == null) {\r\n    addr = ''\r\n  }\r\n\r\n  if (addr instanceof Uint8Array) {\r\n    /**\r\n     * @type {Uint8Array} - The raw bytes representing this multiaddress\r\n     */\r\n    this.bytes = codec.fromBytes(addr)\r\n  } else if (typeof addr === 'string' || addr instanceof String) {\r\n    if (addr.length > 0 && addr.charAt(0) !== '/') {\r\n      throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`)\r\n    }\r\n    this.bytes = codec.fromString(addr)\r\n  } else if (addr.bytes && addr.protos && addr.protoCodes) { // Multiaddr\r\n    this.bytes = codec.fromBytes(addr.bytes) // validate + copy buffer\r\n  } else {\r\n    throw new Error('addr must be a string, Buffer, or another Multiaddr')\r\n  }\r\n}, { className: 'Multiaddr', symbolName: '@multiformats/js-multiaddr/multiaddr' })\r\n\r\n/**\r\n * Returns Multiaddr as a String\r\n *\r\n * @returns {string}\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').toString()\r\n * // '/ip4/127.0.0.1/tcp/4001'\r\n */\r\nMultiaddr.prototype.toString = function toString () {\r\n  return codec.bytesToString(this.bytes)\r\n}\r\n\r\n/**\r\n * Returns Multiaddr as a JSON encoded object\r\n *\r\n * @returns {string}\r\n * @example\r\n * JSON.stringify(Multiaddr('/ip4/127.0.0.1/tcp/4001'))\r\n * // '/ip4/127.0.0.1/tcp/4001'\r\n */\r\nMultiaddr.prototype.toJSON = Multiaddr.prototype.toString\r\n\r\n/**\r\n * Returns Multiaddr as a convinient options object to be used with net.createConnection\r\n *\r\n * @returns {{family: string, host: string, transport: string, port: number}}\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').toOptions()\r\n * // { family: 'ipv4', host: '127.0.0.1', transport: 'tcp', port: 4001 }\r\n */\r\nMultiaddr.prototype.toOptions = function toOptions () {\r\n  const opts = {}\r\n  const parsed = this.toString().split('/')\r\n  opts.family = parsed[1] === 'ip4' ? 'ipv4' : 'ipv6'\r\n  opts.host = parsed[2]\r\n  opts.transport = parsed[3]\r\n  opts.port = parseInt(parsed[4])\r\n  return opts\r\n}\r\n\r\n/**\r\n * Returns Multiaddr as a human-readable string.\r\n * For post Node.js v10.0.0.\r\n * https://nodejs.org/api/deprecations.html#deprecations_dep0079_custom_inspection_function_on_objects_via_inspect\r\n *\r\n * @returns {string}\r\n * @example\r\n * console.log(Multiaddr('/ip4/127.0.0.1/tcp/4001'))\r\n * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'\r\n */\r\nMultiaddr.prototype[inspect] = function inspectCustom () {\r\n  return '<Multiaddr ' +\r\n    uint8ArrayToString(this.bytes, 'base16') + ' - ' +\r\n    codec.bytesToString(this.bytes) + '>'\r\n}\r\n\r\n/**\r\n * Returns Multiaddr as a human-readable string.\r\n * Fallback for pre Node.js v10.0.0.\r\n * https://nodejs.org/api/deprecations.html#deprecations_dep0079_custom_inspection_function_on_objects_via_inspect\r\n *\r\n * @returns {string}\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').inspect()\r\n * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'\r\n */\r\nMultiaddr.prototype.inspect = function inspect () {\r\n  return '<Multiaddr ' +\r\n    uint8ArrayToString(this.bytes, 'base16') + ' - ' +\r\n    codec.bytesToString(this.bytes) + '>'\r\n}\r\n\r\n/**\r\n * @typedef {object} protocol\r\n * @property {number} code\r\n * @property {number} size\r\n * @property {string} name\r\n * @property {boolean} [resolvable]\r\n * @property {boolean} [path]\r\n */\r\n\r\n/**\r\n * Returns the protocols the Multiaddr is defined with, as an array of objects, in\r\n * left-to-right order. Each object contains the protocol code, protocol name,\r\n * and the size of its address space in bits.\r\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\r\n *\r\n * @returns {protocol[]} protocols - All the protocols the address is composed of\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protos()\r\n * // [ { code: 4, size: 32, name: 'ip4' },\r\n * //   { code: 6, size: 16, name: 'tcp' } ]\r\n */\r\nMultiaddr.prototype.protos = function protos () {\r\n  return this.protoCodes().map(code => Object.assign({}, protocols(code)))\r\n}\r\n\r\n/**\r\n * Returns the codes of the protocols in left-to-right order.\r\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\r\n *\r\n * @returns {Array<number>} protocol codes\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoCodes()\r\n * // [ 4, 6 ]\r\n */\r\nMultiaddr.prototype.protoCodes = function protoCodes () {\r\n  const codes = []\r\n  const buf = this.bytes\r\n  let i = 0\r\n  while (i < buf.length) {\r\n    const code = varint.decode(buf, i)\r\n    const n = varint.decode.bytes\r\n\r\n    const p = protocols(code)\r\n    const size = codec.sizeForAddr(p, buf.slice(i + n))\r\n\r\n    i += (size + n)\r\n    codes.push(code)\r\n  }\r\n\r\n  return codes\r\n}\r\n\r\n/**\r\n * Returns the names of the protocols in left-to-right order.\r\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\r\n *\r\n * @returns {Array.<string>} protocol names\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoNames()\r\n * // [ 'ip4', 'tcp' ]\r\n */\r\nMultiaddr.prototype.protoNames = function protoNames () {\r\n  return this.protos().map(proto => proto.name)\r\n}\r\n\r\n/**\r\n * Returns a tuple of parts\r\n *\r\n * @returns {[number, Uint8Array][]} tuples\r\n * @example\r\n * Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").tuples()\r\n * // [ [ 4, <Buffer 7f 00 00 01> ], [ 6, <Buffer 0f a1> ] ]\r\n */\r\nMultiaddr.prototype.tuples = function tuples () {\r\n  return codec.bytesToTuples(this.bytes)\r\n}\r\n\r\n/**\r\n * Returns a tuple of string/number parts\r\n * - tuples[][0] = code of protocol\r\n * - tuples[][1] = contents of address\r\n *\r\n * @returns {[number, string|number][]} tuples\r\n * @example\r\n * Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").stringTuples()\r\n * // [ [ 4, '127.0.0.1' ], [ 6, 4001 ] ]\r\n */\r\nMultiaddr.prototype.stringTuples = function stringTuples () {\r\n  const t = codec.bytesToTuples(this.bytes)\r\n  return codec.tuplesToStringTuples(t)\r\n}\r\n\r\n/**\r\n * Encapsulates a Multiaddr in another Multiaddr\r\n *\r\n * @param {Multiaddr} addr - Multiaddr to add into this Multiaddr\r\n * @returns {Multiaddr}\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\r\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\r\n *\r\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n *\r\n * const mh3 = mh1.encapsulate(mh2)\r\n * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\r\n *\r\n * mh3.toString()\r\n * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'\r\n */\r\nMultiaddr.prototype.encapsulate = function encapsulate (addr) {\r\n  addr = Multiaddr(addr)\r\n  return Multiaddr(this.toString() + addr.toString())\r\n}\r\n\r\n/**\r\n * Decapsulates a Multiaddr from another Multiaddr\r\n *\r\n * @param {Multiaddr} addr - Multiaddr to remove from this Multiaddr\r\n * @returns {Multiaddr}\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\r\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\r\n *\r\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n *\r\n * const mh3 = mh1.encapsulate(mh2)\r\n * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\r\n *\r\n * mh3.decapsulate(mh2).toString()\r\n * // '/ip4/8.8.8.8/tcp/1080'\r\n */\r\nMultiaddr.prototype.decapsulate = function decapsulate (addr) {\r\n  addr = addr.toString()\r\n  const s = this.toString()\r\n  const i = s.lastIndexOf(addr)\r\n  if (i < 0) {\r\n    throw new Error('Address ' + this + ' does not contain subaddress: ' + addr)\r\n  }\r\n  return Multiaddr(s.slice(0, i))\r\n}\r\n\r\n/**\r\n * A more reliable version of `decapsulate` if you are targeting a\r\n * specific code, such as 421 (the `p2p` protocol code). The last index of the code\r\n * will be removed from the `Multiaddr`, and a new instance will be returned.\r\n * If the code is not present, the original `Multiaddr` is returned.\r\n *\r\n * @param {number} code - The code of the protocol to decapsulate from this Multiaddr\r\n * @returns {Multiaddr}\r\n * @example\r\n * const addr = Multiaddr('/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC')\r\n * // <Multiaddr 0400... - /ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC>\r\n *\r\n * addr.decapsulateCode(421).toString()\r\n * // '/ip4/0.0.0.0/tcp/8080'\r\n *\r\n * Multiaddr('/ip4/127.0.0.1/tcp/8080').decapsulateCode(421).toString()\r\n * // '/ip4/127.0.0.1/tcp/8080'\r\n */\r\nMultiaddr.prototype.decapsulateCode = function decapsulateCode (code) {\r\n  const tuples = this.tuples()\r\n  for (let i = tuples.length - 1; i >= 0; i--) {\r\n    if (tuples[i][0] === code) {\r\n      return Multiaddr(codec.tuplesToBytes(tuples.slice(0, i)))\r\n    }\r\n  }\r\n  return this\r\n}\r\n\r\n/**\r\n * Extract the peerId if the multiaddr contains one\r\n *\r\n * @returns {string | null} peerId - The id of the peer or null if invalid or missing from the ma\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string')\r\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string>\r\n *\r\n * // should return QmValidBase58string or null if the id is missing or invalid\r\n * const peerId = mh1.getPeerId()\r\n */\r\nMultiaddr.prototype.getPeerId = function getPeerId () {\r\n  let b58str = null\r\n  try {\r\n    const tuples = this.stringTuples().filter((tuple) => {\r\n      if (tuple[0] === protocols.names.ipfs.code) {\r\n        return true\r\n      }\r\n    })\r\n\r\n    // Get the last id\r\n    b58str = tuples.pop()[1]\r\n    // Get multihash, unwrap from CID if needed\r\n    b58str = uint8ArrayToString(new CID(b58str).multihash, 'base58btc')\r\n  } catch (e) {\r\n    b58str = null\r\n  }\r\n\r\n  return b58str\r\n}\r\n\r\n/**\r\n * Extract the path if the multiaddr contains one\r\n *\r\n * @returns {string | null} path - The path of the multiaddr, or null if no path protocol is present\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock')\r\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock>\r\n *\r\n * // should return utf8 string or null if the id is missing or invalid\r\n * const path = mh1.getPath()\r\n */\r\nMultiaddr.prototype.getPath = function getPath () {\r\n  let path = null\r\n  try {\r\n    path = this.stringTuples().filter((tuple) => {\r\n      const proto = protocols(tuple[0])\r\n      if (proto.path) {\r\n        return true\r\n      }\r\n    })[0][1]\r\n  } catch (e) {\r\n    path = null\r\n  }\r\n\r\n  return path\r\n}\r\n\r\n/**\r\n * Checks if two Multiaddrs are the same\r\n *\r\n * @param {Multiaddr} addr\r\n * @returns {Bool}\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\r\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\r\n *\r\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n *\r\n * mh1.equals(mh1)\r\n * // true\r\n *\r\n * mh1.equals(mh2)\r\n * // false\r\n */\r\nMultiaddr.prototype.equals = function equals (addr) {\r\n  return uint8ArrayEquals(this.bytes, addr.bytes)\r\n}\r\n\r\n/**\r\n * Resolve multiaddr if containing resolvable hostname.\r\n *\r\n * @returns {Promise<Array<Multiaddr>>}\r\n * @example\r\n * Multiaddr.resolvers.set('dnsaddr', resolverFunction)\r\n * const mh1 = Multiaddr('/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb')\r\n * const resolvedMultiaddrs = await mh1.resolve()\r\n * // [\r\n * //   <Multiaddr 04934b5353060fa1a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/tcp/4001/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>,\r\n * //   <Multiaddr 04934b53530601bbde03a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/tcp/443/wss/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>,\r\n * //   <Multiaddr 04934b535391020fa1cc03a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/udp/4001/quic/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>\r\n * // ]\r\n */\r\nMultiaddr.prototype.resolve = async function resolve () {\r\n  const resolvableProto = this.protos().find((p) => p.resolvable)\r\n\r\n  // Multiaddr is not resolvable?\r\n  if (!resolvableProto) {\r\n    return [this]\r\n  }\r\n\r\n  const resolver = resolvers.get(resolvableProto.name)\r\n  if (!resolver) {\r\n    throw errCode(new Error(`no available resolver for ${resolvableProto.name}`), 'ERR_NO_AVAILABLE_RESOLVER')\r\n  }\r\n\r\n  const addresses = await resolver(this)\r\n  return addresses.map(a => Multiaddr(a))\r\n}\r\n\r\n/**\r\n * Gets a Multiaddrs node-friendly address object. Note that protocol information\r\n * is left out: in Node (and most network systems) the protocol is unknowable\r\n * given only the address.\r\n *\r\n * Has to be a ThinWaist Address, otherwise throws error\r\n *\r\n * @returns {{family: string, address: string, port: number}}\r\n * @throws {Error} Throws error if Multiaddr is not a Thin Waist address\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').nodeAddress()\r\n * // {family: 'IPv4', address: '127.0.0.1', port: '4001'}\r\n */\r\nMultiaddr.prototype.nodeAddress = function nodeAddress () {\r\n  const codes = this.protoCodes()\r\n  const names = this.protoNames()\r\n  const parts = this.toString().split('/').slice(1)\r\n\r\n  if (parts.length < 4) {\r\n    throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}\".')\r\n  } else if (codes[0] !== 4 && codes[0] !== 41 && codes[0] !== 54 && codes[0] !== 55) {\r\n    throw new Error(`no protocol with name: \"'${names[0]}'\". Must have a valid family name: \"{ip4, ip6, dns4, dns6}\".`)\r\n  } else if (parts[2] !== 'tcp' && parts[2] !== 'udp') {\r\n    throw new Error(`no protocol with name: \"'${names[1]}'\". Must have a valid transport protocol: \"{tcp, udp}\".`)\r\n  }\r\n\r\n  return {\r\n    family: (codes[0] === 41 || codes[0] === 55) ? 6 : 4,\r\n    address: parts[1], // ip addr\r\n    port: parseInt(parts[3]) // tcp or udp port\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a Multiaddr from a node-friendly address object\r\n *\r\n * @param {{family: string, address: string, port: number}} addr\r\n * @param {string} transport\r\n * @returns {Multiaddr} multiaddr\r\n * @throws {Error} Throws error if addr is not truthy\r\n * @throws {Error} Throws error if transport is not truthy\r\n * @example\r\n * Multiaddr.fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n */\r\nMultiaddr.fromNodeAddress = function fromNodeAddress (addr, transport) {\r\n  if (!addr) throw new Error('requires node address object')\r\n  if (!transport) throw new Error('requires transport protocol')\r\n  let ip\r\n  switch (addr.family) {\r\n    case 'IPv4':\r\n      ip = 'ip4'\r\n      break\r\n    case 'IPv6':\r\n      ip = 'ip6'\r\n      break\r\n    default:\r\n      throw Error(`Invalid addr family. Got '${addr.family}' instead of 'IPv4' or 'IPv6'`)\r\n  }\r\n  return Multiaddr('/' + [ip, addr.address, transport, addr.port].join('/'))\r\n}\r\n\r\n// TODO find a better example, not sure about it's good enough\r\n/**\r\n * Returns if a Multiaddr is a Thin Waist address or not.\r\n *\r\n * Thin Waist is if a Multiaddr adheres to the standard combination of:\r\n *\r\n * `{IPv4, IPv6}/{TCP, UDP}`\r\n *\r\n * @param {Multiaddr} [addr] - Defaults to using `this` instance\r\n * @returns {boolean} isThinWaistAddress\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n * const mh2 = Multiaddr('/ip4/192.168.2.1/tcp/5001')\r\n * // <Multiaddr 04c0a80201061389 - /ip4/192.168.2.1/tcp/5001>\r\n * const mh3 = mh1.encapsulate(mh2)\r\n * // <Multiaddr 047f000001060fa104c0a80201061389 - /ip4/127.0.0.1/tcp/4001/ip4/192.168.2.1/tcp/5001>\r\n * mh1.isThinWaistAddress()\r\n * // true\r\n * mh2.isThinWaistAddress()\r\n * // true\r\n * mh3.isThinWaistAddress()\r\n * // false\r\n */\r\nMultiaddr.prototype.isThinWaistAddress = function isThinWaistAddress (addr) {\r\n  const protos = (addr || this).protos()\r\n\r\n  if (protos.length !== 2) {\r\n    return false\r\n  }\r\n\r\n  if (protos[0].code !== 4 && protos[0].code !== 41) {\r\n    return false\r\n  }\r\n  if (protos[1].code !== 6 && protos[1].code !== 273) {\r\n    return false\r\n  }\r\n  return true\r\n}\r\n\r\n/**\r\n * Object containing table, names and codes of all supported protocols.\r\n * To get the protocol values from a Multiaddr, you can use\r\n * [`.protos()`](#multiaddrprotos),\r\n * [`.protoCodes()`](#multiaddrprotocodes) or\r\n * [`.protoNames()`](#multiaddrprotonames)\r\n *\r\n * @instance\r\n * @returns {{table: Array, names: Object, codes: Object}}\r\n *\r\n */\r\nMultiaddr.protocols = protocols\r\n\r\n/**\r\n * Returns if something is a Multiaddr that is a name\r\n *\r\n * @param {Multiaddr} addr\r\n * @returns {Bool} isName\r\n */\r\nMultiaddr.isName = function isName (addr) {\r\n  if (!Multiaddr.isMultiaddr(addr)) {\r\n    return false\r\n  }\r\n\r\n  // if a part of the multiaddr is resolvable, then return true\r\n  return addr.protos().some((proto) => proto.resolvable)\r\n}\r\n\r\n/**\r\n * Returns an array of multiaddrs, by resolving the multiaddr that is a name\r\n *\r\n * @async\r\n * @param {Multiaddr} addr\r\n * @returns {Multiaddr[]}\r\n */\r\nMultiaddr.resolve = function resolve (addr) {\r\n  if (!Multiaddr.isMultiaddr(addr) || !Multiaddr.isName(addr)) {\r\n    return Promise.reject(Error('not a valid name'))\r\n  }\r\n\r\n  /*\r\n   * Needs more consideration from spec design:\r\n   *   - what to return\r\n   *   - how to achieve it in the browser?\r\n   */\r\n  return Promise.reject(new Error('not implemented yet'))\r\n}\r\n\r\nMultiaddr.resolvers = resolvers\r\nexports = module.exports = Multiaddr\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}