{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst CID = require('cids');\n/**\r\n * Transform one of:\r\n *\r\n * ```ts\r\n * CID\r\n * String\r\n * { cid: CID recursive, metadata }\r\n * { path: String recursive, metadata }\r\n * Iterable<CID>\r\n * Iterable<String>\r\n * Iterable<{ cid: CID recursive, metadata }>\r\n * Iterable<{ path: String recursive, metadata }>\r\n * AsyncIterable<CID>\r\n * AsyncIterable<String>\r\n * AsyncIterable<{ cid: CID recursive, metadata }>\r\n * AsyncIterable<{ path: String recursive, metadata }>\r\n * ```\r\n * Into:\r\n *\r\n * ```ts\r\n * AsyncIterable<{ path: CID|String, recursive:boolean, metadata }>\r\n * ```\r\n *\r\n * @param {Source} input\r\n * @returns {AsyncIterable<Pin>}\r\n */\n// eslint-disable-next-line complexity\n\n\nmodule.exports = async function* normaliseInput(input) {\n  // must give us something\n  if (input === null || input === undefined) {\n    throw errCode(new Error(`Unexpected input: ${input}`), 'ERR_UNEXPECTED_INPUT');\n  } // CID|String\n\n\n  if (CID.isCID(input)) {\n    yield toPin({\n      cid: input\n    });\n    return;\n  }\n\n  if (input instanceof String || typeof input === 'string') {\n    yield toPin({\n      path: input\n    });\n    return;\n  } // { cid: CID recursive, metadata }\n  // @ts-ignore - it still could be iterable or async iterable\n\n\n  if (input.cid != null || input.path != null) {\n    // @ts-ignore\n    return yield toPin(input);\n  } // Iterable<?>\n\n\n  if (input[Symbol.iterator]) {\n    const iterator = input[Symbol.iterator]();\n    const first = iterator.next();\n    if (first.done) return iterator; // Iterable<CID|String>\n\n    if (CID.isCID(first.value) || first.value instanceof String || typeof first.value === 'string') {\n      yield toPin({\n        cid: first.value\n      });\n\n      for (const cid of iterator) {\n        yield toPin({\n          cid\n        });\n      }\n\n      return;\n    } // Iterable<{ cid: CID recursive, metadata }>\n\n\n    if (first.value.cid != null || first.value.path != null) {\n      yield toPin(first.value);\n\n      for (const obj of iterator) {\n        yield toPin(obj);\n      }\n\n      return;\n    }\n\n    throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');\n  } // AsyncIterable<?>\n\n\n  if (input[Symbol.asyncIterator]) {\n    const iterator = input[Symbol.asyncIterator]();\n    const first = await iterator.next();\n    if (first.done) return iterator; // AsyncIterable<CID|String>\n\n    if (CID.isCID(first.value) || first.value instanceof String || typeof first.value === 'string') {\n      yield toPin({\n        cid: first.value\n      });\n\n      for await (const cid of iterator) {\n        yield toPin({\n          cid\n        });\n      }\n\n      return;\n    } // AsyncIterable<{ cid: CID|String recursive, metadata }>\n\n\n    if (first.value.cid != null || first.value.path != null) {\n      yield toPin(first.value);\n\n      for await (const obj of iterator) {\n        yield toPin(obj);\n      }\n\n      return;\n    }\n\n    throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');\n  }\n\n  throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');\n};\n/**\r\n * @param {ToPinWithPath|ToPinWithCID} input\r\n * @returns {Pin}\r\n */\n\n\nfunction toPin(input) {\n  const pin = {\n    path: input.path == null ? input.cid : `${input.path}`,\n    recursive: input.recursive !== false\n  };\n\n  if (input.metadata != null) {\n    pin.metadata = input.metadata;\n  }\n\n  return pin;\n}\n/**\r\n * @typedef {Object} ToPinWithPath\r\n * @property {string | InstanceType<typeof window.String> | CID} path\r\n * @property {undefined} [cid]\r\n * @property {boolean} [recursive]\r\n * @property {any} [metadata]\r\n *\r\n * @typedef {Object} ToPinWithCID\r\n * @property {undefined} [path]\r\n * @property {CID} cid\r\n * @property {boolean} [recursive]\r\n * @property {any} [metadata]\r\n *\r\n * @typedef {CID|string|InstanceType<typeof window.String>|ToPinWithPath|ToPinWithPath} ToPin\r\n * @typedef {ToPin|Iterable<ToPin>|AsyncIterable<ToPin>} Source\r\n *\r\n * @typedef {Object} Pin\r\n * @property {string|CID} path\r\n * @property {boolean} recursive\r\n * @property {any} [metadata]\r\n */","map":{"version":3,"names":["errCode","require","CID","module","exports","normaliseInput","input","undefined","Error","isCID","toPin","cid","String","path","Symbol","iterator","first","next","done","value","obj","asyncIterator","pin","recursive","metadata"],"sources":["C:/Users/User/Documents/clone-starter-kit-08/node_modules/ipfs-core-utils/src/pins/normalise-input.js"],"sourcesContent":["'use strict'\r\n\r\nconst errCode = require('err-code')\r\nconst CID = require('cids')\r\n\r\n/**\r\n * Transform one of:\r\n *\r\n * ```ts\r\n * CID\r\n * String\r\n * { cid: CID recursive, metadata }\r\n * { path: String recursive, metadata }\r\n * Iterable<CID>\r\n * Iterable<String>\r\n * Iterable<{ cid: CID recursive, metadata }>\r\n * Iterable<{ path: String recursive, metadata }>\r\n * AsyncIterable<CID>\r\n * AsyncIterable<String>\r\n * AsyncIterable<{ cid: CID recursive, metadata }>\r\n * AsyncIterable<{ path: String recursive, metadata }>\r\n * ```\r\n * Into:\r\n *\r\n * ```ts\r\n * AsyncIterable<{ path: CID|String, recursive:boolean, metadata }>\r\n * ```\r\n *\r\n * @param {Source} input\r\n * @returns {AsyncIterable<Pin>}\r\n */\r\n// eslint-disable-next-line complexity\r\nmodule.exports = async function * normaliseInput (input) {\r\n  // must give us something\r\n  if (input === null || input === undefined) {\r\n    throw errCode(new Error(`Unexpected input: ${input}`), 'ERR_UNEXPECTED_INPUT')\r\n  }\r\n\r\n  // CID|String\r\n  if (CID.isCID(input)) {\r\n    yield toPin({ cid: input })\r\n    return\r\n  }\r\n\r\n  if (input instanceof String || typeof input === 'string') {\r\n    yield toPin({ path: input })\r\n    return\r\n  }\r\n\r\n  // { cid: CID recursive, metadata }\r\n  // @ts-ignore - it still could be iterable or async iterable\r\n  if (input.cid != null || input.path != null) {\r\n    // @ts-ignore\r\n    return yield toPin(input)\r\n  }\r\n\r\n  // Iterable<?>\r\n  if (input[Symbol.iterator]) {\r\n    const iterator = input[Symbol.iterator]()\r\n    const first = iterator.next()\r\n    if (first.done) return iterator\r\n\r\n    // Iterable<CID|String>\r\n    if (CID.isCID(first.value) || first.value instanceof String || typeof first.value === 'string') {\r\n      yield toPin({ cid: first.value })\r\n      for (const cid of iterator) {\r\n        yield toPin({ cid })\r\n      }\r\n      return\r\n    }\r\n\r\n    // Iterable<{ cid: CID recursive, metadata }>\r\n    if (first.value.cid != null || first.value.path != null) {\r\n      yield toPin(first.value)\r\n      for (const obj of iterator) {\r\n        yield toPin(obj)\r\n      }\r\n      return\r\n    }\r\n\r\n    throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT')\r\n  }\r\n\r\n  // AsyncIterable<?>\r\n  if (input[Symbol.asyncIterator]) {\r\n    const iterator = input[Symbol.asyncIterator]()\r\n    const first = await iterator.next()\r\n    if (first.done) return iterator\r\n\r\n    // AsyncIterable<CID|String>\r\n    if (CID.isCID(first.value) || first.value instanceof String || typeof first.value === 'string') {\r\n      yield toPin({ cid: first.value })\r\n      for await (const cid of iterator) {\r\n        yield toPin({ cid })\r\n      }\r\n      return\r\n    }\r\n\r\n    // AsyncIterable<{ cid: CID|String recursive, metadata }>\r\n    if (first.value.cid != null || first.value.path != null) {\r\n      yield toPin(first.value)\r\n      for await (const obj of iterator) {\r\n        yield toPin(obj)\r\n      }\r\n      return\r\n    }\r\n\r\n    throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT')\r\n  }\r\n\r\n  throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT')\r\n}\r\n\r\n/**\r\n * @param {ToPinWithPath|ToPinWithCID} input\r\n * @returns {Pin}\r\n */\r\nfunction toPin (input) {\r\n  const pin = {\r\n    path: input.path == null ? input.cid : `${input.path}`,\r\n    recursive: input.recursive !== false\r\n  }\r\n\r\n  if (input.metadata != null) {\r\n    pin.metadata = input.metadata\r\n  }\r\n\r\n  return pin\r\n}\r\n\r\n/**\r\n * @typedef {Object} ToPinWithPath\r\n * @property {string | InstanceType<typeof window.String> | CID} path\r\n * @property {undefined} [cid]\r\n * @property {boolean} [recursive]\r\n * @property {any} [metadata]\r\n *\r\n * @typedef {Object} ToPinWithCID\r\n * @property {undefined} [path]\r\n * @property {CID} cid\r\n * @property {boolean} [recursive]\r\n * @property {any} [metadata]\r\n *\r\n * @typedef {CID|string|InstanceType<typeof window.String>|ToPinWithPath|ToPinWithPath} ToPin\r\n * @typedef {ToPin|Iterable<ToPin>|AsyncIterable<ToPin>} Source\r\n *\r\n * @typedef {Object} Pin\r\n * @property {string|CID} path\r\n * @property {boolean} recursive\r\n * @property {any} [metadata]\r\n */\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}