{"ast":null,"code":"var _createForOfIteratorHelper = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\n/*\r\n    Copyright 2020 The caver-js Authors\r\n    This file is part of the caver-js library.\r\n\r\n    The caver-js library is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    The caver-js library is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\r\n*/\nvar _ = require('lodash');\n\nvar Bytes = require('eth-lib/lib/bytes');\n\nvar RLP = require('eth-lib/lib/rlp');\n\nvar Hash = require('eth-lib/lib/hash');\n\nvar TransactionHasher = require('../transactionHasher/transactionHasher');\n\nvar utils = require('../../../caver-utils');\n\nvar Keyring = require('../../../caver-wallet/src/keyring/keyringFactory');\n\nvar SingleKeyring = require('../../../caver-wallet/src/keyring/singleKeyring');\n\nvar MultipleKeyring = require('../../../caver-wallet/src/keyring/multipleKeyring');\n\nvar RoleBasedKeyring = require('../../../caver-wallet/src/keyring/roleBasedKeyring');\n\nvar _require = require('../transactionHelper/transactionHelper'),\n    TX_TYPE_STRING = _require.TX_TYPE_STRING,\n    refineSignatures = _require.refineSignatures,\n    typeDetectionFromRLPEncoding = _require.typeDetectionFromRLPEncoding,\n    isEthereumTxType = _require.isEthereumTxType;\n\nvar _require2 = require('../../../caver-wallet/src/keyring/keyringHelper'),\n    KEY_ROLE = _require2.KEY_ROLE;\n\nvar _require3 = require('../../../caver-core-helpers/src/validateFunction'),\n    validateParams = _require3.validateParams;\n\nvar SignatureData = require('../../../caver-wallet/src/keyring/signatureData');\n/**\r\n * Abstract class that implements common logic for each transaction type.\r\n * @class\r\n * @hideconstructor\r\n * @abstract\r\n */\n\n\nvar AbstractTransaction = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\r\n   * Abstract class that implements common logic for each transaction type.\r\n   * In this constructor, type, tag, nonce, gasPrice, chainId, gas and signatures are set as transaction member variables.\r\n   *\r\n   * @constructor\r\n   * @param {string} typeString - The type string of transaction.\r\n   * @param {object} createTxObj - The parameters to create a transaction instance.\r\n   * @param {object} [klaytnCall] - An object includes klay rpc calls.\r\n   */\n  function AbstractTransaction(typeString, createTxObj) {\n    var klaytnCall = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : AbstractTransaction._klaytnCall;\n\n    _classCallCheck(this, AbstractTransaction);\n\n    this._type = typeString;\n    createTxObj.type = typeString;\n    var err = validateParams(createTxObj);\n    if (err) throw err;\n    this.from = createTxObj.from;\n    this.gas = createTxObj.gas; // The variables below are values that the user does not need to pass to the parameter.\n\n    if (createTxObj.nonce !== undefined) this.nonce = createTxObj.nonce;\n    if (createTxObj.chainId !== undefined) this.chainId = createTxObj.chainId;\n    this.signatures = createTxObj.signatures || [];\n    this.klaytnCall = klaytnCall;\n  }\n  /**\r\n   * @type {string}\r\n   */\n\n\n  _createClass(AbstractTransaction, [{\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    }\n    /**\r\n     * @type {string}\r\n     */\n\n  }, {\n    key: \"from\",\n    get: function get() {\n      return this._from;\n    },\n    set: function set(address) {\n      if (this.type === TX_TYPE_STRING.TxTypeLegacyTransaction && (address === '0x' || address === '0x0000000000000000000000000000000000000000')) {\n        this._from = address.toLowerCase();\n      } else {\n        if (!utils.isAddress(address)) throw new Error(\"Invalid address \".concat(address));\n        this._from = address.toLowerCase();\n      }\n    }\n    /**\r\n     * @type {string}\r\n     */\n\n  }, {\n    key: \"nonce\",\n    get: function get() {\n      return this._nonce;\n    },\n    set: function set(n) {\n      this._nonce = utils.numberToHex(n);\n    }\n    /**\r\n     * @type {string}\r\n     */\n\n  }, {\n    key: \"gas\",\n    get: function get() {\n      return this._gas;\n    },\n    set: function set(g) {\n      this._gas = utils.numberToHex(g);\n    }\n    /**\r\n     * @type {string}\r\n     */\n\n  }, {\n    key: \"chainId\",\n    get: function get() {\n      return this._chainId;\n    },\n    set: function set(ch) {\n      this._chainId = utils.toHex(ch);\n    }\n    /**\r\n     * @type {Array<string>|Array.<Array<string>>}\r\n     */\n\n  }, {\n    key: \"signatures\",\n    get: function get() {\n      return this._signatures;\n    },\n    set: function set(sigs) {\n      this._signatures = refineSignatures(sigs, this.type);\n    }\n    /**\r\n     * @type {object}\r\n     */\n\n  }, {\n    key: \"klaytnCall\",\n    get: function get() {\n      return this._klaytnCall;\n    },\n    set: function set(c) {\n      this._klaytnCall = c;\n    }\n    /**\r\n     * Calls `klay_chainID` klay rpc call.\r\n     *\r\n     * @example\r\n     * const result = await tx.getChainId()\r\n     *\r\n     * @return {string} chain id\r\n     */\n\n  }, {\n    key: \"getChainId\",\n    value: function () {\n      var _getChainId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var chainId;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.klaytnCall.getChainId();\n\n              case 2:\n                chainId = _context.sent;\n                return _context.abrupt(\"return\", chainId);\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getChainId() {\n        return _getChainId.apply(this, arguments);\n      }\n\n      return getChainId;\n    }()\n    /**\r\n     * Suggests a gas price to use in the transaction.\r\n     * Calls `klay_gasPrice` to return unit price of the gas.\r\n     *\r\n     * @example\r\n     * const result = await tx.suggestGasPrice()\r\n     *\r\n     * @return {string} gas price\r\n     */\n\n  }, {\n    key: \"suggestGasPrice\",\n    value: function () {\n      var _suggestGasPrice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var suggestion;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.klaytnCall.getGasPrice();\n\n              case 2:\n                suggestion = _context2.sent;\n                return _context2.abrupt(\"return\", suggestion);\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function suggestGasPrice() {\n        return _suggestGasPrice.apply(this, arguments);\n      }\n\n      return suggestGasPrice;\n    }()\n    /**\r\n     * Calls `klay_gasPrice` klay rpc call.\r\n     * Note that when Klaytn network use dynamic gas fee,\r\n     * you need to use `tx.suggestGasPrice` function in the gasPrice field.\r\n     *\r\n     * @example\r\n     * const result = await tx.getGasPrice()\r\n     *\r\n     * @return {string} gas price\r\n     */\n\n  }, {\n    key: \"getGasPrice\",\n    value: function () {\n      var _getGasPrice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var gasPrice;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.klaytnCall.getGasPrice();\n\n              case 2:\n                gasPrice = _context3.sent;\n                return _context3.abrupt(\"return\", gasPrice);\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getGasPrice() {\n        return _getGasPrice.apply(this, arguments);\n      }\n\n      return getGasPrice;\n    }()\n    /**\r\n     * Calls `klay_getTransactionCount` klay rpc call.\r\n     *\r\n     * @example\r\n     * const result = await tx.getNonce('0x{from address}')\r\n     *\r\n     * @return {string} nonce\r\n     */\n\n  }, {\n    key: \"getNonce\",\n    value: function () {\n      var _getNonce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(from) {\n        var nonce;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.klaytnCall.getTransactionCount(from, 'pending');\n\n              case 2:\n                nonce = _context4.sent;\n                return _context4.abrupt(\"return\", nonce);\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getNonce(_x) {\n        return _getNonce.apply(this, arguments);\n      }\n\n      return getNonce;\n    }()\n    /**\r\n     * Calls `klay_getHeaderByNumber` klay rpc call to get `baseFeePerGas` in header.\r\n     * If `baseFeePerGas` is not existed, returns '0x0'.\r\n     *\r\n     * @example\r\n     * const result = await tx.getBaseFee()\r\n     *\r\n     * @return {string} base fee\r\n     */\n\n  }, {\n    key: \"getBaseFee\",\n    value: function () {\n      var _getBaseFee = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var header;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.klaytnCall.getHeaderByNumber('latest');\n\n              case 2:\n                header = _context5.sent;\n                return _context5.abrupt(\"return\", header.baseFeePerGas || '0x0');\n\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getBaseFee() {\n        return _getBaseFee.apply(this, arguments);\n      }\n\n      return getBaseFee;\n    }()\n    /**\r\n     * Calls `klay_maxPriorityFeePerGas` klay rpc call.\r\n     *\r\n     * @example\r\n     * const result = await tx.getMaxPriorityFeePerGas()\r\n     *\r\n     * @return {string} suggested max priority fee per gas\r\n     */\n\n  }, {\n    key: \"getMaxPriorityFeePerGas\",\n    value: function () {\n      var _getMaxPriorityFeePerGas = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var maxPriorityFeePerGas;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.klaytnCall.getMaxPriorityFeePerGas();\n\n              case 2:\n                maxPriorityFeePerGas = _context6.sent;\n                return _context6.abrupt(\"return\", maxPriorityFeePerGas);\n\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function getMaxPriorityFeePerGas() {\n        return _getMaxPriorityFeePerGas.apply(this, arguments);\n      }\n\n      return getMaxPriorityFeePerGas;\n    }()\n    /**\r\n     * Returns the RLP-encoded string of this transaction (i.e., rawTransaction).\r\n     * This method has to be overrided in classes which extends AbstractTransaction.\r\n     *\r\n     * @example\r\n     * const result = tx.getRLPEncoding()\r\n     *\r\n     * @return {string} An RLP-encoded transaction string.\r\n     */\n\n  }, {\n    key: \"getRLPEncoding\",\n    value: function getRLPEncoding() {\n      throw new Error(\"Not implemented.\");\n    }\n    /**\r\n     * Returns the RLP-encoded string to make the signature of this transaction.\r\n     * This method has to be overrided in classes which extends AbstractTransaction.\r\n     * getCommonRLPEncodingForSignature is used in getRLPEncodingForSignature.\r\n     *\r\n     * @example\r\n     * const result = tx.getCommonRLPEncodingForSignature()\r\n     *\r\n     * @return {string} An RLP-encoded transaction string without signature.\r\n     */\n\n  }, {\n    key: \"getCommonRLPEncodingForSignature\",\n    value: function getCommonRLPEncodingForSignature() {\n      throw new Error(\"Not implemented.\");\n    }\n    /**\r\n     * Signs the transaction as a transaction sender with the private key(s) in the `keyring` and appends `signatures` in the transaction object.\r\n     *\r\n     * For {@link AccountUpdate|Account Update} transaction, use \"roleAccountUpdateKey\", or otherwise, use \"roleTransactionKey\" in {@link RoleBasedKeyring}.\r\n     * If the user has not defined an `index`, `transaction.sign` signs the transaction using \"all the private keys\" used by the role.\r\n     * If `index` is defined, the `transaction.sign` signs the transaction using \"only one private key\" at the given index.\r\n     *\r\n     * @example\r\n     * const keyring = caver.wallet.keyring.create('0x{address in hex}', '0x{private key}')\r\n     * const signedTx = await tx.sign(keyring)\r\n     *\r\n     * const keyring = caver.wallet.keyring.create('0x{address in hex}', ['0x{private key}', '0x{private key}'])\r\n     * const signedTx = await tx.sign(keyring, 1) // sign the transaction with index. If omitted, sign with all private keys.\r\n     *\r\n     * @param {KeyringContainer.Keyring|string} key - A private key string ({@link https://docs.klaytn.com/klaytn/design/accounts#klaytn-wallet-key-format|KlaytnWalletKey} format is also allowed) or an instance of {@link KeyringContainer.Keyring|Keyring}. If a private key string or a KlaytnWalletKey is passed as a parameter, the keyring instance is created internally.\r\n     * @param {number} [index] - The index of the private key you want to use. The index must be less than the length of the array of the private keys defined for each role. If an index is not defined, this method will use all the private keys.\r\n     * @param {function} [hasher] - The hash function to get the hash of the transaction.\r\n     * @return {module:Transaction.Transaction} An instance of signed Transaction. The `signature` is appended to the `transaction.signatures`.\r\n     */\n\n  }, {\n    key: \"sign\",\n    value: function () {\n      var _sign2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(key, index) {\n        var hasher,\n            _yield$this$_sign,\n            keyring,\n            hash,\n            role,\n            sig,\n            _args7 = arguments;\n\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                hasher = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : TransactionHasher.getHashForSignature;\n\n                // User parameter input cases\n                // (key) / (key index) / (key hasher) / (key index hasher)\n                if (_.isFunction(index)) {\n                  hasher = index;\n                  index = undefined;\n                }\n\n                _context7.next = 4;\n                return this._sign(key, hasher);\n\n              case 4:\n                _yield$this$_sign = _context7.sent;\n                keyring = _yield$this$_sign.keyring;\n                hash = _yield$this$_sign.hash;\n                role = _yield$this$_sign.role;\n                sig = keyring.sign(hash, this.chainId, role, index);\n                this.appendSignatures(sig);\n                return _context7.abrupt(\"return\", this);\n\n              case 11:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function sign(_x2, _x3) {\n        return _sign2.apply(this, arguments);\n      }\n\n      return sign;\n    }()\n    /**\r\n     * Appends `signatures` to the transaction.\r\n     *\r\n     * @example\r\n     * tx.appendSignatures([ '0x0fea', '0xade94...', '0x38160...' ])\r\n     *\r\n     * const sig = [[ '0x0fea', '0xade94...', '0x38160...' ], [ '0x0fea', '0xbde66...', '0x546eb...' ]]\r\n     * tx.appendSignatures(sig)\r\n     *\r\n     * @param {SignatureData|Array.<SignatureData>|Array.<string>|Array.<Array.<string>>} signatures - The `signatures` to be appended to the transaction. {@link SignatureData} instance or an array containing {@link SignatureData} instances.\r\n     *                                                                                                 An array in which each 'v', 'r', and 's' are sequentially defined as string formats or a 2D array containing those arrays can also be taken as parameters.\r\n     */\n\n  }, {\n    key: \"appendSignatures\",\n    value: function appendSignatures(signatures) {\n      var sig = signatures;\n      if (_.isString(sig)) sig = utils.resolveSignature(sig);\n      if (sig instanceof SignatureData) sig = [sig];\n      if (!_.isArray(sig)) throw new Error(\"Failed to append signatures: invalid signatures format \".concat(sig));\n      if (_.isString(sig[0])) sig = [sig];\n      this.signatures = this.signatures.concat(sig);\n    }\n    /**\r\n     * Collects signs in each RLP-encoded transaction string in the given array, combines them with the transaction instance, and returns a RLP-encoded transaction string which includes all signs.\r\n     *\r\n     * Note that the transaction instance doesn't necessarily be signed in advance.\r\n     *\r\n     * When combining the signatures into a transaction instance, an error is thrown if the decoded transaction contains different value except signatures.\r\n     *\r\n     * @example\r\n     * const combined = tx.combineSignedRawTransactions(['0x09f88...'])\r\n     *\r\n     * @param {Array.<string>} rlpEncodedTxs - An array of signed RLP-encoded transaction strings.\r\n     * @return {string} A RLP-encoded transaction string which includes all `signatures`.\r\n     */\n\n  }, {\n    key: \"combineSignedRawTransactions\",\n    value: function combineSignedRawTransactions(rlpEncodedTxs) {\n      if (!_.isArray(rlpEncodedTxs)) throw new Error(\"The parameter must be an array of RLP-encoded transaction strings.\"); // If the signatures are empty, there may be an undefined member variable.\n      // In this case, the empty information is filled with the decoded result.\n\n      var fillVariables = false;\n      if (utils.isEmptySig(this.signatures)) fillVariables = true;\n\n      var _iterator = _createForOfIteratorHelper(rlpEncodedTxs),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var encoded = _step.value;\n          var type = typeDetectionFromRLPEncoding(encoded);\n          if (this.type !== type) throw new Error(\"Transaction type mismatch: Signatures from different transactions cannot be combined.\");\n          var decoded = this.constructor.decode(encoded); // Signatures can only be combined for the same transaction.\n          // Therefore, compare whether the decoded transaction is the same as this.\n\n          for (var k in decoded) {\n            if (k === '_klaytnCall' || k === '_signatures' || k === '_feePayerSignatures') continue;\n            if (this[k] === undefined && fillVariables) this[k] = decoded[k];\n            var differentTxError = \"Transactions containing different information cannot be combined.\"; // Compare with the RLP-encoded accountKey string, because 'account' is an object.\n\n            if (k === '_account') {\n              if (this[k].getRLPEncodingAccountKey() !== decoded[k].getRLPEncodingAccountKey()) throw new Error(differentTxError);\n              continue;\n            }\n\n            if (k === '_accessList') {\n              if (!this[k].isEqual(decoded[k])) throw new Error(differentTxError);\n              continue;\n            }\n\n            if (this[k] !== decoded[k]) {\n              // console.log(`k(${k}) is different. ${this[k]} vs ${decoded[k]}`)\n              throw new Error(differentTxError);\n            }\n          }\n\n          this.appendSignatures(decoded.signatures);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return this.getRLPEncoding();\n    }\n    /**\r\n     * Returns a `rawTransaction` string (a RLP-encoded transaction string).\r\n     * This function is same with {@link AbstractTransaction#getRLPEncoding|transaction.getRLPEncoding}.\r\n     *\r\n     * @example\r\n     * const result = tx.getRawTransaction()\r\n     *\r\n     * @return {string}\r\n     */\n\n  }, {\n    key: \"getRawTransaction\",\n    value: function getRawTransaction() {\n      return this.getRLPEncoding();\n    }\n    /**\r\n     * Returns a hash string of transaction.\r\n     *\r\n     * @example\r\n     * const result = tx.getTransactionHash()\r\n     *\r\n     * @return {string}\r\n     */\n\n  }, {\n    key: \"getTransactionHash\",\n    value: function getTransactionHash() {\n      return Hash.keccak256(this.getRLPEncoding());\n    }\n    /**\r\n     * Returns a {@link https://docs.klaytn.com/klaytn/design/transactions#sendertxhash|senderTxHash} of transaction.\r\n     * The {@link https://docs.klaytn.com/klaytn/design/transactions#sendertxhash|senderTxHash} is a hash of the transaction except for the fee payer's address and signature, so transactionHash and senderTxHash are the same for basic transactions.\r\n     *\r\n     * @example\r\n     * const result = tx.getSenderTxHash()\r\n     *\r\n     * @return {string} A senderTxHash.\r\n     */\n\n  }, {\n    key: \"getSenderTxHash\",\n    value: function getSenderTxHash() {\n      return this.getTransactionHash();\n    }\n    /**\r\n     * Returns an RLP-encoded transaction string for making signature.\r\n     *\r\n     * @example\r\n     * const result = tx.getRLPEncodingForSignature()\r\n     *\r\n     * @return {string} An RLP-encoded transaction string without any signature attached.\r\n     */\n\n  }, {\n    key: \"getRLPEncodingForSignature\",\n    value: function getRLPEncodingForSignature() {\n      this.validateOptionalValues();\n      if (this.chainId === undefined) throw new Error(\"chainId is undefined. Define chainId in transaction or use 'transaction.fillTransaction' to fill values.\");\n      return RLP.encode([this.getCommonRLPEncodingForSignature(), Bytes.fromNat(this.chainId), '0x', '0x']);\n    }\n    /**\r\n     * Recovers the public key strings from `signatures` field in transaction object.\r\n     * If you want to derive an address from public key, please use {@link module:utils~publicKeyToAddress|caver.utils.publicKeyToAddress}.\r\n     *\r\n     * @example\r\n     * const publicKey = tx.recoverPublicKeys()\r\n     *\r\n     * @return {Array.<string>} An array containing public keys recovered from `signatures`.\r\n     */\n\n  }, {\n    key: \"recoverPublicKeys\",\n    value: function recoverPublicKeys() {\n      if (utils.isEmptySig(this.signatures)) throw new Error(\"Failed to recover public keys from signatures: signatures is empty.\");\n      var recovery = Bytes.toNumber(this.signatures[0].v);\n      var chainId = recovery < 35 ? Bytes.fromNat('0x1') : Bytes.fromNumber(recovery - 35 >> 1);\n      if (!this.chainId) this.chainId = chainId;\n      var signingDataHex = this.getRLPEncodingForSignature();\n      var hasedSigningData = Hash.keccak256(signingDataHex);\n      var publicKeys = [];\n\n      var _iterator2 = _createForOfIteratorHelper(this.signatures),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var sig = _step2.value;\n          var sigV = Bytes.toNumber(sig.v);\n          var recoveryData = sigV < 35 ? Bytes.fromNat('0x1') : Bytes.fromNumber(sigV - 35 >> 1);\n          if (utils.trimLeadingZero(this.chainId) !== utils.trimLeadingZero(recoveryData)) throw new Error(\"Invalid signatures data: recovery data is not matched.\");\n          publicKeys.push(utils.recoverPublicKey(hasedSigningData, sig, true));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return publicKeys;\n    }\n    /**\r\n     * Fills in the optional variables in transaction.\r\n     *\r\n     * If the `gasPrice`, `nonce`, or `chainId` of the transaction are not defined, this method asks the default values for these optional variables and preset them by sending JSON RPC call to the connected Klaytn Node.\r\n     * Use {@link Klay#getGasPrice|caver.rpc.klay.getGasPrice} to get gasPrice, {@link Klay#getTransactionCount|caver.rpc.klay.getTransactionCount} to get nonce and {@link Klay#getChainId|caver.rpc.klay.getChainId} call to get chainId.\r\n     *\r\n     * @example\r\n     * await tx.fillTransaction()\r\n     */\n\n  }, {\n    key: \"fillTransaction\",\n    value: function () {\n      var _fillTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                throw new Error(\"Not implemented.\");\n\n              case 1:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }));\n\n      function fillTransaction() {\n        return _fillTransaction.apply(this, arguments);\n      }\n\n      return fillTransaction;\n    }()\n    /**\r\n     * Checks that member variables that can be defined by the user are defined.\r\n     * If there is an undefined variable, an error occurs.\r\n     *\r\n     * @ignore\r\n     */\n\n  }, {\n    key: \"validateOptionalValues\",\n    value: function validateOptionalValues() {\n      if (this.nonce === undefined) throw new Error(\"nonce is undefined. Define nonce in transaction or use 'transaction.fillTransaction' to fill values.\");\n    }\n  }, {\n    key: \"_sign\",\n    value: function () {\n      var _sign3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(key, hasher) {\n        var keyring, hash, role;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                keyring = key;\n\n                if (_.isString(key)) {\n                  keyring = Keyring.createFromPrivateKey(key);\n                }\n\n                if (!(!(keyring instanceof SingleKeyring) && !(keyring instanceof MultipleKeyring) && !(keyring instanceof RoleBasedKeyring))) {\n                  _context9.next = 4;\n                  break;\n                }\n\n                throw new Error(\"Unsupported key type. The key must be a single private key string, KlaytnWalletKey string, or Keyring instance.\");\n\n              case 4:\n                if (!(isEthereumTxType(this.type) && keyring.isDecoupled())) {\n                  _context9.next = 6;\n                  break;\n                }\n\n                throw new Error(\"\".concat(this.type, \" cannot be signed with a decoupled keyring.\"));\n\n              case 6:\n                if (!this.from || this.from === '0x' || this.from === '0x0000000000000000000000000000000000000000') this.from = keyring.address;\n\n                if (!(this.from.toLowerCase() !== keyring.address.toLowerCase())) {\n                  _context9.next = 9;\n                  break;\n                }\n\n                throw new Error(\"The from address of the transaction is different with the address of the keyring to use.\");\n\n              case 9:\n                _context9.next = 11;\n                return this.fillTransaction();\n\n              case 11:\n                hash = hasher(this);\n                role = this.type.includes('AccountUpdate') ? KEY_ROLE.roleAccountUpdateKey : KEY_ROLE.roleTransactionKey;\n                return _context9.abrupt(\"return\", {\n                  keyring: keyring,\n                  hash: hash,\n                  role: role\n                });\n\n              case 14:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function _sign(_x4, _x5) {\n        return _sign3.apply(this, arguments);\n      }\n\n      return _sign;\n    }()\n  }]);\n\n  return AbstractTransaction;\n}();\n\nmodule.exports = AbstractTransaction;","map":{"version":3,"names":["_","require","Bytes","RLP","Hash","TransactionHasher","utils","Keyring","SingleKeyring","MultipleKeyring","RoleBasedKeyring","TX_TYPE_STRING","refineSignatures","typeDetectionFromRLPEncoding","isEthereumTxType","KEY_ROLE","validateParams","SignatureData","AbstractTransaction","typeString","createTxObj","klaytnCall","_klaytnCall","_type","type","err","from","gas","nonce","undefined","chainId","signatures","_from","address","TxTypeLegacyTransaction","toLowerCase","isAddress","Error","_nonce","n","numberToHex","_gas","g","_chainId","ch","toHex","_signatures","sigs","c","getChainId","getGasPrice","suggestion","gasPrice","getTransactionCount","getHeaderByNumber","header","baseFeePerGas","getMaxPriorityFeePerGas","maxPriorityFeePerGas","key","index","hasher","getHashForSignature","isFunction","_sign","keyring","hash","role","sig","sign","appendSignatures","isString","resolveSignature","isArray","concat","rlpEncodedTxs","fillVariables","isEmptySig","encoded","decoded","constructor","decode","k","differentTxError","getRLPEncodingAccountKey","isEqual","getRLPEncoding","keccak256","getTransactionHash","validateOptionalValues","encode","getCommonRLPEncodingForSignature","fromNat","recovery","toNumber","v","fromNumber","signingDataHex","getRLPEncodingForSignature","hasedSigningData","publicKeys","sigV","recoveryData","trimLeadingZero","push","recoverPublicKey","createFromPrivateKey","isDecoupled","fillTransaction","includes","roleAccountUpdateKey","roleTransactionKey","module","exports"],"sources":["C:/Users/User/Documents/clone-starter-kit-08/node_modules/caver-js/packages/caver-transaction/src/transactionTypes/abstractTransaction.js"],"sourcesContent":["/*\r\n    Copyright 2020 The caver-js Authors\r\n    This file is part of the caver-js library.\r\n\r\n    The caver-js library is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    The caver-js library is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst _ = require('lodash')\r\nconst Bytes = require('eth-lib/lib/bytes')\r\nconst RLP = require('eth-lib/lib/rlp')\r\nconst Hash = require('eth-lib/lib/hash')\r\nconst TransactionHasher = require('../transactionHasher/transactionHasher')\r\nconst utils = require('../../../caver-utils')\r\nconst Keyring = require('../../../caver-wallet/src/keyring/keyringFactory')\r\nconst SingleKeyring = require('../../../caver-wallet/src/keyring/singleKeyring')\r\nconst MultipleKeyring = require('../../../caver-wallet/src/keyring/multipleKeyring')\r\nconst RoleBasedKeyring = require('../../../caver-wallet/src/keyring/roleBasedKeyring')\r\nconst {\r\n    TX_TYPE_STRING,\r\n    refineSignatures,\r\n    typeDetectionFromRLPEncoding,\r\n    isEthereumTxType,\r\n} = require('../transactionHelper/transactionHelper')\r\nconst { KEY_ROLE } = require('../../../caver-wallet/src/keyring/keyringHelper')\r\nconst { validateParams } = require('../../../caver-core-helpers/src/validateFunction')\r\nconst SignatureData = require('../../../caver-wallet/src/keyring/signatureData')\r\n\r\n/**\r\n * Abstract class that implements common logic for each transaction type.\r\n * @class\r\n * @hideconstructor\r\n * @abstract\r\n */\r\nclass AbstractTransaction {\r\n    /**\r\n     * Abstract class that implements common logic for each transaction type.\r\n     * In this constructor, type, tag, nonce, gasPrice, chainId, gas and signatures are set as transaction member variables.\r\n     *\r\n     * @constructor\r\n     * @param {string} typeString - The type string of transaction.\r\n     * @param {object} createTxObj - The parameters to create a transaction instance.\r\n     * @param {object} [klaytnCall] - An object includes klay rpc calls.\r\n     */\r\n    constructor(typeString, createTxObj, klaytnCall = AbstractTransaction._klaytnCall) {\r\n        this._type = typeString\r\n\r\n        createTxObj.type = typeString\r\n\r\n        const err = validateParams(createTxObj)\r\n        if (err) throw err\r\n\r\n        this.from = createTxObj.from\r\n\r\n        this.gas = createTxObj.gas\r\n\r\n        // The variables below are values that the user does not need to pass to the parameter.\r\n        if (createTxObj.nonce !== undefined) this.nonce = createTxObj.nonce\r\n        if (createTxObj.chainId !== undefined) this.chainId = createTxObj.chainId\r\n\r\n        this.signatures = createTxObj.signatures || []\r\n        this.klaytnCall = klaytnCall\r\n    }\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    get type() {\r\n        return this._type\r\n    }\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    get from() {\r\n        return this._from\r\n    }\r\n\r\n    set from(address) {\r\n        if (\r\n            this.type === TX_TYPE_STRING.TxTypeLegacyTransaction &&\r\n            (address === '0x' || address === '0x0000000000000000000000000000000000000000')\r\n        ) {\r\n            this._from = address.toLowerCase()\r\n        } else {\r\n            if (!utils.isAddress(address)) throw new Error(`Invalid address ${address}`)\r\n            this._from = address.toLowerCase()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    get nonce() {\r\n        return this._nonce\r\n    }\r\n\r\n    set nonce(n) {\r\n        this._nonce = utils.numberToHex(n)\r\n    }\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    get gas() {\r\n        return this._gas\r\n    }\r\n\r\n    set gas(g) {\r\n        this._gas = utils.numberToHex(g)\r\n    }\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    get chainId() {\r\n        return this._chainId\r\n    }\r\n\r\n    set chainId(ch) {\r\n        this._chainId = utils.toHex(ch)\r\n    }\r\n\r\n    /**\r\n     * @type {Array<string>|Array.<Array<string>>}\r\n     */\r\n    get signatures() {\r\n        return this._signatures\r\n    }\r\n\r\n    set signatures(sigs) {\r\n        this._signatures = refineSignatures(sigs, this.type)\r\n    }\r\n\r\n    /**\r\n     * @type {object}\r\n     */\r\n    get klaytnCall() {\r\n        return this._klaytnCall\r\n    }\r\n\r\n    set klaytnCall(c) {\r\n        this._klaytnCall = c\r\n    }\r\n\r\n    /**\r\n     * Calls `klay_chainID` klay rpc call.\r\n     *\r\n     * @example\r\n     * const result = await tx.getChainId()\r\n     *\r\n     * @return {string} chain id\r\n     */\r\n    async getChainId() {\r\n        const chainId = await this.klaytnCall.getChainId()\r\n        return chainId\r\n    }\r\n\r\n    /**\r\n     * Suggests a gas price to use in the transaction.\r\n     * Calls `klay_gasPrice` to return unit price of the gas.\r\n     *\r\n     * @example\r\n     * const result = await tx.suggestGasPrice()\r\n     *\r\n     * @return {string} gas price\r\n     */\r\n    async suggestGasPrice() {\r\n        const suggestion = await this.klaytnCall.getGasPrice()\r\n        return suggestion\r\n    }\r\n\r\n    /**\r\n     * Calls `klay_gasPrice` klay rpc call.\r\n     * Note that when Klaytn network use dynamic gas fee,\r\n     * you need to use `tx.suggestGasPrice` function in the gasPrice field.\r\n     *\r\n     * @example\r\n     * const result = await tx.getGasPrice()\r\n     *\r\n     * @return {string} gas price\r\n     */\r\n    async getGasPrice() {\r\n        const gasPrice = await this.klaytnCall.getGasPrice()\r\n        return gasPrice\r\n    }\r\n\r\n    /**\r\n     * Calls `klay_getTransactionCount` klay rpc call.\r\n     *\r\n     * @example\r\n     * const result = await tx.getNonce('0x{from address}')\r\n     *\r\n     * @return {string} nonce\r\n     */\r\n    async getNonce(from) {\r\n        const nonce = await this.klaytnCall.getTransactionCount(from, 'pending')\r\n        return nonce\r\n    }\r\n\r\n    /**\r\n     * Calls `klay_getHeaderByNumber` klay rpc call to get `baseFeePerGas` in header.\r\n     * If `baseFeePerGas` is not existed, returns '0x0'.\r\n     *\r\n     * @example\r\n     * const result = await tx.getBaseFee()\r\n     *\r\n     * @return {string} base fee\r\n     */\r\n    async getBaseFee() {\r\n        const header = await this.klaytnCall.getHeaderByNumber('latest')\r\n        return header.baseFeePerGas || '0x0'\r\n    }\r\n\r\n    /**\r\n     * Calls `klay_maxPriorityFeePerGas` klay rpc call.\r\n     *\r\n     * @example\r\n     * const result = await tx.getMaxPriorityFeePerGas()\r\n     *\r\n     * @return {string} suggested max priority fee per gas\r\n     */\r\n    async getMaxPriorityFeePerGas() {\r\n        const maxPriorityFeePerGas = await this.klaytnCall.getMaxPriorityFeePerGas()\r\n        return maxPriorityFeePerGas\r\n    }\r\n\r\n    /**\r\n     * Returns the RLP-encoded string of this transaction (i.e., rawTransaction).\r\n     * This method has to be overrided in classes which extends AbstractTransaction.\r\n     *\r\n     * @example\r\n     * const result = tx.getRLPEncoding()\r\n     *\r\n     * @return {string} An RLP-encoded transaction string.\r\n     */\r\n    getRLPEncoding() {\r\n        throw new Error(`Not implemented.`)\r\n    }\r\n\r\n    /**\r\n     * Returns the RLP-encoded string to make the signature of this transaction.\r\n     * This method has to be overrided in classes which extends AbstractTransaction.\r\n     * getCommonRLPEncodingForSignature is used in getRLPEncodingForSignature.\r\n     *\r\n     * @example\r\n     * const result = tx.getCommonRLPEncodingForSignature()\r\n     *\r\n     * @return {string} An RLP-encoded transaction string without signature.\r\n     */\r\n    getCommonRLPEncodingForSignature() {\r\n        throw new Error(`Not implemented.`)\r\n    }\r\n\r\n    /**\r\n     * Signs the transaction as a transaction sender with the private key(s) in the `keyring` and appends `signatures` in the transaction object.\r\n     *\r\n     * For {@link AccountUpdate|Account Update} transaction, use \"roleAccountUpdateKey\", or otherwise, use \"roleTransactionKey\" in {@link RoleBasedKeyring}.\r\n     * If the user has not defined an `index`, `transaction.sign` signs the transaction using \"all the private keys\" used by the role.\r\n     * If `index` is defined, the `transaction.sign` signs the transaction using \"only one private key\" at the given index.\r\n     *\r\n     * @example\r\n     * const keyring = caver.wallet.keyring.create('0x{address in hex}', '0x{private key}')\r\n     * const signedTx = await tx.sign(keyring)\r\n     *\r\n     * const keyring = caver.wallet.keyring.create('0x{address in hex}', ['0x{private key}', '0x{private key}'])\r\n     * const signedTx = await tx.sign(keyring, 1) // sign the transaction with index. If omitted, sign with all private keys.\r\n     *\r\n     * @param {KeyringContainer.Keyring|string} key - A private key string ({@link https://docs.klaytn.com/klaytn/design/accounts#klaytn-wallet-key-format|KlaytnWalletKey} format is also allowed) or an instance of {@link KeyringContainer.Keyring|Keyring}. If a private key string or a KlaytnWalletKey is passed as a parameter, the keyring instance is created internally.\r\n     * @param {number} [index] - The index of the private key you want to use. The index must be less than the length of the array of the private keys defined for each role. If an index is not defined, this method will use all the private keys.\r\n     * @param {function} [hasher] - The hash function to get the hash of the transaction.\r\n     * @return {module:Transaction.Transaction} An instance of signed Transaction. The `signature` is appended to the `transaction.signatures`.\r\n     */\r\n    async sign(key, index, hasher = TransactionHasher.getHashForSignature) {\r\n        // User parameter input cases\r\n        // (key) / (key index) / (key hasher) / (key index hasher)\r\n        if (_.isFunction(index)) {\r\n            hasher = index\r\n            index = undefined\r\n        }\r\n\r\n        const { keyring, hash, role } = await this._sign(key, hasher)\r\n\r\n        const sig = keyring.sign(hash, this.chainId, role, index)\r\n\r\n        this.appendSignatures(sig)\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Appends `signatures` to the transaction.\r\n     *\r\n     * @example\r\n     * tx.appendSignatures([ '0x0fea', '0xade94...', '0x38160...' ])\r\n     *\r\n     * const sig = [[ '0x0fea', '0xade94...', '0x38160...' ], [ '0x0fea', '0xbde66...', '0x546eb...' ]]\r\n     * tx.appendSignatures(sig)\r\n     *\r\n     * @param {SignatureData|Array.<SignatureData>|Array.<string>|Array.<Array.<string>>} signatures - The `signatures` to be appended to the transaction. {@link SignatureData} instance or an array containing {@link SignatureData} instances.\r\n     *                                                                                                 An array in which each 'v', 'r', and 's' are sequentially defined as string formats or a 2D array containing those arrays can also be taken as parameters.\r\n     */\r\n    appendSignatures(signatures) {\r\n        let sig = signatures\r\n        if (_.isString(sig)) sig = utils.resolveSignature(sig)\r\n        if (sig instanceof SignatureData) sig = [sig]\r\n\r\n        if (!_.isArray(sig)) throw new Error(`Failed to append signatures: invalid signatures format ${sig}`)\r\n\r\n        if (_.isString(sig[0])) sig = [sig]\r\n\r\n        this.signatures = this.signatures.concat(sig)\r\n    }\r\n\r\n    /**\r\n     * Collects signs in each RLP-encoded transaction string in the given array, combines them with the transaction instance, and returns a RLP-encoded transaction string which includes all signs.\r\n     *\r\n     * Note that the transaction instance doesn't necessarily be signed in advance.\r\n     *\r\n     * When combining the signatures into a transaction instance, an error is thrown if the decoded transaction contains different value except signatures.\r\n     *\r\n     * @example\r\n     * const combined = tx.combineSignedRawTransactions(['0x09f88...'])\r\n     *\r\n     * @param {Array.<string>} rlpEncodedTxs - An array of signed RLP-encoded transaction strings.\r\n     * @return {string} A RLP-encoded transaction string which includes all `signatures`.\r\n     */\r\n    combineSignedRawTransactions(rlpEncodedTxs) {\r\n        if (!_.isArray(rlpEncodedTxs)) throw new Error(`The parameter must be an array of RLP-encoded transaction strings.`)\r\n\r\n        // If the signatures are empty, there may be an undefined member variable.\r\n        // In this case, the empty information is filled with the decoded result.\r\n        let fillVariables = false\r\n        if (utils.isEmptySig(this.signatures)) fillVariables = true\r\n\r\n        for (const encoded of rlpEncodedTxs) {\r\n            const type = typeDetectionFromRLPEncoding(encoded)\r\n            if (this.type !== type) throw new Error(`Transaction type mismatch: Signatures from different transactions cannot be combined.`)\r\n\r\n            const decoded = this.constructor.decode(encoded)\r\n\r\n            // Signatures can only be combined for the same transaction.\r\n            // Therefore, compare whether the decoded transaction is the same as this.\r\n            for (const k in decoded) {\r\n                if (k === '_klaytnCall' || k === '_signatures' || k === '_feePayerSignatures') continue\r\n                if (this[k] === undefined && fillVariables) this[k] = decoded[k]\r\n\r\n                const differentTxError = `Transactions containing different information cannot be combined.`\r\n\r\n                // Compare with the RLP-encoded accountKey string, because 'account' is an object.\r\n                if (k === '_account') {\r\n                    if (this[k].getRLPEncodingAccountKey() !== decoded[k].getRLPEncodingAccountKey()) throw new Error(differentTxError)\r\n                    continue\r\n                }\r\n\r\n                if (k === '_accessList') {\r\n                    if (!this[k].isEqual(decoded[k])) throw new Error(differentTxError)\r\n                    continue\r\n                }\r\n\r\n                if (this[k] !== decoded[k]) {\r\n                    // console.log(`k(${k}) is different. ${this[k]} vs ${decoded[k]}`)\r\n                    throw new Error(differentTxError)\r\n                }\r\n            }\r\n\r\n            this.appendSignatures(decoded.signatures)\r\n        }\r\n\r\n        return this.getRLPEncoding()\r\n    }\r\n\r\n    /**\r\n     * Returns a `rawTransaction` string (a RLP-encoded transaction string).\r\n     * This function is same with {@link AbstractTransaction#getRLPEncoding|transaction.getRLPEncoding}.\r\n     *\r\n     * @example\r\n     * const result = tx.getRawTransaction()\r\n     *\r\n     * @return {string}\r\n     */\r\n    getRawTransaction() {\r\n        return this.getRLPEncoding()\r\n    }\r\n\r\n    /**\r\n     * Returns a hash string of transaction.\r\n     *\r\n     * @example\r\n     * const result = tx.getTransactionHash()\r\n     *\r\n     * @return {string}\r\n     */\r\n    getTransactionHash() {\r\n        return Hash.keccak256(this.getRLPEncoding())\r\n    }\r\n\r\n    /**\r\n     * Returns a {@link https://docs.klaytn.com/klaytn/design/transactions#sendertxhash|senderTxHash} of transaction.\r\n     * The {@link https://docs.klaytn.com/klaytn/design/transactions#sendertxhash|senderTxHash} is a hash of the transaction except for the fee payer's address and signature, so transactionHash and senderTxHash are the same for basic transactions.\r\n     *\r\n     * @example\r\n     * const result = tx.getSenderTxHash()\r\n     *\r\n     * @return {string} A senderTxHash.\r\n     */\r\n    getSenderTxHash() {\r\n        return this.getTransactionHash()\r\n    }\r\n\r\n    /**\r\n     * Returns an RLP-encoded transaction string for making signature.\r\n     *\r\n     * @example\r\n     * const result = tx.getRLPEncodingForSignature()\r\n     *\r\n     * @return {string} An RLP-encoded transaction string without any signature attached.\r\n     */\r\n    getRLPEncodingForSignature() {\r\n        this.validateOptionalValues()\r\n        if (this.chainId === undefined)\r\n            throw new Error(`chainId is undefined. Define chainId in transaction or use 'transaction.fillTransaction' to fill values.`)\r\n\r\n        return RLP.encode([this.getCommonRLPEncodingForSignature(), Bytes.fromNat(this.chainId), '0x', '0x'])\r\n    }\r\n\r\n    /**\r\n     * Recovers the public key strings from `signatures` field in transaction object.\r\n     * If you want to derive an address from public key, please use {@link module:utils~publicKeyToAddress|caver.utils.publicKeyToAddress}.\r\n     *\r\n     * @example\r\n     * const publicKey = tx.recoverPublicKeys()\r\n     *\r\n     * @return {Array.<string>} An array containing public keys recovered from `signatures`.\r\n     */\r\n    recoverPublicKeys() {\r\n        if (utils.isEmptySig(this.signatures)) throw new Error(`Failed to recover public keys from signatures: signatures is empty.`)\r\n\r\n        const recovery = Bytes.toNumber(this.signatures[0].v)\r\n        const chainId = recovery < 35 ? Bytes.fromNat('0x1') : Bytes.fromNumber((recovery - 35) >> 1)\r\n        if (!this.chainId) this.chainId = chainId\r\n        const signingDataHex = this.getRLPEncodingForSignature()\r\n        const hasedSigningData = Hash.keccak256(signingDataHex)\r\n\r\n        const publicKeys = []\r\n        for (const sig of this.signatures) {\r\n            const sigV = Bytes.toNumber(sig.v)\r\n            const recoveryData = sigV < 35 ? Bytes.fromNat('0x1') : Bytes.fromNumber((sigV - 35) >> 1)\r\n\r\n            if (utils.trimLeadingZero(this.chainId) !== utils.trimLeadingZero(recoveryData))\r\n                throw new Error(`Invalid signatures data: recovery data is not matched.`)\r\n\r\n            publicKeys.push(utils.recoverPublicKey(hasedSigningData, sig, true))\r\n        }\r\n\r\n        return publicKeys\r\n    }\r\n\r\n    /**\r\n     * Fills in the optional variables in transaction.\r\n     *\r\n     * If the `gasPrice`, `nonce`, or `chainId` of the transaction are not defined, this method asks the default values for these optional variables and preset them by sending JSON RPC call to the connected Klaytn Node.\r\n     * Use {@link Klay#getGasPrice|caver.rpc.klay.getGasPrice} to get gasPrice, {@link Klay#getTransactionCount|caver.rpc.klay.getTransactionCount} to get nonce and {@link Klay#getChainId|caver.rpc.klay.getChainId} call to get chainId.\r\n     *\r\n     * @example\r\n     * await tx.fillTransaction()\r\n     */\r\n    async fillTransaction() {\r\n        throw new Error(`Not implemented.`)\r\n    }\r\n\r\n    /**\r\n     * Checks that member variables that can be defined by the user are defined.\r\n     * If there is an undefined variable, an error occurs.\r\n     *\r\n     * @ignore\r\n     */\r\n    validateOptionalValues() {\r\n        if (this.nonce === undefined)\r\n            throw new Error(`nonce is undefined. Define nonce in transaction or use 'transaction.fillTransaction' to fill values.`)\r\n    }\r\n\r\n    async _sign(key, hasher) {\r\n        let keyring = key\r\n        if (_.isString(key)) {\r\n            keyring = Keyring.createFromPrivateKey(key)\r\n        }\r\n        if (!(keyring instanceof SingleKeyring) && !(keyring instanceof MultipleKeyring) && !(keyring instanceof RoleBasedKeyring))\r\n            throw new Error(\r\n                `Unsupported key type. The key must be a single private key string, KlaytnWalletKey string, or Keyring instance.`\r\n            )\r\n\r\n        // When user attempt to sign with a updated keyring into an ethereum tx type error should be thrown.\r\n        if (isEthereumTxType(this.type) && keyring.isDecoupled()) throw new Error(`${this.type} cannot be signed with a decoupled keyring.`)\r\n\r\n        if (!this.from || this.from === '0x' || this.from === '0x0000000000000000000000000000000000000000') this.from = keyring.address\r\n        if (this.from.toLowerCase() !== keyring.address.toLowerCase())\r\n            throw new Error(`The from address of the transaction is different with the address of the keyring to use.`)\r\n\r\n        await this.fillTransaction()\r\n        const hash = hasher(this)\r\n        const role = this.type.includes('AccountUpdate') ? KEY_ROLE.roleAccountUpdateKey : KEY_ROLE.roleTransactionKey\r\n\r\n        return { keyring, hash, role }\r\n    }\r\n}\r\n\r\nmodule.exports = AbstractTransaction\r\n"],"mappings":";;;;;;;;+CACA,oJ;;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAMA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAjB;;AACA,IAAMC,KAAK,GAAGD,OAAO,CAAC,mBAAD,CAArB;;AACA,IAAME,GAAG,GAAGF,OAAO,CAAC,iBAAD,CAAnB;;AACA,IAAMG,IAAI,GAAGH,OAAO,CAAC,kBAAD,CAApB;;AACA,IAAMI,iBAAiB,GAAGJ,OAAO,CAAC,wCAAD,CAAjC;;AACA,IAAMK,KAAK,GAAGL,OAAO,CAAC,sBAAD,CAArB;;AACA,IAAMM,OAAO,GAAGN,OAAO,CAAC,kDAAD,CAAvB;;AACA,IAAMO,aAAa,GAAGP,OAAO,CAAC,iDAAD,CAA7B;;AACA,IAAMQ,eAAe,GAAGR,OAAO,CAAC,mDAAD,CAA/B;;AACA,IAAMS,gBAAgB,GAAGT,OAAO,CAAC,oDAAD,CAAhC;;AACA,eAKIA,OAAO,CAAC,wCAAD,CALX;AAAA,IACIU,cADJ,YACIA,cADJ;AAAA,IAEIC,gBAFJ,YAEIA,gBAFJ;AAAA,IAGIC,4BAHJ,YAGIA,4BAHJ;AAAA,IAIIC,gBAJJ,YAIIA,gBAJJ;;AAMA,gBAAqBb,OAAO,CAAC,iDAAD,CAA5B;AAAA,IAAQc,QAAR,aAAQA,QAAR;;AACA,gBAA2Bd,OAAO,CAAC,kDAAD,CAAlC;AAAA,IAAQe,cAAR,aAAQA,cAAR;;AACA,IAAMC,aAAa,GAAGhB,OAAO,CAAC,iDAAD,CAA7B;AAEA;AACA;AACA;AACA;AACA;AACA;;;IACMiB,mB;;;EACF;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,6BAAYC,UAAZ,EAAwBC,WAAxB,EAAmF;IAAA,IAA9CC,UAA8C,uEAAjCH,mBAAmB,CAACI,WAAa;;IAAA;;IAC/E,KAAKC,KAAL,GAAaJ,UAAb;IAEAC,WAAW,CAACI,IAAZ,GAAmBL,UAAnB;IAEA,IAAMM,GAAG,GAAGT,cAAc,CAACI,WAAD,CAA1B;IACA,IAAIK,GAAJ,EAAS,MAAMA,GAAN;IAET,KAAKC,IAAL,GAAYN,WAAW,CAACM,IAAxB;IAEA,KAAKC,GAAL,GAAWP,WAAW,CAACO,GAAvB,CAV+E,CAY/E;;IACA,IAAIP,WAAW,CAACQ,KAAZ,KAAsBC,SAA1B,EAAqC,KAAKD,KAAL,GAAaR,WAAW,CAACQ,KAAzB;IACrC,IAAIR,WAAW,CAACU,OAAZ,KAAwBD,SAA5B,EAAuC,KAAKC,OAAL,GAAeV,WAAW,CAACU,OAA3B;IAEvC,KAAKC,UAAL,GAAkBX,WAAW,CAACW,UAAZ,IAA0B,EAA5C;IACA,KAAKV,UAAL,GAAkBA,UAAlB;EACH;EAED;AACJ;AACA;;;;;SACI,eAAW;MACP,OAAO,KAAKE,KAAZ;IACH;IAED;AACJ;AACA;;;;SACI,eAAW;MACP,OAAO,KAAKS,KAAZ;IACH,C;SAED,aAASC,OAAT,EAAkB;MACd,IACI,KAAKT,IAAL,KAAcb,cAAc,CAACuB,uBAA7B,KACCD,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,4CADjC,CADJ,EAGE;QACE,KAAKD,KAAL,GAAaC,OAAO,CAACE,WAAR,EAAb;MACH,CALD,MAKO;QACH,IAAI,CAAC7B,KAAK,CAAC8B,SAAN,CAAgBH,OAAhB,CAAL,EAA+B,MAAM,IAAII,KAAJ,2BAA6BJ,OAA7B,EAAN;QAC/B,KAAKD,KAAL,GAAaC,OAAO,CAACE,WAAR,EAAb;MACH;IACJ;IAED;AACJ;AACA;;;;SACI,eAAY;MACR,OAAO,KAAKG,MAAZ;IACH,C;SAED,aAAUC,CAAV,EAAa;MACT,KAAKD,MAAL,GAAchC,KAAK,CAACkC,WAAN,CAAkBD,CAAlB,CAAd;IACH;IAED;AACJ;AACA;;;;SACI,eAAU;MACN,OAAO,KAAKE,IAAZ;IACH,C;SAED,aAAQC,CAAR,EAAW;MACP,KAAKD,IAAL,GAAYnC,KAAK,CAACkC,WAAN,CAAkBE,CAAlB,CAAZ;IACH;IAED;AACJ;AACA;;;;SACI,eAAc;MACV,OAAO,KAAKC,QAAZ;IACH,C;SAED,aAAYC,EAAZ,EAAgB;MACZ,KAAKD,QAAL,GAAgBrC,KAAK,CAACuC,KAAN,CAAYD,EAAZ,CAAhB;IACH;IAED;AACJ;AACA;;;;SACI,eAAiB;MACb,OAAO,KAAKE,WAAZ;IACH,C;SAED,aAAeC,IAAf,EAAqB;MACjB,KAAKD,WAAL,GAAmBlC,gBAAgB,CAACmC,IAAD,EAAO,KAAKvB,IAAZ,CAAnC;IACH;IAED;AACJ;AACA;;;;SACI,eAAiB;MACb,OAAO,KAAKF,WAAZ;IACH,C;SAED,aAAe0B,CAAf,EAAkB;MACd,KAAK1B,WAAL,GAAmB0B,CAAnB;IACH;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;;;mFACI;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OAC0B,KAAK3B,UAAL,CAAgB4B,UAAhB,EAD1B;;cAAA;gBACUnB,OADV;gBAAA,iCAEWA,OAFX;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAKA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;wFACI;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OAC6B,KAAKT,UAAL,CAAgB6B,WAAhB,EAD7B;;cAAA;gBACUC,UADV;gBAAA,kCAEWA,UAFX;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAKA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;oFACI;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OAC2B,KAAK9B,UAAL,CAAgB6B,WAAhB,EAD3B;;cAAA;gBACUE,QADV;gBAAA,kCAEWA,QAFX;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAKA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;;;iFACI,kBAAe1B,IAAf;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OACwB,KAAKL,UAAL,CAAgBgC,mBAAhB,CAAoC3B,IAApC,EAA0C,SAA1C,CADxB;;cAAA;gBACUE,KADV;gBAAA,kCAEWA,KAFX;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAKA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;mFACI;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OACyB,KAAKP,UAAL,CAAgBiC,iBAAhB,CAAkC,QAAlC,CADzB;;cAAA;gBACUC,MADV;gBAAA,kCAEWA,MAAM,CAACC,aAAP,IAAwB,KAFnC;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAKA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;;;gGACI;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OACuC,KAAKnC,UAAL,CAAgBoC,uBAAhB,EADvC;;cAAA;gBACUC,oBADV;gBAAA,kCAEWA,oBAFX;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAKA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,0BAAiB;MACb,MAAM,IAAIrB,KAAJ,oBAAN;IACH;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,4CAAmC;MAC/B,MAAM,IAAIA,KAAJ,oBAAN;IACH;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;8EACI,kBAAWsB,GAAX,EAAgBC,KAAhB;QAAA;QAAA;QAAA;QAAA;QAAA;QAAA;QAAA;;QAAA;UAAA;YAAA;cAAA;gBAAuBC,MAAvB,8DAAgCxD,iBAAiB,CAACyD,mBAAlD;;gBACI;gBACA;gBACA,IAAI9D,CAAC,CAAC+D,UAAF,CAAaH,KAAb,CAAJ,EAAyB;kBACrBC,MAAM,GAAGD,KAAT;kBACAA,KAAK,GAAG/B,SAAR;gBACH;;gBANL;gBAAA,OAQ0C,KAAKmC,KAAL,CAAWL,GAAX,EAAgBE,MAAhB,CAR1C;;cAAA;gBAAA;gBAQYI,OARZ,qBAQYA,OARZ;gBAQqBC,IARrB,qBAQqBA,IARrB;gBAQ2BC,IAR3B,qBAQ2BA,IAR3B;gBAUUC,GAVV,GAUgBH,OAAO,CAACI,IAAR,CAAaH,IAAb,EAAmB,KAAKpC,OAAxB,EAAiCqC,IAAjC,EAAuCP,KAAvC,CAVhB;gBAYI,KAAKU,gBAAL,CAAsBF,GAAtB;gBAZJ,kCAcW,IAdX;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAiBA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,0BAAiBrC,UAAjB,EAA6B;MACzB,IAAIqC,GAAG,GAAGrC,UAAV;MACA,IAAI/B,CAAC,CAACuE,QAAF,CAAWH,GAAX,CAAJ,EAAqBA,GAAG,GAAG9D,KAAK,CAACkE,gBAAN,CAAuBJ,GAAvB,CAAN;MACrB,IAAIA,GAAG,YAAYnD,aAAnB,EAAkCmD,GAAG,GAAG,CAACA,GAAD,CAAN;MAElC,IAAI,CAACpE,CAAC,CAACyE,OAAF,CAAUL,GAAV,CAAL,EAAqB,MAAM,IAAI/B,KAAJ,kEAAoE+B,GAApE,EAAN;MAErB,IAAIpE,CAAC,CAACuE,QAAF,CAAWH,GAAG,CAAC,CAAD,CAAd,CAAJ,EAAwBA,GAAG,GAAG,CAACA,GAAD,CAAN;MAExB,KAAKrC,UAAL,GAAkB,KAAKA,UAAL,CAAgB2C,MAAhB,CAAuBN,GAAvB,CAAlB;IACH;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,sCAA6BO,aAA7B,EAA4C;MACxC,IAAI,CAAC3E,CAAC,CAACyE,OAAF,CAAUE,aAAV,CAAL,EAA+B,MAAM,IAAItC,KAAJ,sEAAN,CADS,CAGxC;MACA;;MACA,IAAIuC,aAAa,GAAG,KAApB;MACA,IAAItE,KAAK,CAACuE,UAAN,CAAiB,KAAK9C,UAAtB,CAAJ,EAAuC6C,aAAa,GAAG,IAAhB;;MANC,2CAQlBD,aARkB;MAAA;;MAAA;QAQxC,oDAAqC;UAAA,IAA1BG,OAA0B;UACjC,IAAMtD,IAAI,GAAGX,4BAA4B,CAACiE,OAAD,CAAzC;UACA,IAAI,KAAKtD,IAAL,KAAcA,IAAlB,EAAwB,MAAM,IAAIa,KAAJ,yFAAN;UAExB,IAAM0C,OAAO,GAAG,KAAKC,WAAL,CAAiBC,MAAjB,CAAwBH,OAAxB,CAAhB,CAJiC,CAMjC;UACA;;UACA,KAAK,IAAMI,CAAX,IAAgBH,OAAhB,EAAyB;YACrB,IAAIG,CAAC,KAAK,aAAN,IAAuBA,CAAC,KAAK,aAA7B,IAA8CA,CAAC,KAAK,qBAAxD,EAA+E;YAC/E,IAAI,KAAKA,CAAL,MAAYrD,SAAZ,IAAyB+C,aAA7B,EAA4C,KAAKM,CAAL,IAAUH,OAAO,CAACG,CAAD,CAAjB;YAE5C,IAAMC,gBAAgB,sEAAtB,CAJqB,CAMrB;;YACA,IAAID,CAAC,KAAK,UAAV,EAAsB;cAClB,IAAI,KAAKA,CAAL,EAAQE,wBAAR,OAAuCL,OAAO,CAACG,CAAD,CAAP,CAAWE,wBAAX,EAA3C,EAAkF,MAAM,IAAI/C,KAAJ,CAAU8C,gBAAV,CAAN;cAClF;YACH;;YAED,IAAID,CAAC,KAAK,aAAV,EAAyB;cACrB,IAAI,CAAC,KAAKA,CAAL,EAAQG,OAAR,CAAgBN,OAAO,CAACG,CAAD,CAAvB,CAAL,EAAkC,MAAM,IAAI7C,KAAJ,CAAU8C,gBAAV,CAAN;cAClC;YACH;;YAED,IAAI,KAAKD,CAAL,MAAYH,OAAO,CAACG,CAAD,CAAvB,EAA4B;cACxB;cACA,MAAM,IAAI7C,KAAJ,CAAU8C,gBAAV,CAAN;YACH;UACJ;;UAED,KAAKb,gBAAL,CAAsBS,OAAO,CAAChD,UAA9B;QACH;MAxCuC;QAAA;MAAA;QAAA;MAAA;;MA0CxC,OAAO,KAAKuD,cAAL,EAAP;IACH;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,6BAAoB;MAChB,OAAO,KAAKA,cAAL,EAAP;IACH;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,8BAAqB;MACjB,OAAOlF,IAAI,CAACmF,SAAL,CAAe,KAAKD,cAAL,EAAf,CAAP;IACH;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,2BAAkB;MACd,OAAO,KAAKE,kBAAL,EAAP;IACH;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,sCAA6B;MACzB,KAAKC,sBAAL;MACA,IAAI,KAAK3D,OAAL,KAAiBD,SAArB,EACI,MAAM,IAAIQ,KAAJ,4GAAN;MAEJ,OAAOlC,GAAG,CAACuF,MAAJ,CAAW,CAAC,KAAKC,gCAAL,EAAD,EAA0CzF,KAAK,CAAC0F,OAAN,CAAc,KAAK9D,OAAnB,CAA1C,EAAuE,IAAvE,EAA6E,IAA7E,CAAX,CAAP;IACH;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,6BAAoB;MAChB,IAAIxB,KAAK,CAACuE,UAAN,CAAiB,KAAK9C,UAAtB,CAAJ,EAAuC,MAAM,IAAIM,KAAJ,uEAAN;MAEvC,IAAMwD,QAAQ,GAAG3F,KAAK,CAAC4F,QAAN,CAAe,KAAK/D,UAAL,CAAgB,CAAhB,EAAmBgE,CAAlC,CAAjB;MACA,IAAMjE,OAAO,GAAG+D,QAAQ,GAAG,EAAX,GAAgB3F,KAAK,CAAC0F,OAAN,CAAc,KAAd,CAAhB,GAAuC1F,KAAK,CAAC8F,UAAN,CAAkBH,QAAQ,GAAG,EAAZ,IAAmB,CAApC,CAAvD;MACA,IAAI,CAAC,KAAK/D,OAAV,EAAmB,KAAKA,OAAL,GAAeA,OAAf;MACnB,IAAMmE,cAAc,GAAG,KAAKC,0BAAL,EAAvB;MACA,IAAMC,gBAAgB,GAAG/F,IAAI,CAACmF,SAAL,CAAeU,cAAf,CAAzB;MAEA,IAAMG,UAAU,GAAG,EAAnB;;MATgB,4CAUE,KAAKrE,UAVP;MAAA;;MAAA;QAUhB,uDAAmC;UAAA,IAAxBqC,GAAwB;UAC/B,IAAMiC,IAAI,GAAGnG,KAAK,CAAC4F,QAAN,CAAe1B,GAAG,CAAC2B,CAAnB,CAAb;UACA,IAAMO,YAAY,GAAGD,IAAI,GAAG,EAAP,GAAYnG,KAAK,CAAC0F,OAAN,CAAc,KAAd,CAAZ,GAAmC1F,KAAK,CAAC8F,UAAN,CAAkBK,IAAI,GAAG,EAAR,IAAe,CAAhC,CAAxD;UAEA,IAAI/F,KAAK,CAACiG,eAAN,CAAsB,KAAKzE,OAA3B,MAAwCxB,KAAK,CAACiG,eAAN,CAAsBD,YAAtB,CAA5C,EACI,MAAM,IAAIjE,KAAJ,0DAAN;UAEJ+D,UAAU,CAACI,IAAX,CAAgBlG,KAAK,CAACmG,gBAAN,CAAuBN,gBAAvB,EAAyC/B,GAAzC,EAA8C,IAA9C,CAAhB;QACH;MAlBe;QAAA;MAAA;QAAA;MAAA;;MAoBhB,OAAOgC,UAAP;IACH;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;wFACI;QAAA;UAAA;YAAA;cAAA;gBAAA,MACU,IAAI/D,KAAJ,oBADV;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAIA;AACJ;AACA;AACA;AACA;AACA;;;;WACI,kCAAyB;MACrB,IAAI,KAAKT,KAAL,KAAeC,SAAnB,EACI,MAAM,IAAIQ,KAAJ,wGAAN;IACP;;;;8EAED,kBAAYsB,GAAZ,EAAiBE,MAAjB;QAAA;QAAA;UAAA;YAAA;cAAA;gBACQI,OADR,GACkBN,GADlB;;gBAEI,IAAI3D,CAAC,CAACuE,QAAF,CAAWZ,GAAX,CAAJ,EAAqB;kBACjBM,OAAO,GAAG1D,OAAO,CAACmG,oBAAR,CAA6B/C,GAA7B,CAAV;gBACH;;gBAJL,MAKQ,EAAEM,OAAO,YAAYzD,aAArB,KAAuC,EAAEyD,OAAO,YAAYxD,eAArB,CAAvC,IAAgF,EAAEwD,OAAO,YAAYvD,gBAArB,CALxF;kBAAA;kBAAA;gBAAA;;gBAAA,MAMc,IAAI2B,KAAJ,mHANd;;cAAA;gBAAA,MAWQvB,gBAAgB,CAAC,KAAKU,IAAN,CAAhB,IAA+ByC,OAAO,CAAC0C,WAAR,EAXvC;kBAAA;kBAAA;gBAAA;;gBAAA,MAWoE,IAAItE,KAAJ,WAAa,KAAKb,IAAlB,iDAXpE;;cAAA;gBAaI,IAAI,CAAC,KAAKE,IAAN,IAAc,KAAKA,IAAL,KAAc,IAA5B,IAAoC,KAAKA,IAAL,KAAc,4CAAtD,EAAoG,KAAKA,IAAL,GAAYuC,OAAO,CAAChC,OAApB;;gBAbxG,MAcQ,KAAKP,IAAL,CAAUS,WAAV,OAA4B8B,OAAO,CAAChC,OAAR,CAAgBE,WAAhB,EAdpC;kBAAA;kBAAA;gBAAA;;gBAAA,MAec,IAAIE,KAAJ,4FAfd;;cAAA;gBAAA;gBAAA,OAiBU,KAAKuE,eAAL,EAjBV;;cAAA;gBAkBU1C,IAlBV,GAkBiBL,MAAM,CAAC,IAAD,CAlBvB;gBAmBUM,IAnBV,GAmBiB,KAAK3C,IAAL,CAAUqF,QAAV,CAAmB,eAAnB,IAAsC9F,QAAQ,CAAC+F,oBAA/C,GAAsE/F,QAAQ,CAACgG,kBAnBhG;gBAAA,kCAqBW;kBAAE9C,OAAO,EAAPA,OAAF;kBAAWC,IAAI,EAAJA,IAAX;kBAAiBC,IAAI,EAAJA;gBAAjB,CArBX;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;;;;;;AAyBJ6C,MAAM,CAACC,OAAP,GAAiB/F,mBAAjB"},"metadata":{},"sourceType":"script"}