{"ast":null,"code":"/*\r\n    Copyright 2018 The caver-js Authors\r\n    This file is part of the caver-js library.\r\n\r\n    The caver-js library is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    The caver-js library is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\r\n*/\nconst _ = require('lodash');\n\nconst Method = require('../../caver-core-method');\n\nconst formatters = require('../../caver-core-helpers').formatters;\n\nconst payloadTransformer = require('../../caver-core-helpers').payloadTransformer; // For indexing\n\n\nconst rpcCallToMethodAsObject = {}; // Wrap rpc json through 'Method'\n\nconst rpcCallToMethod = require('../../../rpc.json').map(rpcCall => {\n  rpcCall.inputFormatter = rpcCall.inputFormatter && _.map(rpcCall.inputFormatter, formatterStr => formatters[formatterStr]);\n  rpcCall.outputFormatter = formatters[rpcCall.outputFormatter];\n  rpcCall.transformPayload = payloadTransformer[rpcCall.transformPayload];\n  const [callLabel, callName] = rpcCall.call.split('_');\n\n  if (callName) {\n    if (!rpcCallToMethodAsObject[callLabel]) {\n      rpcCallToMethodAsObject[callLabel] = {};\n    }\n\n    rpcCallToMethodAsObject[callLabel][rpcCall.name] = new Method(rpcCall);\n  }\n\n  if (!rpcCallToMethodAsObject[rpcCall.name]) {\n    return rpcCallToMethodAsObject[rpcCall.name] = new Method(rpcCall);\n  }\n}).filter(a => !!a);\n\nmodule.exports = rpcCallToMethod;\nmodule.exports.rpc = rpcCallToMethodAsObject;","map":{"version":3,"names":["_","require","Method","formatters","payloadTransformer","rpcCallToMethodAsObject","rpcCallToMethod","map","rpcCall","inputFormatter","formatterStr","outputFormatter","transformPayload","callLabel","callName","call","split","name","filter","a","module","exports","rpc"],"sources":["C:/Users/User/Documents/clone-starter-kit-08/node_modules/caver-js/packages/caver-rtm/src/index.js"],"sourcesContent":["/*\r\n    Copyright 2018 The caver-js Authors\r\n    This file is part of the caver-js library.\r\n\r\n    The caver-js library is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    The caver-js library is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst _ = require('lodash')\r\nconst Method = require('../../caver-core-method')\r\nconst formatters = require('../../caver-core-helpers').formatters\r\nconst payloadTransformer = require('../../caver-core-helpers').payloadTransformer\r\n\r\n// For indexing\r\nconst rpcCallToMethodAsObject = {}\r\n\r\n// Wrap rpc json through 'Method'\r\nconst rpcCallToMethod = require('../../../rpc.json')\r\n    .map(rpcCall => {\r\n        rpcCall.inputFormatter = rpcCall.inputFormatter && _.map(rpcCall.inputFormatter, formatterStr => formatters[formatterStr])\r\n        rpcCall.outputFormatter = formatters[rpcCall.outputFormatter]\r\n        rpcCall.transformPayload = payloadTransformer[rpcCall.transformPayload]\r\n\r\n        const [callLabel, callName] = rpcCall.call.split('_')\r\n\r\n        if (callName) {\r\n            if (!rpcCallToMethodAsObject[callLabel]) {\r\n                rpcCallToMethodAsObject[callLabel] = {}\r\n            }\r\n            rpcCallToMethodAsObject[callLabel][rpcCall.name] = new Method(rpcCall)\r\n        }\r\n\r\n        if (!rpcCallToMethodAsObject[rpcCall.name]) {\r\n            return (rpcCallToMethodAsObject[rpcCall.name] = new Method(rpcCall))\r\n        }\r\n    })\r\n    .filter(a => !!a)\r\n\r\nmodule.exports = rpcCallToMethod\r\nmodule.exports.rpc = rpcCallToMethodAsObject\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAjB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,yBAAD,CAAtB;;AACA,MAAME,UAAU,GAAGF,OAAO,CAAC,0BAAD,CAAP,CAAoCE,UAAvD;;AACA,MAAMC,kBAAkB,GAAGH,OAAO,CAAC,0BAAD,CAAP,CAAoCG,kBAA/D,C,CAEA;;;AACA,MAAMC,uBAAuB,GAAG,EAAhC,C,CAEA;;AACA,MAAMC,eAAe,GAAGL,OAAO,CAAC,mBAAD,CAAP,CACnBM,GADmB,CACfC,OAAO,IAAI;EACZA,OAAO,CAACC,cAAR,GAAyBD,OAAO,CAACC,cAAR,IAA0BT,CAAC,CAACO,GAAF,CAAMC,OAAO,CAACC,cAAd,EAA8BC,YAAY,IAAIP,UAAU,CAACO,YAAD,CAAxD,CAAnD;EACAF,OAAO,CAACG,eAAR,GAA0BR,UAAU,CAACK,OAAO,CAACG,eAAT,CAApC;EACAH,OAAO,CAACI,gBAAR,GAA2BR,kBAAkB,CAACI,OAAO,CAACI,gBAAT,CAA7C;EAEA,MAAM,CAACC,SAAD,EAAYC,QAAZ,IAAwBN,OAAO,CAACO,IAAR,CAAaC,KAAb,CAAmB,GAAnB,CAA9B;;EAEA,IAAIF,QAAJ,EAAc;IACV,IAAI,CAACT,uBAAuB,CAACQ,SAAD,CAA5B,EAAyC;MACrCR,uBAAuB,CAACQ,SAAD,CAAvB,GAAqC,EAArC;IACH;;IACDR,uBAAuB,CAACQ,SAAD,CAAvB,CAAmCL,OAAO,CAACS,IAA3C,IAAmD,IAAIf,MAAJ,CAAWM,OAAX,CAAnD;EACH;;EAED,IAAI,CAACH,uBAAuB,CAACG,OAAO,CAACS,IAAT,CAA5B,EAA4C;IACxC,OAAQZ,uBAAuB,CAACG,OAAO,CAACS,IAAT,CAAvB,GAAwC,IAAIf,MAAJ,CAAWM,OAAX,CAAhD;EACH;AACJ,CAlBmB,EAmBnBU,MAnBmB,CAmBZC,CAAC,IAAI,CAAC,CAACA,CAnBK,CAAxB;;AAqBAC,MAAM,CAACC,OAAP,GAAiBf,eAAjB;AACAc,MAAM,CAACC,OAAP,CAAeC,GAAf,GAAqBjB,uBAArB"},"metadata":{},"sourceType":"script"}