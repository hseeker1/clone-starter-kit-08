{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar mh = require('multihashes');\n\nvar multibase = require('multibase');\n\nvar multicodec = require('multicodec');\n\nvar CIDUtil = require('./cid-util');\n\nvar _require = require('uint8arrays/concat'),\n    uint8ArrayConcat = _require.concat;\n\nvar _require2 = require('uint8arrays/to-string'),\n    uint8ArrayToString = _require2.toString;\n\nvar _require3 = require('uint8arrays/equals'),\n    uint8ArrayEquals = _require3.equals;\n\nvar codecs = multicodec.nameToCode;\nvar codecInts =\n/** @type {CodecName[]} */\nObject.keys(codecs).reduce(function (p, name) {\n  p[codecs[name]] = name;\n  return p;\n},\n/** @type {Record<CodecCode, CodecName>} */\n{});\nvar symbol = Symbol.for('@ipld/js-cid/CID');\n/**\r\n * @typedef {Object} SerializedCID\r\n * @property {string} codec\r\n * @property {number} version\r\n * @property {Uint8Array} hash\r\n */\n\n/**\r\n * @typedef {0|1} CIDVersion\r\n * @typedef {import('multibase').BaseNameOrCode} BaseNameOrCode\r\n * @typedef {import('multicodec').CodecName} CodecName\r\n * @typedef {import('multicodec').CodecCode} CodecCode\r\n */\n\n/**\r\n * Class representing a CID `<mbase><version><mcodec><mhash>`\r\n * , as defined in [ipld/cid](https://github.com/multiformats/cid).\r\n *\r\n * @class CID\r\n */\n\nvar CID = /*#__PURE__*/function (_Symbol$for) {\n  /**\r\n   * Create a new CID.\r\n   *\r\n   * The algorithm for argument input is roughly:\r\n   * ```\r\n   * if (cid)\r\n   *   -> create a copy\r\n   * else if (str)\r\n   *   if (1st char is on multibase table) -> CID String\r\n   *   else -> bs58 encoded multihash\r\n   * else if (Uint8Array)\r\n   *   if (1st byte is 0 or 1) -> CID\r\n   *   else -> multihash\r\n   * else if (Number)\r\n   *   -> construct CID by parts\r\n   * ```\r\n   *\r\n   * @param {CIDVersion | string | Uint8Array | CID} version\r\n   * @param {string|number} [codec]\r\n   * @param {Uint8Array} [multihash]\r\n   * @param {string} [multibaseName]\r\n   *\r\n   * @example\r\n   * new CID(<version>, <codec>, <multihash>, <multibaseName>)\r\n   * new CID(<cidStr>)\r\n   * new CID(<cid.bytes>)\r\n   * new CID(<multihash>)\r\n   * new CID(<bs58 encoded multihash>)\r\n   * new CID(<cid>)\r\n   */\n  function CID(version, codec, multihash, multibaseName) {\n    _classCallCheck(this, CID);\n\n    // We have below three blank field accessors only because\n    // otherwise TS will not pick them up if done after assignemnts\n\n    /**\r\n     * The version of the CID.\r\n     *\r\n     * @type {CIDVersion}\r\n     */\n    // eslint-disable-next-line no-unused-expressions\n    this.version;\n    /**\r\n     * The codec of the CID.\r\n     *\r\n     * @deprecated\r\n     * @type {CodecName}\r\n     */\n    // eslint-disable-next-line no-unused-expressions\n\n    this.codec;\n    /**\r\n     * The multihash of the CID.\r\n     *\r\n     * @type {Uint8Array}\r\n     */\n    // eslint-disable-next-line no-unused-expressions\n\n    this.multihash;\n    Object.defineProperty(this, symbol, {\n      value: true\n    });\n\n    if (CID.isCID(version)) {\n      // version is an exising CID instance\n      var cid =\n      /** @type {CID} */\n      version;\n      this.version = cid.version;\n      this.codec = cid.codec;\n      this.multihash = cid.multihash; // Default guard for when a CID < 0.7 is passed with no multibaseName\n      // @ts-ignore\n\n      this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32');\n      return;\n    }\n\n    if (typeof version === 'string') {\n      // e.g. 'base32' or false\n      var baseName = multibase.isEncoded(version);\n\n      if (baseName) {\n        // version is a CID String encoded with multibase, so v1\n        var _cid = multibase.decode(version);\n\n        this.version =\n        /** @type {CIDVersion} */\n        parseInt(_cid[0].toString(), 16);\n        this.codec = multicodec.getCodec(_cid.slice(1));\n        this.multihash = multicodec.rmPrefix(_cid.slice(1));\n        this.multibaseName = baseName;\n      } else {\n        // version is a base58btc string multihash, so v0\n        this.version = 0;\n        this.codec = 'dag-pb';\n        this.multihash = mh.fromB58String(version);\n        this.multibaseName = 'base58btc';\n      }\n\n      CID.validateCID(this);\n      Object.defineProperty(this, 'string', {\n        value: version\n      });\n      return;\n    }\n\n    if (version instanceof Uint8Array) {\n      var v = parseInt(version[0].toString(), 16);\n\n      if (v === 1) {\n        // version is a CID Uint8Array\n        var _cid2 = version;\n        this.version = v;\n        this.codec = multicodec.getCodec(_cid2.slice(1));\n        this.multihash = multicodec.rmPrefix(_cid2.slice(1));\n        this.multibaseName = 'base32';\n      } else {\n        // version is a raw multihash Uint8Array, so v0\n        this.version = 0;\n        this.codec = 'dag-pb';\n        this.multihash = version;\n        this.multibaseName = 'base58btc';\n      }\n\n      CID.validateCID(this);\n      return;\n    } // otherwise, assemble the CID from the parameters\n\n\n    this.version = version;\n\n    if (typeof codec === 'number') {\n      // @ts-ignore\n      codec = codecInts[codec];\n    }\n\n    this.codec =\n    /** @type {CodecName} */\n    codec;\n    this.multihash =\n    /** @type {Uint8Array} */\n    multihash;\n    /**\r\n     * Multibase name as string.\r\n     *\r\n     * @deprecated\r\n     * @type {string}\r\n     */\n\n    this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32');\n    CID.validateCID(this);\n  }\n  /**\r\n   * The CID as a `Uint8Array`\r\n   *\r\n   * @returns {Uint8Array}\r\n   *\r\n   */\n\n\n  _createClass(CID, [{\n    key: \"bytes\",\n    get: function get() {\n      // @ts-ignore\n      var bytes = this._bytes;\n\n      if (!bytes) {\n        if (this.version === 0) {\n          bytes = this.multihash;\n        } else if (this.version === 1) {\n          var codec = multicodec.getCodeVarint(this.codec);\n          bytes = uint8ArrayConcat([[1], codec, this.multihash], 1 + codec.byteLength + this.multihash.byteLength);\n        } else {\n          throw new Error('unsupported version');\n        } // Cache this Uint8Array so it doesn't have to be recreated\n\n\n        Object.defineProperty(this, '_bytes', {\n          value: bytes\n        });\n      }\n\n      return bytes;\n    }\n    /**\r\n     * The prefix of the CID.\r\n     *\r\n     * @returns {Uint8Array}\r\n     */\n\n  }, {\n    key: \"prefix\",\n    get: function get() {\n      var codec = multicodec.getCodeVarint(this.codec);\n      var multihash = mh.prefix(this.multihash);\n      var prefix = uint8ArrayConcat([[this.version], codec, multihash], 1 + codec.byteLength + multihash.byteLength);\n      return prefix;\n    }\n    /**\r\n     * The codec of the CID in its number form.\r\n     *\r\n     * @returns {CodecCode}\r\n     */\n\n  }, {\n    key: \"code\",\n    get: function get() {\n      return codecs[this.codec];\n    }\n    /**\r\n     * Convert to a CID of version `0`.\r\n     *\r\n     * @returns {CID}\r\n     */\n\n  }, {\n    key: \"toV0\",\n    value: function toV0() {\n      if (this.codec !== 'dag-pb') {\n        throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n      }\n\n      var _mh$decode = mh.decode(this.multihash),\n          name = _mh$decode.name,\n          length = _mh$decode.length;\n\n      if (name !== 'sha2-256') {\n        throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n      }\n\n      if (length !== 32) {\n        throw new Error('Cannot convert non 32 byte multihash CID to CIDv0');\n      }\n\n      return new CID(0, this.codec, this.multihash);\n    }\n    /**\r\n     * Convert to a CID of version `1`.\r\n     *\r\n     * @returns {CID}\r\n     */\n\n  }, {\n    key: \"toV1\",\n    value: function toV1() {\n      return new CID(1, this.codec, this.multihash, this.multibaseName);\n    }\n    /**\r\n     * Encode the CID into a string.\r\n     *\r\n     * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: \"toBaseEncodedString\",\n    value: function toBaseEncodedString() {\n      var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.multibaseName;\n\n      // @ts-ignore non enumerable cache property\n      if (this.string && this.string.length !== 0 && base === this.multibaseName) {\n        // @ts-ignore non enumerable cache property\n        return this.string;\n      }\n\n      var str;\n\n      if (this.version === 0) {\n        if (base !== 'base58btc') {\n          throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()');\n        }\n\n        str = mh.toB58String(this.multihash);\n      } else if (this.version === 1) {\n        str = uint8ArrayToString(multibase.encode(base, this.bytes));\n      } else {\n        throw new Error('unsupported version');\n      }\n\n      if (base === this.multibaseName) {\n        // cache the string value\n        Object.defineProperty(this, 'string', {\n          value: str\n        });\n      }\n\n      return str;\n    }\n    /**\r\n     * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)\r\n     *\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: _Symbol$for,\n    value: function value() {\n      return 'CID(' + this.toString() + ')';\n    }\n    /**\r\n     * Encode the CID into a string.\r\n     *\r\n     * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString(base) {\n      return this.toBaseEncodedString(base);\n    }\n    /**\r\n     * Serialize to a plain object.\r\n     *\r\n     * @returns {SerializedCID}\r\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        codec: this.codec,\n        version: this.version,\n        hash: this.multihash\n      };\n    }\n    /**\r\n     * Compare equality with another CID.\r\n     *\r\n     * @param {CID} other\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.codec === other.codec && this.version === other.version && uint8ArrayEquals(this.multihash, other.multihash);\n    }\n    /**\r\n     * Test if the given input is a valid CID object.\r\n     * Throws if it is not.\r\n     *\r\n     * @param {any} other - The other CID.\r\n     * @returns {void}\r\n     */\n\n  }], [{\n    key: \"validateCID\",\n    value: function validateCID(other) {\n      var errorMsg = CIDUtil.checkCIDComponents(other);\n\n      if (errorMsg) {\n        throw new Error(errorMsg);\n      }\n    }\n    /**\r\n     * Check if object is a CID instance\r\n     *\r\n     * @param {any} value\r\n     * @returns {value is CID}\r\n     */\n\n  }, {\n    key: \"isCID\",\n    value: function isCID(value) {\n      return value instanceof CID || Boolean(value && value[symbol]);\n    }\n  }]);\n\n  return CID;\n}(Symbol.for('nodejs.util.inspect.custom'));\n\nCID.codecs = codecs;\nmodule.exports = CID;","map":{"version":3,"names":["mh","require","multibase","multicodec","CIDUtil","uint8ArrayConcat","concat","uint8ArrayToString","toString","uint8ArrayEquals","equals","codecs","nameToCode","codecInts","Object","keys","reduce","p","name","symbol","Symbol","for","CID","version","codec","multihash","multibaseName","defineProperty","value","isCID","cid","baseName","isEncoded","decode","parseInt","getCodec","slice","rmPrefix","fromB58String","validateCID","Uint8Array","v","bytes","_bytes","getCodeVarint","byteLength","Error","prefix","length","base","string","str","toB58String","encode","toBaseEncodedString","hash","other","errorMsg","checkCIDComponents","Boolean","module","exports"],"sources":["C:/Users/User/Documents/clone-starter-kit-08/node_modules/cids/src/index.js"],"sourcesContent":["'use strict'\r\n\r\nconst mh = require('multihashes')\r\nconst multibase = require('multibase')\r\nconst multicodec = require('multicodec')\r\nconst CIDUtil = require('./cid-util')\r\nconst { concat: uint8ArrayConcat } = require('uint8arrays/concat')\r\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\r\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\r\n\r\nconst codecs = multicodec.nameToCode\r\nconst codecInts = /** @type {CodecName[]} */(Object.keys(codecs)).reduce((p, name) => {\r\n  p[codecs[name]] = name\r\n  return p\r\n}, /** @type {Record<CodecCode, CodecName>} */({}))\r\n\r\nconst symbol = Symbol.for('@ipld/js-cid/CID')\r\n\r\n/**\r\n * @typedef {Object} SerializedCID\r\n * @property {string} codec\r\n * @property {number} version\r\n * @property {Uint8Array} hash\r\n */\r\n/**\r\n * @typedef {0|1} CIDVersion\r\n * @typedef {import('multibase').BaseNameOrCode} BaseNameOrCode\r\n * @typedef {import('multicodec').CodecName} CodecName\r\n * @typedef {import('multicodec').CodecCode} CodecCode\r\n */\r\n\r\n/**\r\n * Class representing a CID `<mbase><version><mcodec><mhash>`\r\n * , as defined in [ipld/cid](https://github.com/multiformats/cid).\r\n *\r\n * @class CID\r\n */\r\nclass CID {\r\n  /**\r\n   * Create a new CID.\r\n   *\r\n   * The algorithm for argument input is roughly:\r\n   * ```\r\n   * if (cid)\r\n   *   -> create a copy\r\n   * else if (str)\r\n   *   if (1st char is on multibase table) -> CID String\r\n   *   else -> bs58 encoded multihash\r\n   * else if (Uint8Array)\r\n   *   if (1st byte is 0 or 1) -> CID\r\n   *   else -> multihash\r\n   * else if (Number)\r\n   *   -> construct CID by parts\r\n   * ```\r\n   *\r\n   * @param {CIDVersion | string | Uint8Array | CID} version\r\n   * @param {string|number} [codec]\r\n   * @param {Uint8Array} [multihash]\r\n   * @param {string} [multibaseName]\r\n   *\r\n   * @example\r\n   * new CID(<version>, <codec>, <multihash>, <multibaseName>)\r\n   * new CID(<cidStr>)\r\n   * new CID(<cid.bytes>)\r\n   * new CID(<multihash>)\r\n   * new CID(<bs58 encoded multihash>)\r\n   * new CID(<cid>)\r\n   */\r\n  constructor (version, codec, multihash, multibaseName) {\r\n    // We have below three blank field accessors only because\r\n    // otherwise TS will not pick them up if done after assignemnts\r\n\r\n    /**\r\n     * The version of the CID.\r\n     *\r\n     * @type {CIDVersion}\r\n     */\r\n    // eslint-disable-next-line no-unused-expressions\r\n    this.version\r\n\r\n    /**\r\n     * The codec of the CID.\r\n     *\r\n     * @deprecated\r\n     * @type {CodecName}\r\n     */\r\n    // eslint-disable-next-line no-unused-expressions\r\n    this.codec\r\n\r\n    /**\r\n     * The multihash of the CID.\r\n     *\r\n     * @type {Uint8Array}\r\n     */\r\n    // eslint-disable-next-line no-unused-expressions\r\n    this.multihash\r\n\r\n    Object.defineProperty(this, symbol, { value: true })\r\n    if (CID.isCID(version)) {\r\n      // version is an exising CID instance\r\n      const cid = /** @type {CID} */(version)\r\n      this.version = cid.version\r\n      this.codec = cid.codec\r\n      this.multihash = cid.multihash\r\n      // Default guard for when a CID < 0.7 is passed with no multibaseName\r\n      // @ts-ignore\r\n      this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32')\r\n      return\r\n    }\r\n\r\n    if (typeof version === 'string') {\r\n      // e.g. 'base32' or false\r\n      const baseName = multibase.isEncoded(version)\r\n      if (baseName) {\r\n        // version is a CID String encoded with multibase, so v1\r\n        const cid = multibase.decode(version)\r\n        this.version = /** @type {CIDVersion} */(parseInt(cid[0].toString(), 16))\r\n        this.codec = multicodec.getCodec(cid.slice(1))\r\n        this.multihash = multicodec.rmPrefix(cid.slice(1))\r\n        this.multibaseName = baseName\r\n      } else {\r\n        // version is a base58btc string multihash, so v0\r\n        this.version = 0\r\n        this.codec = 'dag-pb'\r\n        this.multihash = mh.fromB58String(version)\r\n        this.multibaseName = 'base58btc'\r\n      }\r\n      CID.validateCID(this)\r\n      Object.defineProperty(this, 'string', { value: version })\r\n      return\r\n    }\r\n\r\n    if (version instanceof Uint8Array) {\r\n      const v = parseInt(version[0].toString(), 16)\r\n      if (v === 1) {\r\n        // version is a CID Uint8Array\r\n        const cid = version\r\n        this.version = v\r\n        this.codec = multicodec.getCodec(cid.slice(1))\r\n        this.multihash = multicodec.rmPrefix(cid.slice(1))\r\n        this.multibaseName = 'base32'\r\n      } else {\r\n        // version is a raw multihash Uint8Array, so v0\r\n        this.version = 0\r\n        this.codec = 'dag-pb'\r\n        this.multihash = version\r\n        this.multibaseName = 'base58btc'\r\n      }\r\n      CID.validateCID(this)\r\n      return\r\n    }\r\n\r\n    // otherwise, assemble the CID from the parameters\r\n\r\n    this.version = version\r\n\r\n    if (typeof codec === 'number') {\r\n      // @ts-ignore\r\n      codec = codecInts[codec]\r\n    }\r\n\r\n    this.codec = /** @type {CodecName} */ (codec)\r\n\r\n    this.multihash = /** @type {Uint8Array} */ (multihash)\r\n\r\n    /**\r\n     * Multibase name as string.\r\n     *\r\n     * @deprecated\r\n     * @type {string}\r\n     */\r\n    this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32')\r\n\r\n    CID.validateCID(this)\r\n  }\r\n\r\n  /**\r\n   * The CID as a `Uint8Array`\r\n   *\r\n   * @returns {Uint8Array}\r\n   *\r\n   */\r\n  get bytes () {\r\n    // @ts-ignore\r\n    let bytes = this._bytes\r\n\r\n    if (!bytes) {\r\n      if (this.version === 0) {\r\n        bytes = this.multihash\r\n      } else if (this.version === 1) {\r\n        const codec = multicodec.getCodeVarint(this.codec)\r\n        bytes = uint8ArrayConcat([\r\n          [1], codec, this.multihash\r\n        ], 1 + codec.byteLength + this.multihash.byteLength)\r\n      } else {\r\n        throw new Error('unsupported version')\r\n      }\r\n\r\n      // Cache this Uint8Array so it doesn't have to be recreated\r\n      Object.defineProperty(this, '_bytes', { value: bytes })\r\n    }\r\n\r\n    return bytes\r\n  }\r\n\r\n  /**\r\n   * The prefix of the CID.\r\n   *\r\n   * @returns {Uint8Array}\r\n   */\r\n  get prefix () {\r\n    const codec = multicodec.getCodeVarint(this.codec)\r\n    const multihash = mh.prefix(this.multihash)\r\n    const prefix = uint8ArrayConcat([\r\n      [this.version], codec, multihash\r\n    ], 1 + codec.byteLength + multihash.byteLength)\r\n\r\n    return prefix\r\n  }\r\n\r\n  /**\r\n   * The codec of the CID in its number form.\r\n   *\r\n   * @returns {CodecCode}\r\n   */\r\n  get code () {\r\n    return codecs[this.codec]\r\n  }\r\n\r\n  /**\r\n   * Convert to a CID of version `0`.\r\n   *\r\n   * @returns {CID}\r\n   */\r\n  toV0 () {\r\n    if (this.codec !== 'dag-pb') {\r\n      throw new Error('Cannot convert a non dag-pb CID to CIDv0')\r\n    }\r\n\r\n    const { name, length } = mh.decode(this.multihash)\r\n\r\n    if (name !== 'sha2-256') {\r\n      throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\r\n    }\r\n\r\n    if (length !== 32) {\r\n      throw new Error('Cannot convert non 32 byte multihash CID to CIDv0')\r\n    }\r\n\r\n    return new CID(0, this.codec, this.multihash)\r\n  }\r\n\r\n  /**\r\n   * Convert to a CID of version `1`.\r\n   *\r\n   * @returns {CID}\r\n   */\r\n  toV1 () {\r\n    return new CID(1, this.codec, this.multihash, this.multibaseName)\r\n  }\r\n\r\n  /**\r\n   * Encode the CID into a string.\r\n   *\r\n   * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.\r\n   * @returns {string}\r\n   */\r\n  toBaseEncodedString (base = this.multibaseName) {\r\n    // @ts-ignore non enumerable cache property\r\n    if (this.string && this.string.length !== 0 && base === this.multibaseName) {\r\n      // @ts-ignore non enumerable cache property\r\n      return this.string\r\n    }\r\n    let str\r\n    if (this.version === 0) {\r\n      if (base !== 'base58btc') {\r\n        throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()')\r\n      }\r\n      str = mh.toB58String(this.multihash)\r\n    } else if (this.version === 1) {\r\n      str = uint8ArrayToString(multibase.encode(base, this.bytes))\r\n    } else {\r\n      throw new Error('unsupported version')\r\n    }\r\n    if (base === this.multibaseName) {\r\n      // cache the string value\r\n      Object.defineProperty(this, 'string', { value: str })\r\n    }\r\n    return str\r\n  }\r\n\r\n  /**\r\n   * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)\r\n   *\r\n   * @returns {string}\r\n   */\r\n  [Symbol.for('nodejs.util.inspect.custom')] () {\r\n    return 'CID(' + this.toString() + ')'\r\n  }\r\n\r\n  /**\r\n   * Encode the CID into a string.\r\n   *\r\n   * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.\r\n   * @returns {string}\r\n   */\r\n  toString (base) {\r\n    return this.toBaseEncodedString(base)\r\n  }\r\n\r\n  /**\r\n   * Serialize to a plain object.\r\n   *\r\n   * @returns {SerializedCID}\r\n   */\r\n  toJSON () {\r\n    return {\r\n      codec: this.codec,\r\n      version: this.version,\r\n      hash: this.multihash\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Compare equality with another CID.\r\n   *\r\n   * @param {CID} other\r\n   * @returns {boolean}\r\n   */\r\n  equals (other) {\r\n    return this.codec === other.codec &&\r\n      this.version === other.version &&\r\n      uint8ArrayEquals(this.multihash, other.multihash)\r\n  }\r\n\r\n  /**\r\n   * Test if the given input is a valid CID object.\r\n   * Throws if it is not.\r\n   *\r\n   * @param {any} other - The other CID.\r\n   * @returns {void}\r\n   */\r\n  static validateCID (other) {\r\n    const errorMsg = CIDUtil.checkCIDComponents(other)\r\n    if (errorMsg) {\r\n      throw new Error(errorMsg)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if object is a CID instance\r\n   *\r\n   * @param {any} value\r\n   * @returns {value is CID}\r\n   */\r\n  static isCID (value) {\r\n    return value instanceof CID || Boolean(value && value[symbol])\r\n  }\r\n}\r\n\r\nCID.codecs = codecs\r\n\r\nmodule.exports = CID\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}