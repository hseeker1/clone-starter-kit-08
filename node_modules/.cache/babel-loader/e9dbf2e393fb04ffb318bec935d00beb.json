{"ast":null,"code":"/*\r\n    Modifications copyright 2018 The caver-js Authors\r\n    This file is part of web3.js.\r\n\r\n    web3.js is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    web3.js is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n    This file is derived from web3.js/packages/web3-eth-abi/src/index.js (2019/06/12).\r\n    Modified and improved for the caver-js development.\r\n*/\n\n/**\r\n * @file index.js\r\n * @author Marek Kotewicz <marek@parity.io>\r\n * @author Fabian Vogelsteller <fabian@frozeman.de>\r\n * @date 2017\r\n */\nconst _ = require('lodash');\n\nconst EthersAbiCoder = require('@ethersproject/abi').AbiCoder;\n\nconst ParamType = require('@ethersproject/abi').ParamType;\n\nconst utils = require('../../caver-utils');\n\nconst ethersAbiCoder = new EthersAbiCoder(function (type, value) {\n  if (type.match(/^u?int/) && !_.isArray(value) && (!_.isObject(value) || value.constructor.name !== 'BN')) {\n    return value.toString();\n  }\n\n  return value;\n}); // result method\n\nfunction Result() {}\n\nclass ABI {\n  /**\r\n   * Encodes the function signature to its ABI signature, which are the first 4 bytes of the sha3 hash of the function name including parameter types.\r\n   *\r\n   * @example\r\n   * caver.abi.encodeFunctionSignature({ name: 'myMethod', type: 'function', inputs: [{ type: 'uint256', name: 'myNumber' },{ type: 'string', name: 'mystring' }]})\r\n   *\r\n   * caver.abi.encodeFunctionSignature('myMethod(uint256,string)')\r\n   *\r\n   * @method encodeFunctionSignature\r\n   * @memberof ABI\r\n   * @instance\r\n   * @param {string|object} functionSignature The function signature or the JSON interface object of the function to encode. If this is a string, it has to be in the form `function(type, type,...)`, e.g: `myFunction(uint256,uint32[],bytes10,bytes)`.\r\n   * @return {string} function signature\r\n   */\n  encodeFunctionSignature(functionSignature) {\n    if (_.isObject(functionSignature)) {\n      functionSignature = utils._jsonInterfaceMethodToString(functionSignature);\n    }\n\n    return utils.sha3(functionSignature).slice(0, 10);\n  }\n  /**\r\n   * Encodes the event signature to its ABI signature, which is the sha3 hash of the event name including input parameter types.\r\n   *\r\n   * @example\r\n   * caver.abi.encodeEventSignature({ name: 'myEvent', type: 'event', inputs: [{ type: 'uint256', name: 'myNumber' },{ type: 'string', name: 'mystring' }]})\r\n   *\r\n   * caver.abi.encodeEventSignature('myEvent(uint256,bytes32)')\r\n   *\r\n   * @method encodeEventSignature\r\n   * @memberof ABI\r\n   * @instance\r\n   * @param {string|object} eventSignature The event signature or the JSON interface object of the event to encode. If this is a string, it has to be in the form `event(type,type,...)`, e.g: `myEvent(uint256,uint32[],bytes10,bytes)`.\r\n   * @return {string} event signature\r\n   */\n\n\n  encodeEventSignature(eventSignature) {\n    if (_.isObject(eventSignature)) {\n      eventSignature = utils._jsonInterfaceMethodToString(eventSignature);\n    }\n\n    return utils.sha3(eventSignature);\n  }\n  /**\r\n   * Encodes a parameter based on its type to its ABI representation.\r\n   *\r\n   * @example\r\n   * caver.abi.encodeParameter('uint256', '2345675643')\r\n   * caver.abi.encodeParameter('bytes32[]', [caver.utils.rightPad('0xdf3234', 64), caver.utils.rightPad('0xfdfd', 64)])\r\n   * caver.abi.encodeParameter('tuple(bytes32,bool)', ['0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a18', true])\r\n   *\r\n   * @method encodeParameter\r\n   * @memberof ABI\r\n   * @instance\r\n   * @param {string|object} type The type of the parameter, see the {@link http://solidity.readthedocs.io/en/develop/types.html|solidity documentation}  for a list of types.\r\n   * @param {*} param The actual parameter to encode.\r\n   * @return {string} encoded plain param\r\n   */\n\n\n  encodeParameter(type, param) {\n    return this.encodeParameters([type], [param]);\n  }\n  /**\r\n   * Encodes function parameters based on its JSON interface object.\r\n   *\r\n   * @example\r\n   * caver.abi.encodeParameters(['uint256','string'], ['2345675643', 'Hello!%'])\r\n   *\r\n   * caver.abi.encodeParameters(\r\n   *      ['tuple(bytes32,bool)', 'tuple(bool,address)'],\r\n   *      [['0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a18', true], [true, '0x77656c636f6d6520746f20657468657265756d2e']]\r\n   * )\r\n   *\r\n   * caver.abi.encodeParameters(\r\n   *   [\r\n   *       {\r\n   *           components: [{ name: 'a', type: 'bytes32' }, { name: 'b', type: 'bool' }],\r\n   *           name: 'tupleExample',\r\n   *           type: 'tuple',\r\n   *       },\r\n   *       {\r\n   *           components: [{ name: 'c', type: 'bool' }, { name: 'd', type: 'address' }],\r\n   *           name: 'tupleExample2',\r\n   *          type: 'tuple',\r\n   *      },\r\n   *  ],\r\n   *  [\r\n   *      ['0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a18', true],\r\n   *      [true, '0x77656c636f6d6520746f20657468657265756d2e']\r\n   *  ]\r\n   *)\r\n   *\r\n   * @method encodeParameters\r\n   * @memberof ABI\r\n   * @instance\r\n   * @param {Array.<string|object>} types An array with types or a JSON interface of a function. See the {@link http://solidity.readthedocs.io/en/develop/types.html|solidity documentation} for a list of types.\r\n   * @param {Array.<*>} params The parameters to encode.\r\n   * @return {string} encoded list of params\r\n   */\n\n\n  encodeParameters(types, params) {\n    const self = this;\n    types = self.mapTypes(types);\n    params = params.map(function (param, index) {\n      let type = types[index]; // { components: [[Object], [Object]], name: 'b', type: 'tuple' }\n\n      if (typeof type === 'object' && type.type) {\n        // We may get a named type of shape {name, type}\n        type = type.type;\n      }\n\n      param = self.formatParam(type, param); // If the type is string but number comes in, ethersAbiCoder ignores the type and encodes successfully.\n      // To avoid invalid encoding value, adding error handling.\n\n      if (type === 'string' && typeof param !== 'string') throw new Error(`Invalid parameter: Parameter value and type do not match.`); // Format params for tuples\n\n      if (typeof type === 'string' && type.includes('tuple')) {\n        const coder = ethersAbiCoder._getCoder(ParamType.from(type)); // eslint-disable-next-line no-shadow\n\n\n        const modifyParams = (coder, param) => {\n          if (coder.name === 'array') {\n            return param.map(p => {\n              // `coder.type.replace('[]','')` can handle'tuple(string,string)[]', but cannot handle `tuple(string,string)[3]'.\n              // Therefore, in order to handle tuple arrays of fixed length, the logic is changed to handle strings using regular expression expressions.\n              const replacedType = coder.type.replace(/\\[[1-9]*\\]/g, '');\n              const parameterType = ParamType.from(replacedType);\n\n              const gotCoder = ethersAbiCoder._getCoder(parameterType);\n\n              modifyParams(gotCoder, p);\n            });\n          }\n\n          coder.coders.forEach((c, i) => {\n            if (c.name === 'tuple') {\n              modifyParams(c, param[i]);\n            } else {\n              param[i] = self.formatParam(c.name, param[i]);\n            }\n          });\n        };\n\n        modifyParams(coder, param);\n      }\n\n      return param;\n    });\n    return ethersAbiCoder.encode(types, params);\n  }\n  /**\r\n   * Should be used to encode smart contract deployment with constructor arguments.\r\n   *\r\n   * @example\r\n   * // There is no argument for constructor\r\n   * caver.abi.encodeContractDeploy([\r\n   *     { \"constant\": true, \"inputs\": [], \"name\": \"count\", \"outputs\": [ { \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" },\r\n   *     { \"constant\": true, \"inputs\": [], \"name\": \"getBlockNumber\", \"outputs\": [ { \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" },\r\n   *     { \"constant\": false, \"inputs\": [ { \"name\": \"_count\", \"type\": \"uint256\" } ], \"name\": \"setCount\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" }\r\n   * ],'0x{byte code}')\r\n   *\r\n   * // There is one argument for constructor\r\n   * caver.abi.encodeContractDeploy([\r\n   *     { \"constant\": true, \"inputs\": [], \"name\": \"count\", \"outputs\": [ { \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" },\r\n   *     { \"constant\": true, \"inputs\": [], \"name\": \"getBlockNumber\", \"outputs\": [ { \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" },\r\n   *     { \"constant\": false, \"inputs\": [ { \"name\": \"_count\", \"type\": \"uint256\" } ], \"name\": \"setCount\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" },\r\n   *     { \"inputs\": [ { \"name\": \"_a\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"constructor\" }\r\n   * ],'0x{byte code}', 1)\r\n   *\r\n   * @method encodeContractDeploy\r\n   * @memberof ABI\r\n   * @instance\r\n   * @param {Array.<object>} jsonInterface The JSON interface of the contract.\r\n   * @param {string} bytecode A bytecode of smart contract to be deployed.\r\n   * @param {...*} [args] Arguments to pass to the constructor.\r\n   * @return {string} bytecode + args\r\n   */\n\n\n  encodeContractDeploy(jsonInterface, bytecode) {\n    if (!jsonInterface) {\n      throw new Error('jsonInterface should be provided for encoding contract deployment.');\n    }\n\n    if (!bytecode) {\n      throw new Error('bytecode should be provided for encoding contract deployment.');\n    }\n\n    const constructorInterface = jsonInterface.filter(_ref => {\n      let {\n        type\n      } = _ref;\n      return type === 'constructor';\n    })[0];\n    const constructorInputs = constructorInterface && constructorInterface.inputs; // If constructor doesn't exist in smart contract, only bytecode is needed for deploying.\n\n    if (!constructorInterface || !constructorInputs || _.isEmpty(constructorInputs)) {\n      return bytecode;\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    if (constructorInputs.length !== args.length) {\n      throw new Error(`invalid number of parameters for deploying. Got ${args.length} expected ${constructorInputs.length}!`);\n    }\n\n    const constructorTypes = constructorInputs.map(_ref2 => {\n      let {\n        type\n      } = _ref2;\n      return type;\n    });\n    return bytecode + this.encodeParameters(constructorTypes, args).replace('0x', '');\n  }\n  /**\r\n   * Map types if simplified format is used\r\n   *\r\n   * @method mapTypes\r\n   * @memberof ABI\r\n   * @ignore\r\n   * @instance\r\n   * @param {Array} types\r\n   * @return {Array}\r\n   */\n\n\n  mapTypes(types) {\n    const self = this;\n    const mappedTypes = [];\n    types.forEach(function (type) {\n      // Remap `function` type params to bytes24 since Ethers does not\n      // recognize former type. Solidity docs say `Function` is a bytes24\n      // encoding the contract address followed by the function selector hash.\n      if (typeof type === 'object' && type.type === 'function') {\n        type = { ...type,\n          type: 'bytes24'\n        };\n      }\n\n      if (self.isSimplifiedStructFormat(type)) {\n        const structName = Object.keys(type)[0];\n        mappedTypes.push(Object.assign(self.mapStructNameAndType(structName), {\n          components: self.mapStructToCoderFormat(type[structName])\n        }));\n        return;\n      }\n\n      mappedTypes.push(type);\n    });\n    return mappedTypes;\n  }\n  /**\r\n   * Check if type is simplified struct format\r\n   *\r\n   * @method isSimplifiedStructFormat\r\n   * @memberof ABI\r\n   * @ignore\r\n   * @instance\r\n   * @param {string|Object} type\r\n   * @returns {boolean}\r\n   */\n\n\n  isSimplifiedStructFormat(type) {\n    return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n  }\n  /**\r\n   * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\r\n   *\r\n   * @method mapStructNameAndType\r\n   * @memberof ABI\r\n   * @ignore\r\n   * @instance\r\n   * @param {string} structName\r\n   * @return {{type: string, name: *}}\r\n   */\n\n\n  mapStructNameAndType(structName) {\n    let type = 'tuple';\n\n    if (structName.indexOf('[]') > -1) {\n      type = 'tuple[]';\n      structName = structName.slice(0, -2);\n    }\n\n    return {\n      type: type,\n      name: structName\n    };\n  }\n  /**\r\n   * Maps the simplified format in to the expected format of the ABI\r\n   *\r\n   * @method mapStructToCoderFormat\r\n   * @memberof ABI\r\n   * @ignore\r\n   * @instance\r\n   * @param {object} struct\r\n   * @return {Array}\r\n   */\n\n\n  mapStructToCoderFormat(struct) {\n    const self = this;\n    const components = [];\n    Object.keys(struct).forEach(function (key) {\n      if (typeof struct[key] === 'object') {\n        components.push(Object.assign(self.mapStructNameAndType(key), {\n          components: self.mapStructToCoderFormat(struct[key])\n        }));\n        return;\n      }\n\n      components.push({\n        name: key,\n        type: struct[key]\n      });\n    });\n    return components;\n  }\n  /**\r\n   * Handle some formatting of params for backwards compatability with Ethers V4\r\n   *\r\n   * @method formatParam\r\n   * @memberof ABI\r\n   * @ignore\r\n   * @param {string} - type\r\n   * @param {any} - param\r\n   * @return {string|Array.<string>} - The formatted param\r\n   */\n\n\n  formatParam(type, param) {\n    const paramTypeBytes = /^bytes([0-9]*)$/;\n    const paramTypeBytesArray = /^bytes([0-9]*)\\[\\]$/;\n    const paramTypeNumber = /^(u?int)([0-9]*)$/;\n    const paramTypeNumberArray = /^(u?int)([0-9]*)\\[\\]$/; // Format BN to string\n\n    if (utils.isBN(param) || utils.isBigNumber(param)) {\n      return param.toString(10);\n    }\n\n    if (type.match(paramTypeBytesArray) || type.match(paramTypeNumberArray)) {\n      return param.map(p => this.formatParam(type.replace('[]', ''), p));\n    } // Format correct width for u?int[0-9]*\n\n\n    let match = type.match(paramTypeNumber);\n\n    if (match) {\n      const size = parseInt(match[2] || '256');\n\n      if (size / 8 < param.length) {\n        // pad to correct bit width\n        param = utils.leftPad(param, size);\n      }\n    } // Format correct length for bytes[0-9]+\n\n\n    match = type.match(paramTypeBytes);\n\n    if (match) {\n      if (Buffer.isBuffer(param)) {\n        param = utils.toHex(param);\n      } // format to correct length\n\n\n      const size = parseInt(match[1]);\n\n      if (size) {\n        let maxSize = size * 2;\n\n        if (param.substring(0, 2) === '0x') {\n          maxSize += 2;\n        }\n\n        if (param.length < maxSize) {\n          // pad to correct length\n          param = utils.rightPad(param, size * 2);\n        }\n      } // format odd-length bytes to even-length\n\n\n      if (param.length % 2 === 1) {\n        param = `0x0${param.substring(2)}`;\n      }\n    }\n\n    return param;\n  }\n  /**\r\n   * Encodes a function call from its json interface and parameters.\r\n   *\r\n   * @example\r\n   * caver.abi.encodeFunctionCall({\r\n   *     name: 'myMethod',\r\n   *     type: 'function',\r\n   *     inputs: [{\r\n   *         type: 'uint256',\r\n   *         name: 'myNumber'\r\n   * },{\r\n   *         type: 'string',\r\n   *         name: 'mystring'\r\n   *     }]\r\n   * }, ['2345675643', 'Hello!%'])\r\n   *\r\n   * @method encodeFunctionCall\r\n   * @memberof ABI\r\n   * @instance\r\n   * @param {object} jsonInterface The JSON interface object of a function.\r\n   * @param {Array.<*>} [params] The parameters to encode.\r\n   * @return {string} The encoded ABI for this function call\r\n   */\n\n\n  encodeFunctionCall(jsonInterface, params) {\n    params = params || [];\n    return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');\n  }\n  /**\r\n   * Decodes a function call from its abi object of a function and returns parameters.\r\n   * If the function signature of the `abi` passed as a parameter does not match the function signature of the `functionCall`, an error is returned.\r\n   *\r\n   * @example\r\n   * const abi = {\r\n   *    name: 'myMethod',\r\n   *    type: 'function',\r\n   *    inputs: [\r\n   *        {\r\n   *            type: 'uint256',\r\n   *           name: 'myNumber',\r\n   *       },\r\n   *       {\r\n   *           type: 'string',\r\n   *           name: 'mystring',\r\n   *       },\r\n   *   ],\r\n   * }\r\n   * const functionCall = '0x24ef0...'\r\n   * caver.abi.decodeFunctionCall(abi, functionCall)\r\n   *\r\n   * @method decodeFunctionCall\r\n   * @memberof ABI\r\n   * @instance\r\n   * @param {object} abi The abi object of a function.\r\n   * @param {string} functionCall The encoded function call string.\r\n   * @return {object} An object which includes plain params. You can use `result[0]` as it is provided to be accessed like an array in the order of the parameters.\r\n   */\n\n\n  decodeFunctionCall(abi, functionCall) {\n    functionCall = utils.addHexPrefix(functionCall);\n    if (!_.isObject(abi) || _.isArray(abi)) throw new Error(`Invalid abi parameter type: To decode function call, you need to pass an abi object of the function as a first parameter.`);\n    if (!abi.name || !abi.inputs) throw new Error(`Insufficient info in abi object: The function name and inputs must be defined inside the abi function object.`);\n    const funcSig = this.encodeFunctionSignature(abi);\n    const extractFuncSig = functionCall.slice(0, funcSig.length);\n    if (funcSig !== extractFuncSig) throw new Error(`Invalid function signature: The function signature of the abi as a parameter and the function signatures extracted from the function call string do not match.`);\n    return this.decodeParameters(abi.inputs, `0x${functionCall.slice(funcSig.length)}`);\n  }\n  /**\r\n   * Decodes an ABI encoded parameter to its JavaScript type.\r\n   *\r\n   * @example\r\n   * caver.abi.decodeParameter('uint256', '0x0000000000000000000000000000000000000000000000000000000000000010')\r\n   *\r\n   * caver.abi.decodeParameter('string', '0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000848656c6c6f212521000000000000000000000000000000000000000000000000')\r\n   *\r\n   * caver.abi.decodeParameter('tuple(bytes32,bool)', '0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a180000000000000000000000000000000000000000000000000000000000000001')\r\n   *\r\n   * caver.abi.decodeParameter(\r\n   *     {\r\n   *         components: [{ name: 'a', type: 'bytes32' }, { name: 'b', type: 'bool' }],\r\n   *         name: 'tupleExample',\r\n   *         type: 'tuple',\r\n   *     }, '0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a180000000000000000000000000000000000000000000000000000000000000001'\r\n   * )\r\n   *\r\n   * @method decodeParameter\r\n   * @memberof ABI\r\n   * @instance\r\n   * @param {string|object} type The type of the parameter, see the {@link http://solidity.readthedocs.io/en/develop/types.html|solidity documentation} for a list of types.\r\n   * @param {string} encodedString The ABI byte code to decode.\r\n   * @return {string} plain param\r\n   */\n\n\n  decodeParameter(type, encodedString) {\n    return this.decodeParameters([type], encodedString)[0];\n  }\n  /**\r\n   * Decodes ABI encoded parameters to its JavaScript types.\r\n   *\r\n   * @example\r\n   * caver.abi.decodeParameters(['string', 'uint256'], '0x000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000ea000000000000000000000000000000000000000000000000000000000000000848656c6c6f212521000000000000000000000000000000000000000000000000')\r\n   *\r\n   * caver.abi.decodeParameters(\r\n   *  ['tuple(bytes32,bool)', 'tuple(bool,address)'],\r\n   *  '0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a180000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000077656c636f6d6520746f20657468657265756d2e'\r\n   * )\r\n   *\r\n   * caver.abi.decodeParameters([{\r\n   *     type: 'string',\r\n   *     name: 'mystring'\r\n   * },{\r\n   *     type: 'uint256',\r\n   *     name: 'myNumber'\r\n   * }], '0x000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000ea000000000000000000000000000000000000000000000000000000000000000848656c6c6f212521000000000000000000000000000000000000000000000000')\r\n   *\r\n   * caver.abi.decodeParameters(\r\n   *     [\r\n   *         {\r\n   *             components: [{ name: 'a', type: 'bytes32' }, { name: 'b', type: 'bool' }],\r\n   *             name: 'tupleExample',\r\n   *             type: 'tuple',\r\n   *         },\r\n   *         {\r\n   *             components: [{ name: 'c', type: 'bool' }, { name: 'd', type: 'address' }],\r\n   *             name: 'tupleExample2',\r\n   *             type: 'tuple',\r\n   *         },\r\n   *     ],\r\n   *     '0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a180000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000077656c636f6d6520746f20657468657265756d2e'\r\n   * )\r\n   *\r\n   * @method decodeParameters\r\n   * @memberof ABI\r\n   * @instance\r\n   * @param {Array.<string|object>} typesArray An array with types or an array of JSON interface outputs. See the {@link http://solidity.readthedocs.io/en/develop/types.html|solidity documentation} for a list of types.\r\n   * @param {string} encodedString The ABI byte code to decode.\r\n   * @return {object} An object which includes plain params. You can use `result[0]` as it is provided to be accessed like an array in the order of the parameters.\r\n   */\n\n\n  decodeParameters(outputs, encodedString) {\n    return this.decodeParametersWith(outputs, encodedString, false);\n  }\n  /**\r\n   * Should be used to decode list of params\r\n   *\r\n   * @method decodeParametersWith\r\n   * @memberof ABI\r\n   * @instance\r\n   * @ignore\r\n   * @param {Array} outputs\r\n   * @param {string} bytes\r\n   * @param {Boolean} loose must be passed for decoding bytes and string parameters for logs emitted with solc 0.4.x\r\n   *                        Please refer to https://github.com/ChainSafe/web3.js/commit/e80337e16e5c04683fc40148378775234c28e0fb.\r\n   * @return {object} An object which includes plain params. You can use `result[0]` as it is provided to be accessed like an array in the order of the parameters.\r\n   */\n\n\n  decodeParametersWith(outputs, bytes, loose) {\n    if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\n      throw new Error(\"Returned values aren't valid, did it run Out of Gas? \" + 'You might also see this error if you are not using the ' + 'correct ABI for the contract you are retrieving data from, ' + 'requesting data from a block number that does not exist, ' + 'or querying a node which is not fully synced.');\n    }\n\n    const res = ethersAbiCoder.decode(this.mapTypes(outputs), `0x${bytes.replace(/0x/i, '')}`, loose);\n    const returnValue = new Result();\n    returnValue.__length__ = 0;\n    outputs.forEach(function (output, i) {\n      let decodedValue = res[returnValue.__length__];\n      decodedValue = decodedValue === '0x' ? null : decodedValue;\n      returnValue[i] = decodedValue;\n\n      if (_.isObject(output) && output.name) {\n        returnValue[output.name] = decodedValue;\n      }\n\n      returnValue.__length__++;\n    });\n    return returnValue;\n  }\n  /**\r\n   * Decodes ABI encoded log data and indexed topic data.\r\n   *\r\n   * @example\r\n   * caver.abi.decodeLog(\r\n   *     [\r\n   *         {\r\n   *             type: 'string',\r\n   *             name: 'mystring'\r\n   *         },{\r\n   *             type: 'uint256',\r\n   *             name: 'myNumber',\r\n   *             indexed: true\r\n   *         },{\r\n   *             type: 'uint8',\r\n   *             name: 'mySmallNumber',\r\n   *             indexed: true\r\n   *          }\r\n   *     ],\r\n   *     '0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000748656c6c6f252100000000000000000000000000000000000000000000000000',\r\n   *      ['0x000000000000000000000000000000000000000000000000000000000000f310', '0x0000000000000000000000000000000000000000000000000000000000000010']\r\n   * )\r\n   *\r\n   *\r\n   * @method decodeLog\r\n   * @memberof ABI\r\n   * @instance\r\n   * @param {Array.<object>} inputs An array of JSON interface inputs. See the solidity documentation for a list of types.\r\n   * @param {string} data The ABI byte code in the data field of a log.\r\n   * @param {*} topics An array of the index parameter topics of the log. This array doesn't have topic[0] if it is a non-anonymous event, or otherwise, it has topic[0].\r\n   * @return {object} An object which includes plain params. You can use `result[0]` as it is provided to be accessed like an array in the order of the parameters.\r\n   */\n\n\n  decodeLog(inputs, data, topics) {\n    const _this = this;\n\n    topics = _.isArray(topics) ? topics : [topics];\n    data = data || '';\n    const notIndexedInputs = [];\n    const indexedParams = [];\n    let topicCount = 0; // TODO check for anonymous logs?\n\n    inputs.forEach(function (input, i) {\n      if (input.indexed) {\n        indexedParams[i] = ['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function (staticType) {\n          return input.type.indexOf(staticType) !== -1;\n        }) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];\n        topicCount++;\n      } else {\n        notIndexedInputs[i] = input;\n      }\n    });\n    const nonIndexedData = data;\n    const notIndexedParams = nonIndexedData ? this.decodeParametersWith(notIndexedInputs, nonIndexedData, true) : [];\n    const returnValue = new Result();\n    returnValue.__length__ = 0;\n    inputs.forEach(function (res, i) {\n      returnValue[i] = res.type === 'string' ? '' : null;\n\n      if (typeof notIndexedParams[i] !== 'undefined') {\n        returnValue[i] = notIndexedParams[i];\n      }\n\n      if (typeof indexedParams[i] !== 'undefined') {\n        returnValue[i] = indexedParams[i];\n      }\n\n      if (res.name) {\n        returnValue[res.name] = returnValue[i];\n      }\n\n      returnValue.__length__++;\n    });\n    return returnValue;\n  }\n\n}\n/** @instance */\n\n\nconst abi = new ABI();\nmodule.exports = abi;","map":{"version":3,"names":["_","require","EthersAbiCoder","AbiCoder","ParamType","utils","ethersAbiCoder","type","value","match","isArray","isObject","constructor","name","toString","Result","ABI","encodeFunctionSignature","functionSignature","_jsonInterfaceMethodToString","sha3","slice","encodeEventSignature","eventSignature","encodeParameter","param","encodeParameters","types","params","self","mapTypes","map","index","formatParam","Error","includes","coder","_getCoder","from","modifyParams","p","replacedType","replace","parameterType","gotCoder","coders","forEach","c","i","encode","encodeContractDeploy","jsonInterface","bytecode","constructorInterface","filter","constructorInputs","inputs","isEmpty","args","length","constructorTypes","mappedTypes","isSimplifiedStructFormat","structName","Object","keys","push","assign","mapStructNameAndType","components","mapStructToCoderFormat","indexOf","struct","key","paramTypeBytes","paramTypeBytesArray","paramTypeNumber","paramTypeNumberArray","isBN","isBigNumber","size","parseInt","leftPad","Buffer","isBuffer","toHex","maxSize","substring","rightPad","encodeFunctionCall","decodeFunctionCall","abi","functionCall","addHexPrefix","funcSig","extractFuncSig","decodeParameters","decodeParameter","encodedString","outputs","decodeParametersWith","bytes","loose","res","decode","returnValue","__length__","output","decodedValue","decodeLog","data","topics","_this","notIndexedInputs","indexedParams","topicCount","input","indexed","find","staticType","nonIndexedData","notIndexedParams","module","exports"],"sources":["C:/Users/User/Documents/clone-starter-kit-08/node_modules/caver-js/packages/caver-abi/src/index.js"],"sourcesContent":["/*\r\n    Modifications copyright 2018 The caver-js Authors\r\n    This file is part of web3.js.\r\n\r\n    web3.js is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    web3.js is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n    This file is derived from web3.js/packages/web3-eth-abi/src/index.js (2019/06/12).\r\n    Modified and improved for the caver-js development.\r\n*/\r\n/**\r\n * @file index.js\r\n * @author Marek Kotewicz <marek@parity.io>\r\n * @author Fabian Vogelsteller <fabian@frozeman.de>\r\n * @date 2017\r\n */\r\n\r\nconst _ = require('lodash')\r\n\r\nconst EthersAbiCoder = require('@ethersproject/abi').AbiCoder\r\nconst ParamType = require('@ethersproject/abi').ParamType\r\nconst utils = require('../../caver-utils')\r\n\r\nconst ethersAbiCoder = new EthersAbiCoder(function(type, value) {\r\n    if (type.match(/^u?int/) && !_.isArray(value) && (!_.isObject(value) || value.constructor.name !== 'BN')) {\r\n        return value.toString()\r\n    }\r\n    return value\r\n})\r\n\r\n// result method\r\nfunction Result() {}\r\n\r\nclass ABI {\r\n    /**\r\n     * Encodes the function signature to its ABI signature, which are the first 4 bytes of the sha3 hash of the function name including parameter types.\r\n     *\r\n     * @example\r\n     * caver.abi.encodeFunctionSignature({ name: 'myMethod', type: 'function', inputs: [{ type: 'uint256', name: 'myNumber' },{ type: 'string', name: 'mystring' }]})\r\n     *\r\n     * caver.abi.encodeFunctionSignature('myMethod(uint256,string)')\r\n     *\r\n     * @method encodeFunctionSignature\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {string|object} functionSignature The function signature or the JSON interface object of the function to encode. If this is a string, it has to be in the form `function(type, type,...)`, e.g: `myFunction(uint256,uint32[],bytes10,bytes)`.\r\n     * @return {string} function signature\r\n     */\r\n    encodeFunctionSignature(functionSignature) {\r\n        if (_.isObject(functionSignature)) {\r\n            functionSignature = utils._jsonInterfaceMethodToString(functionSignature)\r\n        }\r\n\r\n        return utils.sha3(functionSignature).slice(0, 10)\r\n    }\r\n\r\n    /**\r\n     * Encodes the event signature to its ABI signature, which is the sha3 hash of the event name including input parameter types.\r\n     *\r\n     * @example\r\n     * caver.abi.encodeEventSignature({ name: 'myEvent', type: 'event', inputs: [{ type: 'uint256', name: 'myNumber' },{ type: 'string', name: 'mystring' }]})\r\n     *\r\n     * caver.abi.encodeEventSignature('myEvent(uint256,bytes32)')\r\n     *\r\n     * @method encodeEventSignature\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {string|object} eventSignature The event signature or the JSON interface object of the event to encode. If this is a string, it has to be in the form `event(type,type,...)`, e.g: `myEvent(uint256,uint32[],bytes10,bytes)`.\r\n     * @return {string} event signature\r\n     */\r\n    encodeEventSignature(eventSignature) {\r\n        if (_.isObject(eventSignature)) {\r\n            eventSignature = utils._jsonInterfaceMethodToString(eventSignature)\r\n        }\r\n\r\n        return utils.sha3(eventSignature)\r\n    }\r\n\r\n    /**\r\n     * Encodes a parameter based on its type to its ABI representation.\r\n     *\r\n     * @example\r\n     * caver.abi.encodeParameter('uint256', '2345675643')\r\n     * caver.abi.encodeParameter('bytes32[]', [caver.utils.rightPad('0xdf3234', 64), caver.utils.rightPad('0xfdfd', 64)])\r\n     * caver.abi.encodeParameter('tuple(bytes32,bool)', ['0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a18', true])\r\n     *\r\n     * @method encodeParameter\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {string|object} type The type of the parameter, see the {@link http://solidity.readthedocs.io/en/develop/types.html|solidity documentation}  for a list of types.\r\n     * @param {*} param The actual parameter to encode.\r\n     * @return {string} encoded plain param\r\n     */\r\n    encodeParameter(type, param) {\r\n        return this.encodeParameters([type], [param])\r\n    }\r\n\r\n    /**\r\n     * Encodes function parameters based on its JSON interface object.\r\n     *\r\n     * @example\r\n     * caver.abi.encodeParameters(['uint256','string'], ['2345675643', 'Hello!%'])\r\n     *\r\n     * caver.abi.encodeParameters(\r\n     *      ['tuple(bytes32,bool)', 'tuple(bool,address)'],\r\n     *      [['0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a18', true], [true, '0x77656c636f6d6520746f20657468657265756d2e']]\r\n     * )\r\n     *\r\n     * caver.abi.encodeParameters(\r\n     *   [\r\n     *       {\r\n     *           components: [{ name: 'a', type: 'bytes32' }, { name: 'b', type: 'bool' }],\r\n     *           name: 'tupleExample',\r\n     *           type: 'tuple',\r\n     *       },\r\n     *       {\r\n     *           components: [{ name: 'c', type: 'bool' }, { name: 'd', type: 'address' }],\r\n     *           name: 'tupleExample2',\r\n     *          type: 'tuple',\r\n     *      },\r\n     *  ],\r\n     *  [\r\n     *      ['0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a18', true],\r\n     *      [true, '0x77656c636f6d6520746f20657468657265756d2e']\r\n     *  ]\r\n     *)\r\n     *\r\n     * @method encodeParameters\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {Array.<string|object>} types An array with types or a JSON interface of a function. See the {@link http://solidity.readthedocs.io/en/develop/types.html|solidity documentation} for a list of types.\r\n     * @param {Array.<*>} params The parameters to encode.\r\n     * @return {string} encoded list of params\r\n     */\r\n    encodeParameters(types, params) {\r\n        const self = this\r\n        types = self.mapTypes(types)\r\n\r\n        params = params.map(function(param, index) {\r\n            let type = types[index]\r\n\r\n            // { components: [[Object], [Object]], name: 'b', type: 'tuple' }\r\n            if (typeof type === 'object' && type.type) {\r\n                // We may get a named type of shape {name, type}\r\n                type = type.type\r\n            }\r\n\r\n            param = self.formatParam(type, param)\r\n\r\n            // If the type is string but number comes in, ethersAbiCoder ignores the type and encodes successfully.\r\n            // To avoid invalid encoding value, adding error handling.\r\n            if (type === 'string' && typeof param !== 'string') throw new Error(`Invalid parameter: Parameter value and type do not match.`)\r\n\r\n            // Format params for tuples\r\n            if (typeof type === 'string' && type.includes('tuple')) {\r\n                const coder = ethersAbiCoder._getCoder(ParamType.from(type))\r\n                // eslint-disable-next-line no-shadow\r\n                const modifyParams = (coder, param) => {\r\n                    if (coder.name === 'array') {\r\n                        return param.map(p => {\r\n                            // `coder.type.replace('[]','')` can handle'tuple(string,string)[]', but cannot handle `tuple(string,string)[3]'.\r\n                            // Therefore, in order to handle tuple arrays of fixed length, the logic is changed to handle strings using regular expression expressions.\r\n                            const replacedType = coder.type.replace(/\\[[1-9]*\\]/g, '')\r\n                            const parameterType = ParamType.from(replacedType)\r\n                            const gotCoder = ethersAbiCoder._getCoder(parameterType)\r\n                            modifyParams(gotCoder, p)\r\n                        })\r\n                    }\r\n                    coder.coders.forEach((c, i) => {\r\n                        if (c.name === 'tuple') {\r\n                            modifyParams(c, param[i])\r\n                        } else {\r\n                            param[i] = self.formatParam(c.name, param[i])\r\n                        }\r\n                    })\r\n                }\r\n                modifyParams(coder, param)\r\n            }\r\n\r\n            return param\r\n        })\r\n\r\n        return ethersAbiCoder.encode(types, params)\r\n    }\r\n\r\n    /**\r\n     * Should be used to encode smart contract deployment with constructor arguments.\r\n     *\r\n     * @example\r\n     * // There is no argument for constructor\r\n     * caver.abi.encodeContractDeploy([\r\n     *     { \"constant\": true, \"inputs\": [], \"name\": \"count\", \"outputs\": [ { \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" },\r\n     *     { \"constant\": true, \"inputs\": [], \"name\": \"getBlockNumber\", \"outputs\": [ { \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" },\r\n     *     { \"constant\": false, \"inputs\": [ { \"name\": \"_count\", \"type\": \"uint256\" } ], \"name\": \"setCount\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" }\r\n     * ],'0x{byte code}')\r\n     *\r\n     * // There is one argument for constructor\r\n     * caver.abi.encodeContractDeploy([\r\n     *     { \"constant\": true, \"inputs\": [], \"name\": \"count\", \"outputs\": [ { \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" },\r\n     *     { \"constant\": true, \"inputs\": [], \"name\": \"getBlockNumber\", \"outputs\": [ { \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" },\r\n     *     { \"constant\": false, \"inputs\": [ { \"name\": \"_count\", \"type\": \"uint256\" } ], \"name\": \"setCount\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" },\r\n     *     { \"inputs\": [ { \"name\": \"_a\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"constructor\" }\r\n     * ],'0x{byte code}', 1)\r\n     *\r\n     * @method encodeContractDeploy\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {Array.<object>} jsonInterface The JSON interface of the contract.\r\n     * @param {string} bytecode A bytecode of smart contract to be deployed.\r\n     * @param {...*} [args] Arguments to pass to the constructor.\r\n     * @return {string} bytecode + args\r\n     */\r\n    encodeContractDeploy(jsonInterface, bytecode, ...args) {\r\n        if (!jsonInterface) {\r\n            throw new Error('jsonInterface should be provided for encoding contract deployment.')\r\n        }\r\n\r\n        if (!bytecode) {\r\n            throw new Error('bytecode should be provided for encoding contract deployment.')\r\n        }\r\n\r\n        const constructorInterface = jsonInterface.filter(({ type }) => type === 'constructor')[0]\r\n        const constructorInputs = constructorInterface && constructorInterface.inputs\r\n\r\n        // If constructor doesn't exist in smart contract, only bytecode is needed for deploying.\r\n        if (!constructorInterface || !constructorInputs || _.isEmpty(constructorInputs)) {\r\n            return bytecode\r\n        }\r\n\r\n        if (constructorInputs.length !== args.length) {\r\n            throw new Error(`invalid number of parameters for deploying. Got ${args.length} expected ${constructorInputs.length}!`)\r\n        }\r\n\r\n        const constructorTypes = constructorInputs.map(({ type }) => type)\r\n\r\n        return bytecode + this.encodeParameters(constructorTypes, args).replace('0x', '')\r\n    }\r\n\r\n    /**\r\n     * Map types if simplified format is used\r\n     *\r\n     * @method mapTypes\r\n     * @memberof ABI\r\n     * @ignore\r\n     * @instance\r\n     * @param {Array} types\r\n     * @return {Array}\r\n     */\r\n    mapTypes(types) {\r\n        const self = this\r\n        const mappedTypes = []\r\n        types.forEach(function(type) {\r\n            // Remap `function` type params to bytes24 since Ethers does not\r\n            // recognize former type. Solidity docs say `Function` is a bytes24\r\n            // encoding the contract address followed by the function selector hash.\r\n            if (typeof type === 'object' && type.type === 'function') {\r\n                type = { ...type, type: 'bytes24' }\r\n            }\r\n            if (self.isSimplifiedStructFormat(type)) {\r\n                const structName = Object.keys(type)[0]\r\n                mappedTypes.push(\r\n                    Object.assign(self.mapStructNameAndType(structName), {\r\n                        components: self.mapStructToCoderFormat(type[structName]),\r\n                    })\r\n                )\r\n\r\n                return\r\n            }\r\n\r\n            mappedTypes.push(type)\r\n        })\r\n        return mappedTypes\r\n    }\r\n\r\n    /**\r\n     * Check if type is simplified struct format\r\n     *\r\n     * @method isSimplifiedStructFormat\r\n     * @memberof ABI\r\n     * @ignore\r\n     * @instance\r\n     * @param {string|Object} type\r\n     * @returns {boolean}\r\n     */\r\n    isSimplifiedStructFormat(type) {\r\n        return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined'\r\n    }\r\n\r\n    /**\r\n     * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\r\n     *\r\n     * @method mapStructNameAndType\r\n     * @memberof ABI\r\n     * @ignore\r\n     * @instance\r\n     * @param {string} structName\r\n     * @return {{type: string, name: *}}\r\n     */\r\n    mapStructNameAndType(structName) {\r\n        let type = 'tuple'\r\n\r\n        if (structName.indexOf('[]') > -1) {\r\n            type = 'tuple[]'\r\n            structName = structName.slice(0, -2)\r\n        }\r\n\r\n        return { type: type, name: structName }\r\n    }\r\n\r\n    /**\r\n     * Maps the simplified format in to the expected format of the ABI\r\n     *\r\n     * @method mapStructToCoderFormat\r\n     * @memberof ABI\r\n     * @ignore\r\n     * @instance\r\n     * @param {object} struct\r\n     * @return {Array}\r\n     */\r\n    mapStructToCoderFormat(struct) {\r\n        const self = this\r\n        const components = []\r\n        Object.keys(struct).forEach(function(key) {\r\n            if (typeof struct[key] === 'object') {\r\n                components.push(\r\n                    Object.assign(self.mapStructNameAndType(key), {\r\n                        components: self.mapStructToCoderFormat(struct[key]),\r\n                    })\r\n                )\r\n\r\n                return\r\n            }\r\n\r\n            components.push({\r\n                name: key,\r\n                type: struct[key],\r\n            })\r\n        })\r\n\r\n        return components\r\n    }\r\n\r\n    /**\r\n     * Handle some formatting of params for backwards compatability with Ethers V4\r\n     *\r\n     * @method formatParam\r\n     * @memberof ABI\r\n     * @ignore\r\n     * @param {string} - type\r\n     * @param {any} - param\r\n     * @return {string|Array.<string>} - The formatted param\r\n     */\r\n    formatParam(type, param) {\r\n        const paramTypeBytes = /^bytes([0-9]*)$/\r\n        const paramTypeBytesArray = /^bytes([0-9]*)\\[\\]$/\r\n        const paramTypeNumber = /^(u?int)([0-9]*)$/\r\n        const paramTypeNumberArray = /^(u?int)([0-9]*)\\[\\]$/\r\n\r\n        // Format BN to string\r\n        if (utils.isBN(param) || utils.isBigNumber(param)) {\r\n            return param.toString(10)\r\n        }\r\n\r\n        if (type.match(paramTypeBytesArray) || type.match(paramTypeNumberArray)) {\r\n            return param.map(p => this.formatParam(type.replace('[]', ''), p))\r\n        }\r\n\r\n        // Format correct width for u?int[0-9]*\r\n        let match = type.match(paramTypeNumber)\r\n        if (match) {\r\n            const size = parseInt(match[2] || '256')\r\n            if (size / 8 < param.length) {\r\n                // pad to correct bit width\r\n                param = utils.leftPad(param, size)\r\n            }\r\n        }\r\n\r\n        // Format correct length for bytes[0-9]+\r\n        match = type.match(paramTypeBytes)\r\n        if (match) {\r\n            if (Buffer.isBuffer(param)) {\r\n                param = utils.toHex(param)\r\n            }\r\n\r\n            // format to correct length\r\n            const size = parseInt(match[1])\r\n            if (size) {\r\n                let maxSize = size * 2\r\n                if (param.substring(0, 2) === '0x') {\r\n                    maxSize += 2\r\n                }\r\n                if (param.length < maxSize) {\r\n                    // pad to correct length\r\n                    param = utils.rightPad(param, size * 2)\r\n                }\r\n            }\r\n\r\n            // format odd-length bytes to even-length\r\n            if (param.length % 2 === 1) {\r\n                param = `0x0${param.substring(2)}`\r\n            }\r\n        }\r\n\r\n        return param\r\n    }\r\n\r\n    /**\r\n     * Encodes a function call from its json interface and parameters.\r\n     *\r\n     * @example\r\n     * caver.abi.encodeFunctionCall({\r\n     *     name: 'myMethod',\r\n     *     type: 'function',\r\n     *     inputs: [{\r\n     *         type: 'uint256',\r\n     *         name: 'myNumber'\r\n     * },{\r\n     *         type: 'string',\r\n     *         name: 'mystring'\r\n     *     }]\r\n     * }, ['2345675643', 'Hello!%'])\r\n     *\r\n     * @method encodeFunctionCall\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {object} jsonInterface The JSON interface object of a function.\r\n     * @param {Array.<*>} [params] The parameters to encode.\r\n     * @return {string} The encoded ABI for this function call\r\n     */\r\n    encodeFunctionCall(jsonInterface, params) {\r\n        params = params || []\r\n        return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '')\r\n    }\r\n\r\n    /**\r\n     * Decodes a function call from its abi object of a function and returns parameters.\r\n     * If the function signature of the `abi` passed as a parameter does not match the function signature of the `functionCall`, an error is returned.\r\n     *\r\n     * @example\r\n     * const abi = {\r\n     *    name: 'myMethod',\r\n     *    type: 'function',\r\n     *    inputs: [\r\n     *        {\r\n     *            type: 'uint256',\r\n     *           name: 'myNumber',\r\n     *       },\r\n     *       {\r\n     *           type: 'string',\r\n     *           name: 'mystring',\r\n     *       },\r\n     *   ],\r\n     * }\r\n     * const functionCall = '0x24ef0...'\r\n     * caver.abi.decodeFunctionCall(abi, functionCall)\r\n     *\r\n     * @method decodeFunctionCall\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {object} abi The abi object of a function.\r\n     * @param {string} functionCall The encoded function call string.\r\n     * @return {object} An object which includes plain params. You can use `result[0]` as it is provided to be accessed like an array in the order of the parameters.\r\n     */\r\n    decodeFunctionCall(abi, functionCall) {\r\n        functionCall = utils.addHexPrefix(functionCall)\r\n\r\n        if (!_.isObject(abi) || _.isArray(abi))\r\n            throw new Error(\r\n                `Invalid abi parameter type: To decode function call, you need to pass an abi object of the function as a first parameter.`\r\n            )\r\n        if (!abi.name || !abi.inputs)\r\n            throw new Error(`Insufficient info in abi object: The function name and inputs must be defined inside the abi function object.`)\r\n\r\n        const funcSig = this.encodeFunctionSignature(abi)\r\n        const extractFuncSig = functionCall.slice(0, funcSig.length)\r\n\r\n        if (funcSig !== extractFuncSig)\r\n            throw new Error(\r\n                `Invalid function signature: The function signature of the abi as a parameter and the function signatures extracted from the function call string do not match.`\r\n            )\r\n\r\n        return this.decodeParameters(abi.inputs, `0x${functionCall.slice(funcSig.length)}`)\r\n    }\r\n\r\n    /**\r\n     * Decodes an ABI encoded parameter to its JavaScript type.\r\n     *\r\n     * @example\r\n     * caver.abi.decodeParameter('uint256', '0x0000000000000000000000000000000000000000000000000000000000000010')\r\n     *\r\n     * caver.abi.decodeParameter('string', '0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000848656c6c6f212521000000000000000000000000000000000000000000000000')\r\n     *\r\n     * caver.abi.decodeParameter('tuple(bytes32,bool)', '0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a180000000000000000000000000000000000000000000000000000000000000001')\r\n     *\r\n     * caver.abi.decodeParameter(\r\n     *     {\r\n     *         components: [{ name: 'a', type: 'bytes32' }, { name: 'b', type: 'bool' }],\r\n     *         name: 'tupleExample',\r\n     *         type: 'tuple',\r\n     *     }, '0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a180000000000000000000000000000000000000000000000000000000000000001'\r\n     * )\r\n     *\r\n     * @method decodeParameter\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {string|object} type The type of the parameter, see the {@link http://solidity.readthedocs.io/en/develop/types.html|solidity documentation} for a list of types.\r\n     * @param {string} encodedString The ABI byte code to decode.\r\n     * @return {string} plain param\r\n     */\r\n    decodeParameter(type, encodedString) {\r\n        return this.decodeParameters([type], encodedString)[0]\r\n    }\r\n\r\n    /**\r\n     * Decodes ABI encoded parameters to its JavaScript types.\r\n     *\r\n     * @example\r\n     * caver.abi.decodeParameters(['string', 'uint256'], '0x000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000ea000000000000000000000000000000000000000000000000000000000000000848656c6c6f212521000000000000000000000000000000000000000000000000')\r\n     *\r\n     * caver.abi.decodeParameters(\r\n     *  ['tuple(bytes32,bool)', 'tuple(bool,address)'],\r\n     *  '0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a180000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000077656c636f6d6520746f20657468657265756d2e'\r\n     * )\r\n     *\r\n     * caver.abi.decodeParameters([{\r\n     *     type: 'string',\r\n     *     name: 'mystring'\r\n     * },{\r\n     *     type: 'uint256',\r\n     *     name: 'myNumber'\r\n     * }], '0x000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000ea000000000000000000000000000000000000000000000000000000000000000848656c6c6f212521000000000000000000000000000000000000000000000000')\r\n     *\r\n     * caver.abi.decodeParameters(\r\n     *     [\r\n     *         {\r\n     *             components: [{ name: 'a', type: 'bytes32' }, { name: 'b', type: 'bool' }],\r\n     *             name: 'tupleExample',\r\n     *             type: 'tuple',\r\n     *         },\r\n     *         {\r\n     *             components: [{ name: 'c', type: 'bool' }, { name: 'd', type: 'address' }],\r\n     *             name: 'tupleExample2',\r\n     *             type: 'tuple',\r\n     *         },\r\n     *     ],\r\n     *     '0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a180000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000077656c636f6d6520746f20657468657265756d2e'\r\n     * )\r\n     *\r\n     * @method decodeParameters\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {Array.<string|object>} typesArray An array with types or an array of JSON interface outputs. See the {@link http://solidity.readthedocs.io/en/develop/types.html|solidity documentation} for a list of types.\r\n     * @param {string} encodedString The ABI byte code to decode.\r\n     * @return {object} An object which includes plain params. You can use `result[0]` as it is provided to be accessed like an array in the order of the parameters.\r\n     */\r\n    decodeParameters(outputs, encodedString) {\r\n        return this.decodeParametersWith(outputs, encodedString, false)\r\n    }\r\n\r\n    /**\r\n     * Should be used to decode list of params\r\n     *\r\n     * @method decodeParametersWith\r\n     * @memberof ABI\r\n     * @instance\r\n     * @ignore\r\n     * @param {Array} outputs\r\n     * @param {string} bytes\r\n     * @param {Boolean} loose must be passed for decoding bytes and string parameters for logs emitted with solc 0.4.x\r\n     *                        Please refer to https://github.com/ChainSafe/web3.js/commit/e80337e16e5c04683fc40148378775234c28e0fb.\r\n     * @return {object} An object which includes plain params. You can use `result[0]` as it is provided to be accessed like an array in the order of the parameters.\r\n     */\r\n    decodeParametersWith(outputs, bytes, loose) {\r\n        if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\r\n            throw new Error(\r\n                \"Returned values aren't valid, did it run Out of Gas? \" +\r\n                    'You might also see this error if you are not using the ' +\r\n                    'correct ABI for the contract you are retrieving data from, ' +\r\n                    'requesting data from a block number that does not exist, ' +\r\n                    'or querying a node which is not fully synced.'\r\n            )\r\n        }\r\n\r\n        const res = ethersAbiCoder.decode(this.mapTypes(outputs), `0x${bytes.replace(/0x/i, '')}`, loose)\r\n        const returnValue = new Result()\r\n        returnValue.__length__ = 0\r\n\r\n        outputs.forEach(function(output, i) {\r\n            let decodedValue = res[returnValue.__length__]\r\n            decodedValue = decodedValue === '0x' ? null : decodedValue\r\n\r\n            returnValue[i] = decodedValue\r\n\r\n            if (_.isObject(output) && output.name) {\r\n                returnValue[output.name] = decodedValue\r\n            }\r\n\r\n            returnValue.__length__++\r\n        })\r\n\r\n        return returnValue\r\n    }\r\n\r\n    /**\r\n     * Decodes ABI encoded log data and indexed topic data.\r\n     *\r\n     * @example\r\n     * caver.abi.decodeLog(\r\n     *     [\r\n     *         {\r\n     *             type: 'string',\r\n     *             name: 'mystring'\r\n     *         },{\r\n     *             type: 'uint256',\r\n     *             name: 'myNumber',\r\n     *             indexed: true\r\n     *         },{\r\n     *             type: 'uint8',\r\n     *             name: 'mySmallNumber',\r\n     *             indexed: true\r\n     *          }\r\n     *     ],\r\n     *     '0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000748656c6c6f252100000000000000000000000000000000000000000000000000',\r\n     *      ['0x000000000000000000000000000000000000000000000000000000000000f310', '0x0000000000000000000000000000000000000000000000000000000000000010']\r\n     * )\r\n     *\r\n     *\r\n     * @method decodeLog\r\n     * @memberof ABI\r\n     * @instance\r\n     * @param {Array.<object>} inputs An array of JSON interface inputs. See the solidity documentation for a list of types.\r\n     * @param {string} data The ABI byte code in the data field of a log.\r\n     * @param {*} topics An array of the index parameter topics of the log. This array doesn't have topic[0] if it is a non-anonymous event, or otherwise, it has topic[0].\r\n     * @return {object} An object which includes plain params. You can use `result[0]` as it is provided to be accessed like an array in the order of the parameters.\r\n     */\r\n    decodeLog(inputs, data, topics) {\r\n        const _this = this\r\n        topics = _.isArray(topics) ? topics : [topics]\r\n\r\n        data = data || ''\r\n\r\n        const notIndexedInputs = []\r\n        const indexedParams = []\r\n        let topicCount = 0\r\n\r\n        // TODO check for anonymous logs?\r\n\r\n        inputs.forEach(function(input, i) {\r\n            if (input.indexed) {\r\n                indexedParams[i] = ['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function(staticType) {\r\n                    return input.type.indexOf(staticType) !== -1\r\n                })\r\n                    ? _this.decodeParameter(input.type, topics[topicCount])\r\n                    : topics[topicCount]\r\n                topicCount++\r\n            } else {\r\n                notIndexedInputs[i] = input\r\n            }\r\n        })\r\n\r\n        const nonIndexedData = data\r\n        const notIndexedParams = nonIndexedData ? this.decodeParametersWith(notIndexedInputs, nonIndexedData, true) : []\r\n\r\n        const returnValue = new Result()\r\n        returnValue.__length__ = 0\r\n\r\n        inputs.forEach(function(res, i) {\r\n            returnValue[i] = res.type === 'string' ? '' : null\r\n\r\n            if (typeof notIndexedParams[i] !== 'undefined') {\r\n                returnValue[i] = notIndexedParams[i]\r\n            }\r\n            if (typeof indexedParams[i] !== 'undefined') {\r\n                returnValue[i] = indexedParams[i]\r\n            }\r\n\r\n            if (res.name) {\r\n                returnValue[res.name] = returnValue[i]\r\n            }\r\n\r\n            returnValue.__length__++\r\n        })\r\n\r\n        return returnValue\r\n    }\r\n}\r\n\r\n/** @instance */\r\nconst abi = new ABI()\r\n\r\nmodule.exports = abi\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAjB;;AAEA,MAAMC,cAAc,GAAGD,OAAO,CAAC,oBAAD,CAAP,CAA8BE,QAArD;;AACA,MAAMC,SAAS,GAAGH,OAAO,CAAC,oBAAD,CAAP,CAA8BG,SAAhD;;AACA,MAAMC,KAAK,GAAGJ,OAAO,CAAC,mBAAD,CAArB;;AAEA,MAAMK,cAAc,GAAG,IAAIJ,cAAJ,CAAmB,UAASK,IAAT,EAAeC,KAAf,EAAsB;EAC5D,IAAID,IAAI,CAACE,KAAL,CAAW,QAAX,KAAwB,CAACT,CAAC,CAACU,OAAF,CAAUF,KAAV,CAAzB,KAA8C,CAACR,CAAC,CAACW,QAAF,CAAWH,KAAX,CAAD,IAAsBA,KAAK,CAACI,WAAN,CAAkBC,IAAlB,KAA2B,IAA/F,CAAJ,EAA0G;IACtG,OAAOL,KAAK,CAACM,QAAN,EAAP;EACH;;EACD,OAAON,KAAP;AACH,CALsB,CAAvB,C,CAOA;;AACA,SAASO,MAAT,GAAkB,CAAE;;AAEpB,MAAMC,GAAN,CAAU;EACN;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,uBAAuB,CAACC,iBAAD,EAAoB;IACvC,IAAIlB,CAAC,CAACW,QAAF,CAAWO,iBAAX,CAAJ,EAAmC;MAC/BA,iBAAiB,GAAGb,KAAK,CAACc,4BAAN,CAAmCD,iBAAnC,CAApB;IACH;;IAED,OAAOb,KAAK,CAACe,IAAN,CAAWF,iBAAX,EAA8BG,KAA9B,CAAoC,CAApC,EAAuC,EAAvC,CAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIC,oBAAoB,CAACC,cAAD,EAAiB;IACjC,IAAIvB,CAAC,CAACW,QAAF,CAAWY,cAAX,CAAJ,EAAgC;MAC5BA,cAAc,GAAGlB,KAAK,CAACc,4BAAN,CAAmCI,cAAnC,CAAjB;IACH;;IAED,OAAOlB,KAAK,CAACe,IAAN,CAAWG,cAAX,CAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIC,eAAe,CAACjB,IAAD,EAAOkB,KAAP,EAAc;IACzB,OAAO,KAAKC,gBAAL,CAAsB,CAACnB,IAAD,CAAtB,EAA8B,CAACkB,KAAD,CAA9B,CAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIC,gBAAgB,CAACC,KAAD,EAAQC,MAAR,EAAgB;IAC5B,MAAMC,IAAI,GAAG,IAAb;IACAF,KAAK,GAAGE,IAAI,CAACC,QAAL,CAAcH,KAAd,CAAR;IAEAC,MAAM,GAAGA,MAAM,CAACG,GAAP,CAAW,UAASN,KAAT,EAAgBO,KAAhB,EAAuB;MACvC,IAAIzB,IAAI,GAAGoB,KAAK,CAACK,KAAD,CAAhB,CADuC,CAGvC;;MACA,IAAI,OAAOzB,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,CAACA,IAArC,EAA2C;QACvC;QACAA,IAAI,GAAGA,IAAI,CAACA,IAAZ;MACH;;MAEDkB,KAAK,GAAGI,IAAI,CAACI,WAAL,CAAiB1B,IAAjB,EAAuBkB,KAAvB,CAAR,CATuC,CAWvC;MACA;;MACA,IAAIlB,IAAI,KAAK,QAAT,IAAqB,OAAOkB,KAAP,KAAiB,QAA1C,EAAoD,MAAM,IAAIS,KAAJ,CAAW,2DAAX,CAAN,CAbb,CAevC;;MACA,IAAI,OAAO3B,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,CAAC4B,QAAL,CAAc,OAAd,CAAhC,EAAwD;QACpD,MAAMC,KAAK,GAAG9B,cAAc,CAAC+B,SAAf,CAAyBjC,SAAS,CAACkC,IAAV,CAAe/B,IAAf,CAAzB,CAAd,CADoD,CAEpD;;;QACA,MAAMgC,YAAY,GAAG,CAACH,KAAD,EAAQX,KAAR,KAAkB;UACnC,IAAIW,KAAK,CAACvB,IAAN,KAAe,OAAnB,EAA4B;YACxB,OAAOY,KAAK,CAACM,GAAN,CAAUS,CAAC,IAAI;cAClB;cACA;cACA,MAAMC,YAAY,GAAGL,KAAK,CAAC7B,IAAN,CAAWmC,OAAX,CAAmB,aAAnB,EAAkC,EAAlC,CAArB;cACA,MAAMC,aAAa,GAAGvC,SAAS,CAACkC,IAAV,CAAeG,YAAf,CAAtB;;cACA,MAAMG,QAAQ,GAAGtC,cAAc,CAAC+B,SAAf,CAAyBM,aAAzB,CAAjB;;cACAJ,YAAY,CAACK,QAAD,EAAWJ,CAAX,CAAZ;YACH,CAPM,CAAP;UAQH;;UACDJ,KAAK,CAACS,MAAN,CAAaC,OAAb,CAAqB,CAACC,CAAD,EAAIC,CAAJ,KAAU;YAC3B,IAAID,CAAC,CAAClC,IAAF,KAAW,OAAf,EAAwB;cACpB0B,YAAY,CAACQ,CAAD,EAAItB,KAAK,CAACuB,CAAD,CAAT,CAAZ;YACH,CAFD,MAEO;cACHvB,KAAK,CAACuB,CAAD,CAAL,GAAWnB,IAAI,CAACI,WAAL,CAAiBc,CAAC,CAAClC,IAAnB,EAAyBY,KAAK,CAACuB,CAAD,CAA9B,CAAX;YACH;UACJ,CAND;QAOH,CAlBD;;QAmBAT,YAAY,CAACH,KAAD,EAAQX,KAAR,CAAZ;MACH;;MAED,OAAOA,KAAP;IACH,CA1CQ,CAAT;IA4CA,OAAOnB,cAAc,CAAC2C,MAAf,CAAsBtB,KAAtB,EAA6BC,MAA7B,CAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIsB,oBAAoB,CAACC,aAAD,EAAgBC,QAAhB,EAAmC;IACnD,IAAI,CAACD,aAAL,EAAoB;MAChB,MAAM,IAAIjB,KAAJ,CAAU,oEAAV,CAAN;IACH;;IAED,IAAI,CAACkB,QAAL,EAAe;MACX,MAAM,IAAIlB,KAAJ,CAAU,+DAAV,CAAN;IACH;;IAED,MAAMmB,oBAAoB,GAAGF,aAAa,CAACG,MAAd,CAAqB;MAAA,IAAC;QAAE/C;MAAF,CAAD;MAAA,OAAcA,IAAI,KAAK,aAAvB;IAAA,CAArB,EAA2D,CAA3D,CAA7B;IACA,MAAMgD,iBAAiB,GAAGF,oBAAoB,IAAIA,oBAAoB,CAACG,MAAvE,CAVmD,CAYnD;;IACA,IAAI,CAACH,oBAAD,IAAyB,CAACE,iBAA1B,IAA+CvD,CAAC,CAACyD,OAAF,CAAUF,iBAAV,CAAnD,EAAiF;MAC7E,OAAOH,QAAP;IACH;;IAfkD,kCAANM,IAAM;MAANA,IAAM;IAAA;;IAiBnD,IAAIH,iBAAiB,CAACI,MAAlB,KAA6BD,IAAI,CAACC,MAAtC,EAA8C;MAC1C,MAAM,IAAIzB,KAAJ,CAAW,mDAAkDwB,IAAI,CAACC,MAAO,aAAYJ,iBAAiB,CAACI,MAAO,GAA9G,CAAN;IACH;;IAED,MAAMC,gBAAgB,GAAGL,iBAAiB,CAACxB,GAAlB,CAAsB;MAAA,IAAC;QAAExB;MAAF,CAAD;MAAA,OAAcA,IAAd;IAAA,CAAtB,CAAzB;IAEA,OAAO6C,QAAQ,GAAG,KAAK1B,gBAAL,CAAsBkC,gBAAtB,EAAwCF,IAAxC,EAA8ChB,OAA9C,CAAsD,IAAtD,EAA4D,EAA5D,CAAlB;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIZ,QAAQ,CAACH,KAAD,EAAQ;IACZ,MAAME,IAAI,GAAG,IAAb;IACA,MAAMgC,WAAW,GAAG,EAApB;IACAlC,KAAK,CAACmB,OAAN,CAAc,UAASvC,IAAT,EAAe;MACzB;MACA;MACA;MACA,IAAI,OAAOA,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,CAACA,IAAL,KAAc,UAA9C,EAA0D;QACtDA,IAAI,GAAG,EAAE,GAAGA,IAAL;UAAWA,IAAI,EAAE;QAAjB,CAAP;MACH;;MACD,IAAIsB,IAAI,CAACiC,wBAAL,CAA8BvD,IAA9B,CAAJ,EAAyC;QACrC,MAAMwD,UAAU,GAAGC,MAAM,CAACC,IAAP,CAAY1D,IAAZ,EAAkB,CAAlB,CAAnB;QACAsD,WAAW,CAACK,IAAZ,CACIF,MAAM,CAACG,MAAP,CAActC,IAAI,CAACuC,oBAAL,CAA0BL,UAA1B,CAAd,EAAqD;UACjDM,UAAU,EAAExC,IAAI,CAACyC,sBAAL,CAA4B/D,IAAI,CAACwD,UAAD,CAAhC;QADqC,CAArD,CADJ;QAMA;MACH;;MAEDF,WAAW,CAACK,IAAZ,CAAiB3D,IAAjB;IACH,CAnBD;IAoBA,OAAOsD,WAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIC,wBAAwB,CAACvD,IAAD,EAAO;IAC3B,OAAO,OAAOA,IAAP,KAAgB,QAAhB,IAA4B,OAAOA,IAAI,CAAC8D,UAAZ,KAA2B,WAAvD,IAAsE,OAAO9D,IAAI,CAACM,IAAZ,KAAqB,WAAlG;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIuD,oBAAoB,CAACL,UAAD,EAAa;IAC7B,IAAIxD,IAAI,GAAG,OAAX;;IAEA,IAAIwD,UAAU,CAACQ,OAAX,CAAmB,IAAnB,IAA2B,CAAC,CAAhC,EAAmC;MAC/BhE,IAAI,GAAG,SAAP;MACAwD,UAAU,GAAGA,UAAU,CAAC1C,KAAX,CAAiB,CAAjB,EAAoB,CAAC,CAArB,CAAb;IACH;;IAED,OAAO;MAAEd,IAAI,EAAEA,IAAR;MAAcM,IAAI,EAAEkD;IAApB,CAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIO,sBAAsB,CAACE,MAAD,EAAS;IAC3B,MAAM3C,IAAI,GAAG,IAAb;IACA,MAAMwC,UAAU,GAAG,EAAnB;IACAL,MAAM,CAACC,IAAP,CAAYO,MAAZ,EAAoB1B,OAApB,CAA4B,UAAS2B,GAAT,EAAc;MACtC,IAAI,OAAOD,MAAM,CAACC,GAAD,CAAb,KAAuB,QAA3B,EAAqC;QACjCJ,UAAU,CAACH,IAAX,CACIF,MAAM,CAACG,MAAP,CAActC,IAAI,CAACuC,oBAAL,CAA0BK,GAA1B,CAAd,EAA8C;UAC1CJ,UAAU,EAAExC,IAAI,CAACyC,sBAAL,CAA4BE,MAAM,CAACC,GAAD,CAAlC;QAD8B,CAA9C,CADJ;QAMA;MACH;;MAEDJ,UAAU,CAACH,IAAX,CAAgB;QACZrD,IAAI,EAAE4D,GADM;QAEZlE,IAAI,EAAEiE,MAAM,CAACC,GAAD;MAFA,CAAhB;IAIH,CAfD;IAiBA,OAAOJ,UAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIpC,WAAW,CAAC1B,IAAD,EAAOkB,KAAP,EAAc;IACrB,MAAMiD,cAAc,GAAG,iBAAvB;IACA,MAAMC,mBAAmB,GAAG,qBAA5B;IACA,MAAMC,eAAe,GAAG,mBAAxB;IACA,MAAMC,oBAAoB,GAAG,uBAA7B,CAJqB,CAMrB;;IACA,IAAIxE,KAAK,CAACyE,IAAN,CAAWrD,KAAX,KAAqBpB,KAAK,CAAC0E,WAAN,CAAkBtD,KAAlB,CAAzB,EAAmD;MAC/C,OAAOA,KAAK,CAACX,QAAN,CAAe,EAAf,CAAP;IACH;;IAED,IAAIP,IAAI,CAACE,KAAL,CAAWkE,mBAAX,KAAmCpE,IAAI,CAACE,KAAL,CAAWoE,oBAAX,CAAvC,EAAyE;MACrE,OAAOpD,KAAK,CAACM,GAAN,CAAUS,CAAC,IAAI,KAAKP,WAAL,CAAiB1B,IAAI,CAACmC,OAAL,CAAa,IAAb,EAAmB,EAAnB,CAAjB,EAAyCF,CAAzC,CAAf,CAAP;IACH,CAboB,CAerB;;;IACA,IAAI/B,KAAK,GAAGF,IAAI,CAACE,KAAL,CAAWmE,eAAX,CAAZ;;IACA,IAAInE,KAAJ,EAAW;MACP,MAAMuE,IAAI,GAAGC,QAAQ,CAACxE,KAAK,CAAC,CAAD,CAAL,IAAY,KAAb,CAArB;;MACA,IAAIuE,IAAI,GAAG,CAAP,GAAWvD,KAAK,CAACkC,MAArB,EAA6B;QACzB;QACAlC,KAAK,GAAGpB,KAAK,CAAC6E,OAAN,CAAczD,KAAd,EAAqBuD,IAArB,CAAR;MACH;IACJ,CAvBoB,CAyBrB;;;IACAvE,KAAK,GAAGF,IAAI,CAACE,KAAL,CAAWiE,cAAX,CAAR;;IACA,IAAIjE,KAAJ,EAAW;MACP,IAAI0E,MAAM,CAACC,QAAP,CAAgB3D,KAAhB,CAAJ,EAA4B;QACxBA,KAAK,GAAGpB,KAAK,CAACgF,KAAN,CAAY5D,KAAZ,CAAR;MACH,CAHM,CAKP;;;MACA,MAAMuD,IAAI,GAAGC,QAAQ,CAACxE,KAAK,CAAC,CAAD,CAAN,CAArB;;MACA,IAAIuE,IAAJ,EAAU;QACN,IAAIM,OAAO,GAAGN,IAAI,GAAG,CAArB;;QACA,IAAIvD,KAAK,CAAC8D,SAAN,CAAgB,CAAhB,EAAmB,CAAnB,MAA0B,IAA9B,EAAoC;UAChCD,OAAO,IAAI,CAAX;QACH;;QACD,IAAI7D,KAAK,CAACkC,MAAN,GAAe2B,OAAnB,EAA4B;UACxB;UACA7D,KAAK,GAAGpB,KAAK,CAACmF,QAAN,CAAe/D,KAAf,EAAsBuD,IAAI,GAAG,CAA7B,CAAR;QACH;MACJ,CAhBM,CAkBP;;;MACA,IAAIvD,KAAK,CAACkC,MAAN,GAAe,CAAf,KAAqB,CAAzB,EAA4B;QACxBlC,KAAK,GAAI,MAAKA,KAAK,CAAC8D,SAAN,CAAgB,CAAhB,CAAmB,EAAjC;MACH;IACJ;;IAED,OAAO9D,KAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIgE,kBAAkB,CAACtC,aAAD,EAAgBvB,MAAhB,EAAwB;IACtCA,MAAM,GAAGA,MAAM,IAAI,EAAnB;IACA,OAAO,KAAKX,uBAAL,CAA6BkC,aAA7B,IAA8C,KAAKzB,gBAAL,CAAsByB,aAAa,CAACK,MAApC,EAA4C5B,MAA5C,EAAoDc,OAApD,CAA4D,IAA5D,EAAkE,EAAlE,CAArD;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIgD,kBAAkB,CAACC,GAAD,EAAMC,YAAN,EAAoB;IAClCA,YAAY,GAAGvF,KAAK,CAACwF,YAAN,CAAmBD,YAAnB,CAAf;IAEA,IAAI,CAAC5F,CAAC,CAACW,QAAF,CAAWgF,GAAX,CAAD,IAAoB3F,CAAC,CAACU,OAAF,CAAUiF,GAAV,CAAxB,EACI,MAAM,IAAIzD,KAAJ,CACD,2HADC,CAAN;IAGJ,IAAI,CAACyD,GAAG,CAAC9E,IAAL,IAAa,CAAC8E,GAAG,CAACnC,MAAtB,EACI,MAAM,IAAItB,KAAJ,CAAW,+GAAX,CAAN;IAEJ,MAAM4D,OAAO,GAAG,KAAK7E,uBAAL,CAA6B0E,GAA7B,CAAhB;IACA,MAAMI,cAAc,GAAGH,YAAY,CAACvE,KAAb,CAAmB,CAAnB,EAAsByE,OAAO,CAACnC,MAA9B,CAAvB;IAEA,IAAImC,OAAO,KAAKC,cAAhB,EACI,MAAM,IAAI7D,KAAJ,CACD,gKADC,CAAN;IAIJ,OAAO,KAAK8D,gBAAL,CAAsBL,GAAG,CAACnC,MAA1B,EAAmC,KAAIoC,YAAY,CAACvE,KAAb,CAAmByE,OAAO,CAACnC,MAA3B,CAAmC,EAA1E,CAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIsC,eAAe,CAAC1F,IAAD,EAAO2F,aAAP,EAAsB;IACjC,OAAO,KAAKF,gBAAL,CAAsB,CAACzF,IAAD,CAAtB,EAA8B2F,aAA9B,EAA6C,CAA7C,CAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIF,gBAAgB,CAACG,OAAD,EAAUD,aAAV,EAAyB;IACrC,OAAO,KAAKE,oBAAL,CAA0BD,OAA1B,EAAmCD,aAAnC,EAAkD,KAAlD,CAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIE,oBAAoB,CAACD,OAAD,EAAUE,KAAV,EAAiBC,KAAjB,EAAwB;IACxC,IAAIH,OAAO,CAACxC,MAAR,GAAiB,CAAjB,KAAuB,CAAC0C,KAAD,IAAUA,KAAK,KAAK,IAApB,IAA4BA,KAAK,KAAK,IAA7D,CAAJ,EAAwE;MACpE,MAAM,IAAInE,KAAJ,CACF,0DACI,yDADJ,GAEI,6DAFJ,GAGI,2DAHJ,GAII,+CALF,CAAN;IAOH;;IAED,MAAMqE,GAAG,GAAGjG,cAAc,CAACkG,MAAf,CAAsB,KAAK1E,QAAL,CAAcqE,OAAd,CAAtB,EAA+C,KAAIE,KAAK,CAAC3D,OAAN,CAAc,KAAd,EAAqB,EAArB,CAAyB,EAA5E,EAA+E4D,KAA/E,CAAZ;IACA,MAAMG,WAAW,GAAG,IAAI1F,MAAJ,EAApB;IACA0F,WAAW,CAACC,UAAZ,GAAyB,CAAzB;IAEAP,OAAO,CAACrD,OAAR,CAAgB,UAAS6D,MAAT,EAAiB3D,CAAjB,EAAoB;MAChC,IAAI4D,YAAY,GAAGL,GAAG,CAACE,WAAW,CAACC,UAAb,CAAtB;MACAE,YAAY,GAAGA,YAAY,KAAK,IAAjB,GAAwB,IAAxB,GAA+BA,YAA9C;MAEAH,WAAW,CAACzD,CAAD,CAAX,GAAiB4D,YAAjB;;MAEA,IAAI5G,CAAC,CAACW,QAAF,CAAWgG,MAAX,KAAsBA,MAAM,CAAC9F,IAAjC,EAAuC;QACnC4F,WAAW,CAACE,MAAM,CAAC9F,IAAR,CAAX,GAA2B+F,YAA3B;MACH;;MAEDH,WAAW,CAACC,UAAZ;IACH,CAXD;IAaA,OAAOD,WAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACII,SAAS,CAACrD,MAAD,EAASsD,IAAT,EAAeC,MAAf,EAAuB;IAC5B,MAAMC,KAAK,GAAG,IAAd;;IACAD,MAAM,GAAG/G,CAAC,CAACU,OAAF,CAAUqG,MAAV,IAAoBA,MAApB,GAA6B,CAACA,MAAD,CAAtC;IAEAD,IAAI,GAAGA,IAAI,IAAI,EAAf;IAEA,MAAMG,gBAAgB,GAAG,EAAzB;IACA,MAAMC,aAAa,GAAG,EAAtB;IACA,IAAIC,UAAU,GAAG,CAAjB,CAR4B,CAU5B;;IAEA3D,MAAM,CAACV,OAAP,CAAe,UAASsE,KAAT,EAAgBpE,CAAhB,EAAmB;MAC9B,IAAIoE,KAAK,CAACC,OAAV,EAAmB;QACfH,aAAa,CAAClE,CAAD,CAAb,GAAmB,CAAC,MAAD,EAAS,KAAT,EAAgB,MAAhB,EAAwB,SAAxB,EAAmC,OAAnC,EAA4C,QAA5C,EAAsDsE,IAAtD,CAA2D,UAASC,UAAT,EAAqB;UAC/F,OAAOH,KAAK,CAAC7G,IAAN,CAAWgE,OAAX,CAAmBgD,UAAnB,MAAmC,CAAC,CAA3C;QACH,CAFkB,IAGbP,KAAK,CAACf,eAAN,CAAsBmB,KAAK,CAAC7G,IAA5B,EAAkCwG,MAAM,CAACI,UAAD,CAAxC,CAHa,GAIbJ,MAAM,CAACI,UAAD,CAJZ;QAKAA,UAAU;MACb,CAPD,MAOO;QACHF,gBAAgB,CAACjE,CAAD,CAAhB,GAAsBoE,KAAtB;MACH;IACJ,CAXD;IAaA,MAAMI,cAAc,GAAGV,IAAvB;IACA,MAAMW,gBAAgB,GAAGD,cAAc,GAAG,KAAKpB,oBAAL,CAA0Ba,gBAA1B,EAA4CO,cAA5C,EAA4D,IAA5D,CAAH,GAAuE,EAA9G;IAEA,MAAMf,WAAW,GAAG,IAAI1F,MAAJ,EAApB;IACA0F,WAAW,CAACC,UAAZ,GAAyB,CAAzB;IAEAlD,MAAM,CAACV,OAAP,CAAe,UAASyD,GAAT,EAAcvD,CAAd,EAAiB;MAC5ByD,WAAW,CAACzD,CAAD,CAAX,GAAiBuD,GAAG,CAAChG,IAAJ,KAAa,QAAb,GAAwB,EAAxB,GAA6B,IAA9C;;MAEA,IAAI,OAAOkH,gBAAgB,CAACzE,CAAD,CAAvB,KAA+B,WAAnC,EAAgD;QAC5CyD,WAAW,CAACzD,CAAD,CAAX,GAAiByE,gBAAgB,CAACzE,CAAD,CAAjC;MACH;;MACD,IAAI,OAAOkE,aAAa,CAAClE,CAAD,CAApB,KAA4B,WAAhC,EAA6C;QACzCyD,WAAW,CAACzD,CAAD,CAAX,GAAiBkE,aAAa,CAAClE,CAAD,CAA9B;MACH;;MAED,IAAIuD,GAAG,CAAC1F,IAAR,EAAc;QACV4F,WAAW,CAACF,GAAG,CAAC1F,IAAL,CAAX,GAAwB4F,WAAW,CAACzD,CAAD,CAAnC;MACH;;MAEDyD,WAAW,CAACC,UAAZ;IACH,CAfD;IAiBA,OAAOD,WAAP;EACH;;AA3oBK;AA8oBV;;;AACA,MAAMd,GAAG,GAAG,IAAI3E,GAAJ,EAAZ;AAEA0G,MAAM,CAACC,OAAP,GAAiBhC,GAAjB"},"metadata":{},"sourceType":"script"}