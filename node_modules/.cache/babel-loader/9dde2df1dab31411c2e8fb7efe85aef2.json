{"ast":null,"code":"/**\r\n * Multihash implementation in JavaScript.\r\n */\n'use strict';\n\nconst multibase = require('multibase');\n\nconst varint = require('varint');\n\nconst {\n  names\n} = require('./constants');\n\nconst uint8ArrayToString = require('uint8arrays/to-string');\n\nconst uint8ArrayFromString = require('uint8arrays/from-string');\n\nconst uint8ArrayConcat = require('uint8arrays/concat');\n\nconst codes =\n/** @type {import('./types').CodeNameMap} */\n{}; // eslint-disable-next-line guard-for-in\n\nfor (const key in names) {\n  const name =\n  /** @type {HashName} */\n  key;\n  codes[names[name]] = name;\n}\n\nObject.freeze(codes);\n/**\r\n * Convert the given multihash to a hex encoded string.\r\n *\r\n * @param {Uint8Array} hash\r\n * @returns {string}\r\n */\n\nfunction toHexString(hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array');\n  }\n\n  return uint8ArrayToString(hash, 'base16');\n}\n/**\r\n * Convert the given hex encoded string to a multihash.\r\n *\r\n * @param {string} hash\r\n * @returns {Uint8Array}\r\n */\n\n\nfunction fromHexString(hash) {\n  return uint8ArrayFromString(hash, 'base16');\n}\n/**\r\n * Convert the given multihash to a base58 encoded string.\r\n *\r\n * @param {Uint8Array} hash\r\n * @returns {string}\r\n */\n\n\nfunction toB58String(hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array');\n  }\n\n  return uint8ArrayToString(multibase.encode('base58btc', hash)).slice(1);\n}\n/**\r\n * Convert the given base58 encoded string to a multihash.\r\n *\r\n * @param {string|Uint8Array} hash\r\n * @returns {Uint8Array}\r\n */\n\n\nfunction fromB58String(hash) {\n  const encoded = hash instanceof Uint8Array ? uint8ArrayToString(hash) : hash;\n  return multibase.decode('z' + encoded);\n}\n/**\r\n * Decode a hash from the given multihash.\r\n *\r\n * @param {Uint8Array} bytes\r\n * @returns {{code: HashCode, name: HashName, length: number, digest: Uint8Array}} result\r\n */\n\n\nfunction decode(bytes) {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new Error('multihash must be a Uint8Array');\n  }\n\n  if (bytes.length < 2) {\n    throw new Error('multihash too short. must be > 2 bytes.');\n  }\n\n  const code =\n  /** @type {HashCode} */\n  varint.decode(bytes);\n\n  if (!isValidCode(code)) {\n    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`);\n  }\n\n  bytes = bytes.slice(varint.decode.bytes);\n  const len = varint.decode(bytes);\n\n  if (len < 0) {\n    throw new Error(`multihash invalid length: ${len}`);\n  }\n\n  bytes = bytes.slice(varint.decode.bytes);\n\n  if (bytes.length !== len) {\n    throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes, 'base16')}`);\n  }\n\n  return {\n    code,\n    name: codes[code],\n    length: len,\n    digest: bytes\n  };\n}\n/**\r\n * Encode a hash digest along with the specified function code.\r\n *\r\n * > **Note:** the length is derived from the length of the digest itself.\r\n *\r\n * @param {Uint8Array} digest\r\n * @param {HashName | HashCode} code\r\n * @param {number} [length]\r\n * @returns {Uint8Array}\r\n */\n\n\nfunction encode(digest, code, length) {\n  if (!digest || code === undefined) {\n    throw new Error('multihash encode requires at least two args: digest, code');\n  } // ensure it's a hashfunction code.\n\n\n  const hashfn = coerceCode(code);\n\n  if (!(digest instanceof Uint8Array)) {\n    throw new Error('digest should be a Uint8Array');\n  }\n\n  if (length == null) {\n    length = digest.length;\n  }\n\n  if (length && digest.length !== length) {\n    throw new Error('digest length should be equal to specified length.');\n  }\n\n  const hash = varint.encode(hashfn);\n  const len = varint.encode(length);\n  return uint8ArrayConcat([hash, len, digest], hash.length + len.length + digest.length);\n}\n/**\r\n * Converts a hash function name into the matching code.\r\n * If passed a number it will return the number if it's a valid code.\r\n *\r\n * @param {HashName | number} name\r\n * @returns {number}\r\n */\n\n\nfunction coerceCode(name) {\n  let code = name;\n\n  if (typeof name === 'string') {\n    if (names[name] === undefined) {\n      throw new Error(`Unrecognized hash function named: ${name}`);\n    }\n\n    code = names[name];\n  }\n\n  if (typeof code !== 'number') {\n    throw new Error(`Hash function code should be a number. Got: ${code}`);\n  } // @ts-ignore\n\n\n  if (codes[code] === undefined && !isAppCode(code)) {\n    throw new Error(`Unrecognized function code: ${code}`);\n  }\n\n  return code;\n}\n/**\r\n * Checks if a code is part of the app range\r\n *\r\n * @param {number} code\r\n * @returns {boolean}\r\n */\n\n\nfunction isAppCode(code) {\n  return code > 0 && code < 0x10;\n}\n/**\r\n * Checks whether a multihash code is valid.\r\n *\r\n * @param {HashCode} code\r\n * @returns {boolean}\r\n */\n\n\nfunction isValidCode(code) {\n  if (isAppCode(code)) {\n    return true;\n  }\n\n  if (codes[code]) {\n    return true;\n  }\n\n  return false;\n}\n/**\r\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\r\n *\r\n * @param {Uint8Array} multihash\r\n * @returns {void}\r\n * @throws {Error}\r\n */\n\n\nfunction validate(multihash) {\n  decode(multihash); // throws if bad.\n}\n/**\r\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\r\n *\r\n * @param {Uint8Array} multihash\r\n * @returns {Uint8Array}\r\n * @throws {Error}\r\n */\n\n\nfunction prefix(multihash) {\n  validate(multihash);\n  return multihash.subarray(0, 2);\n}\n\nmodule.exports = {\n  names,\n  codes,\n  toHexString,\n  fromHexString,\n  toB58String,\n  fromB58String,\n  decode,\n  encode,\n  coerceCode,\n  isAppCode,\n  validate,\n  prefix,\n  isValidCode\n};\n/**\r\n * @typedef { import(\"./constants\").HashCode } HashCode\r\n * @typedef { import(\"./constants\").HashName } HashName\r\n */","map":{"version":3,"names":["multibase","require","varint","names","uint8ArrayToString","uint8ArrayFromString","uint8ArrayConcat","codes","key","name","Object","freeze","toHexString","hash","Uint8Array","Error","fromHexString","toB58String","encode","slice","fromB58String","encoded","decode","bytes","length","code","isValidCode","toString","len","digest","undefined","hashfn","coerceCode","isAppCode","validate","multihash","prefix","subarray","module","exports"],"sources":["C:/Users/User/Documents/clone-starter-kit-08/node_modules/multihashes/src/index.js"],"sourcesContent":["/**\r\n * Multihash implementation in JavaScript.\r\n */\r\n'use strict'\r\n\r\nconst multibase = require('multibase')\r\nconst varint = require('varint')\r\nconst { names } = require('./constants')\r\nconst uint8ArrayToString = require('uint8arrays/to-string')\r\nconst uint8ArrayFromString = require('uint8arrays/from-string')\r\nconst uint8ArrayConcat = require('uint8arrays/concat')\r\n\r\nconst codes = /** @type {import('./types').CodeNameMap} */({})\r\n\r\n// eslint-disable-next-line guard-for-in\r\nfor (const key in names) {\r\n  const name = /** @type {HashName} */(key)\r\n  codes[names[name]] = name\r\n}\r\nObject.freeze(codes)\r\n\r\n/**\r\n * Convert the given multihash to a hex encoded string.\r\n *\r\n * @param {Uint8Array} hash\r\n * @returns {string}\r\n */\r\nfunction toHexString (hash) {\r\n  if (!(hash instanceof Uint8Array)) {\r\n    throw new Error('must be passed a Uint8Array')\r\n  }\r\n\r\n  return uint8ArrayToString(hash, 'base16')\r\n}\r\n\r\n/**\r\n * Convert the given hex encoded string to a multihash.\r\n *\r\n * @param {string} hash\r\n * @returns {Uint8Array}\r\n */\r\nfunction fromHexString (hash) {\r\n  return uint8ArrayFromString(hash, 'base16')\r\n}\r\n\r\n/**\r\n * Convert the given multihash to a base58 encoded string.\r\n *\r\n * @param {Uint8Array} hash\r\n * @returns {string}\r\n */\r\nfunction toB58String (hash) {\r\n  if (!(hash instanceof Uint8Array)) {\r\n    throw new Error('must be passed a Uint8Array')\r\n  }\r\n\r\n  return uint8ArrayToString(multibase.encode('base58btc', hash)).slice(1)\r\n}\r\n\r\n/**\r\n * Convert the given base58 encoded string to a multihash.\r\n *\r\n * @param {string|Uint8Array} hash\r\n * @returns {Uint8Array}\r\n */\r\nfunction fromB58String (hash) {\r\n  const encoded = hash instanceof Uint8Array\r\n    ? uint8ArrayToString(hash)\r\n    : hash\r\n\r\n  return multibase.decode('z' + encoded)\r\n}\r\n\r\n/**\r\n * Decode a hash from the given multihash.\r\n *\r\n * @param {Uint8Array} bytes\r\n * @returns {{code: HashCode, name: HashName, length: number, digest: Uint8Array}} result\r\n */\r\nfunction decode (bytes) {\r\n  if (!(bytes instanceof Uint8Array)) {\r\n    throw new Error('multihash must be a Uint8Array')\r\n  }\r\n\r\n  if (bytes.length < 2) {\r\n    throw new Error('multihash too short. must be > 2 bytes.')\r\n  }\r\n\r\n  const code = /** @type {HashCode} */(varint.decode(bytes))\r\n  if (!isValidCode(code)) {\r\n    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)\r\n  }\r\n  bytes = bytes.slice(varint.decode.bytes)\r\n\r\n  const len = varint.decode(bytes)\r\n  if (len < 0) {\r\n    throw new Error(`multihash invalid length: ${len}`)\r\n  }\r\n  bytes = bytes.slice(varint.decode.bytes)\r\n\r\n  if (bytes.length !== len) {\r\n    throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes, 'base16')}`)\r\n  }\r\n\r\n  return {\r\n    code,\r\n    name: codes[code],\r\n    length: len,\r\n    digest: bytes\r\n  }\r\n}\r\n\r\n/**\r\n * Encode a hash digest along with the specified function code.\r\n *\r\n * > **Note:** the length is derived from the length of the digest itself.\r\n *\r\n * @param {Uint8Array} digest\r\n * @param {HashName | HashCode} code\r\n * @param {number} [length]\r\n * @returns {Uint8Array}\r\n */\r\nfunction encode (digest, code, length) {\r\n  if (!digest || code === undefined) {\r\n    throw new Error('multihash encode requires at least two args: digest, code')\r\n  }\r\n\r\n  // ensure it's a hashfunction code.\r\n  const hashfn = coerceCode(code)\r\n\r\n  if (!(digest instanceof Uint8Array)) {\r\n    throw new Error('digest should be a Uint8Array')\r\n  }\r\n\r\n  if (length == null) {\r\n    length = digest.length\r\n  }\r\n\r\n  if (length && digest.length !== length) {\r\n    throw new Error('digest length should be equal to specified length.')\r\n  }\r\n\r\n  const hash = varint.encode(hashfn)\r\n  const len = varint.encode(length)\r\n  return uint8ArrayConcat([hash, len, digest], hash.length + len.length + digest.length)\r\n}\r\n\r\n/**\r\n * Converts a hash function name into the matching code.\r\n * If passed a number it will return the number if it's a valid code.\r\n *\r\n * @param {HashName | number} name\r\n * @returns {number}\r\n */\r\nfunction coerceCode (name) {\r\n  let code = name\r\n\r\n  if (typeof name === 'string') {\r\n    if (names[name] === undefined) {\r\n      throw new Error(`Unrecognized hash function named: ${name}`)\r\n    }\r\n    code = names[name]\r\n  }\r\n\r\n  if (typeof code !== 'number') {\r\n    throw new Error(`Hash function code should be a number. Got: ${code}`)\r\n  }\r\n\r\n  // @ts-ignore\r\n  if (codes[code] === undefined && !isAppCode(code)) {\r\n    throw new Error(`Unrecognized function code: ${code}`)\r\n  }\r\n\r\n  return code\r\n}\r\n\r\n/**\r\n * Checks if a code is part of the app range\r\n *\r\n * @param {number} code\r\n * @returns {boolean}\r\n */\r\nfunction isAppCode (code) {\r\n  return code > 0 && code < 0x10\r\n}\r\n\r\n/**\r\n * Checks whether a multihash code is valid.\r\n *\r\n * @param {HashCode} code\r\n * @returns {boolean}\r\n */\r\nfunction isValidCode (code) {\r\n  if (isAppCode(code)) {\r\n    return true\r\n  }\r\n\r\n  if (codes[code]) {\r\n    return true\r\n  }\r\n\r\n  return false\r\n}\r\n\r\n/**\r\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\r\n *\r\n * @param {Uint8Array} multihash\r\n * @returns {void}\r\n * @throws {Error}\r\n */\r\nfunction validate (multihash) {\r\n  decode(multihash) // throws if bad.\r\n}\r\n\r\n/**\r\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\r\n *\r\n * @param {Uint8Array} multihash\r\n * @returns {Uint8Array}\r\n * @throws {Error}\r\n */\r\nfunction prefix (multihash) {\r\n  validate(multihash)\r\n\r\n  return multihash.subarray(0, 2)\r\n}\r\n\r\nmodule.exports = {\r\n  names,\r\n  codes,\r\n  toHexString,\r\n  fromHexString,\r\n  toB58String,\r\n  fromB58String,\r\n  decode,\r\n  encode,\r\n  coerceCode,\r\n  isAppCode,\r\n  validate,\r\n  prefix,\r\n  isValidCode\r\n}\r\n\r\n/**\r\n * @typedef { import(\"./constants\").HashCode } HashCode\r\n * @typedef { import(\"./constants\").HashName } HashName\r\n */\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}