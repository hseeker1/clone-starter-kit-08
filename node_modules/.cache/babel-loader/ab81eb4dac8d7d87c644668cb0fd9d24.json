{"ast":null,"code":"var _slicedToArray = require(\"C:\\\\Users\\\\User\\\\Documents\\\\clone-starter-kit-08\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\n/*\r\n    Modifications copyright 2018 The caver-js Authors\r\n    This file is part of web3.js.\r\n\r\n    web3.js is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    web3.js is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n    This file is derived from web3.js/packages/web3-core-method/src/index.js (2019/06/12).\r\n    Modified and improved for the caver-js development.\r\n*/\n\n/**\r\n * @file index.js\r\n * @author Fabian Vogelsteller <fabian@ethereum.org>\r\n * @author Marek Kotewicz <marek@parity.io>\r\n * @date 2017\r\n */\nvar _ = require('lodash');\n\nvar errors = require('../../caver-core-helpers').errors;\n\nvar formatters = require('../../caver-core-helpers').formatters;\n\nvar utils = require('../../caver-utils');\n\nvar Subscriptions = require('../../caver-core-subscriptions').subscriptions;\n\nvar validateParams = require('../../caver-core-helpers').validateFunction.validateParams;\n\nvar TIMEOUTBLOCK = 50;\nvar AVERAGE_BLOCK_TIME = 1; // 1s\n\nvar POLLINGTIMEOUT = AVERAGE_BLOCK_TIME * TIMEOUTBLOCK; // ~average block time (seconds) * TIMEOUTBLOCK\n\nvar TransactionDecoder = require('../../caver-transaction/src/transactionDecoder/transactionDecoder');\n\nvar _require = require('../../caver-transaction/src/transactionHelper/transactionHelper'),\n    TX_TYPE_STRING = _require.TX_TYPE_STRING;\n\nvar _require2 = require('../../caver-klay/caver-klay-accounts/src/transactionType/account'),\n    resolveRawKeyToAccountKey = _require2.resolveRawKeyToAccountKey;\n\nfunction Method(options) {\n  // call, name should be existed to create a method.\n  if (!options.call || !options.name) throw errors.needNameCallPropertyToCreateMethod;\n  this.name = options.name;\n  this.call = options.call;\n  this.hexCall = options.hexCall;\n  this.params = options.params || 0;\n  this.inputFormatter = options.inputFormatter || [];\n  this.outputFormatter = options.outputFormatter;\n  this.transformPayload = options.transformPayload;\n  this.extraFormatters = options.extraFormatters;\n  this.requestManager = options.requestManager; // reference to klay.accounts\n\n  this.accounts = options.accounts;\n  this.defaultBlock = options.defaultBlock || 'latest';\n  this.defaultAccount = options.defaultAccount || null;\n  this.outputFormatterDisable = options.outputFormatterDisable;\n}\n\nMethod.prototype.setRequestManager = setRequestManager;\nMethod.prototype.createFunction = createFunction;\nMethod.prototype.attachToObject = attachToObject;\nMethod.prototype.getCall = getCall;\nMethod.prototype.extractCallback = extractCallback;\nMethod.prototype.validateArgs = validateArgs;\nMethod.prototype.formatInput = formatInput;\nMethod.prototype.formatOutput = formatOutput;\nMethod.prototype.toPayload = toPayload;\nMethod.prototype.buildCall = buildCall;\nMethod.prototype._confirmTransaction = _confirmTransaction;\nMethod.prototype.request = request;\n/**\r\n * Set requestManager for rpc calling.\r\n * If it has accounts parameter also, set it.\r\n * @method setRequestManager\r\n * @param  {Object} requestManager\r\n * @param  {Object} accounts\r\n */\n\nfunction setRequestManager(requestManager, accounts) {\n  this.requestManager = requestManager; // reference to klay.accounts\n\n  if (accounts) this.accounts = accounts;\n}\n/**\r\n * createFunction through 'this' context (= instance by created through new Method(...))\r\n * @method createFunction\r\n * @param  {Object} requestManager\r\n * @param  {Object} accounts\r\n * @return {Function} it will be used for sending RPC call.\r\n */\n\n\nfunction createFunction(requestManager, accounts) {\n  // set requestManager for method individulally.\n  this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts); // this.buildCall() returns function `send = function() { ... }`\n\n  var func = this.buildCall(); // call is directly used for rpc calling,\n  // ex) 'klay_sendTransaction'\n\n  func.call = this.call;\n  return func;\n}\n/**\r\n * attach buildCalled method to 'obj' object,\r\n * by adding a property name through this.name\r\n * @method attachToObject\r\n * @param  {Object} obj\r\n */\n\n\nfunction attachToObject(obj) {\n  var _this2 = this;\n\n  var func = this.buildCall();\n  func.call = this.call;\n\n  var _this$name$split = this.name.split('.'),\n      _this$name$split2 = _slicedToArray(_this$name$split, 2),\n      callName = _this$name$split2[0],\n      optionalName = _this$name$split2[1];\n\n  if (optionalName) {\n    obj[callName] = obj[callName] || {};\n    obj[callName][optionalName] = func;\n\n    obj[callName][optionalName].getMethod = function () {\n      return _this2;\n    };\n  } else {\n    obj[callName] = func;\n\n    obj[callName].getMethod = function () {\n      return _this2;\n    };\n  }\n}\n/**\r\n * Should be used to determine name of the jsonrpc method based on arguments\r\n *\r\n * @method getCall\r\n * @param {Array} arguments\r\n * @return {String} name of jsonrpc method\r\n */\n\n\nfunction getCall(args) {\n  // If hexCall is defined, args[0] type is truly hexParameter, return this.hexCall\n  // If not, return this.call\n  // 'this.call', 'this.hexCall' are defined in rpc.json\n  return this.hexCall && utils.isHexParameter(args[0]) ? this.hexCall : this.call;\n}\n/**\r\n * Should be used to extract callback from array of arguments.\r\n * (caution) It modifies input param.\r\n *\r\n * @method extractCallback\r\n * @param {Array} arguments\r\n * @return {Function|Null} callback, if exists\r\n */\n\n\nfunction extractCallback(args) {\n  if (_.isFunction(args[args.length - 1])) {\n    return args.pop(); // 'pop' method modifies the original args array!\n  }\n}\n/**\r\n * Should be called to check if the number of arguments is correct\r\n *\r\n * @method validateArgs\r\n * @param {Array} arguments\r\n * @throws {Error} if it is not\r\n */\n\n\nfunction validateArgs(args) {\n  if (args.length !== this.params) {\n    throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n  }\n}\n/**\r\n * Should be called to format input args of method\r\n *\r\n * @method formatInput\r\n * @param {Array}\r\n * @return {Array}\r\n */\n\n\nfunction formatInput(args) {\n  var _this = this; // If inputFormatter is not defined, or empty just return original args.\n\n\n  if (!this.inputFormatter || _.isEmpty(this.inputFormatter)) {\n    return args;\n  } // If inputFormatter is defined, map original args by calling formatter.\n\n\n  return this.inputFormatter.map(function (formatter, index) {\n    // bind this for defaultBlock, and defaultAccount\n    var formattedInput = args[index];\n\n    if (formatter) {\n      formattedInput = formatter.call(_this, args[index]);\n    }\n\n    return formattedInput;\n  });\n}\n/**\r\n * Should be called to format output(result) of method\r\n *\r\n * @method formatOutput\r\n * @param {Object}\r\n * @return {Object}\r\n */\n\n\nfunction formatOutput(result) {\n  var _this = this; // If outputFormatter is defined, calling outputFormatter,\n  // If not, just return original res.\n\n\n  var _formatOutput = function _formatOutput(res) {\n    return typeof _this.outputFormatter === 'function' ? _this.outputFormatter(res) : res;\n  }; // If result is array, map it through calling _formatOuput\n  // If result is single, just calling _formatOutput.\n\n\n  return _.isArray(result) ? result.map(_formatOutput) : _formatOutput(result);\n}\n/**\r\n * Should create payload from given input args\r\n *\r\n * @method toPayload\r\n * @param {Array} args\r\n * @return {Object}\r\n */\n\n\nfunction toPayload(args) {\n  var call = this.getCall(args);\n  var callback = this.extractCallback(args);\n  var inputParams = this.formatInput(args);\n  this.validateArgs(inputParams);\n  var payload = {\n    method: call,\n    params: inputParams,\n    callback: callback\n  }; // If payload transform option is existing, apply it.\n  // If not, just return payload.\n\n  return this.transformPayload && this.transformPayload(payload) || payload;\n}\n\nvar buildSendTxCallbackFunc = function buildSendTxCallbackFunc(defer, method, payload, isSendTx) {\n  return function (err, result) {\n    try {\n      result = method.formatOutput(result);\n    } catch (e) {\n      if (!err) err = e;\n    }\n\n    err = result instanceof Error && result || err; // If err exists, fireError\n\n    if (err) {\n      return utils._fireError(err.error || err, // sometimes, err.error property exists, in case, fire it instead 'err'\n      defer.eventEmitter, defer.reject, payload.callback);\n    } // fire callback\n\n\n    if (payload.callback) payload.callback(null, result); // return PROMISE\n\n    if (!isSendTx) {\n      defer.resolve(result);\n    } else {\n      defer.eventEmitter.emit('transactionHash', result);\n\n      method._confirmTransaction(defer, result, payload);\n    }\n  };\n};\n\nvar buildSendSignedTxFunc = function buildSendSignedTxFunc(method, payload, sendTxCallback) {\n  return function (signed) {\n    var rawTransaction = signed.rawTransaction ? signed.rawTransaction : signed;\n\n    var signedPayload = _.extend({}, payload, {\n      method: 'klay_sendRawTransaction',\n      params: [rawTransaction]\n    });\n\n    method.requestManager.send(signedPayload, sendTxCallback);\n  };\n};\n\nvar buildSendRequestFunc = function buildSendRequestFunc(defer, sendSignedTx, sendTxCallback) {\n  return function (payload, method) {\n    var methodName = payload.method; // Logic for handling multiple cases of parameters in sendSignedTransaction.\n    // 1. Object containing rawTransaction\n    //    : call 'klay_sendRawTransaction' with RLP encoded transaction(rawTransaction) in object\n    // 2. A transaction object containing signatures or feePayerSignatures\n    //    : call 'getRawTransactionWithSignatures', then call 'klay_sendRawTransaction' with result of getRawTransactionWithSignatures\n\n    if (method && methodName === 'klay_sendRawTransaction') {\n      // The existence of accounts in the method means the implementation before the common architecture.\n      if (method.accounts) {\n        var transaction = payload.params[0];\n\n        if (typeof transaction !== 'string' && _.isObject(transaction)) {\n          if (transaction.rawTransaction) {\n            return sendSignedTx(transaction);\n          }\n\n          return method.accounts.getRawTransactionWithSignatures(transaction).then(sendSignedTx).catch(function (e) {\n            sendTxCallback(e);\n          });\n        }\n      } else {\n        var _transaction = payload.params[0];\n\n        if (!_.isString(_transaction) && _.isObject(_transaction) && _.isFunction(_transaction.getRLPEncoding)) {\n          return sendSignedTx(_transaction.getRLPEncoding());\n        }\n      }\n    } // In the previous implementation of common architecture,\n    // if there was an account in the in-memory wallet before requesting to send or sign a transaction to the node,\n    // it was handled by using it.\n\n\n    if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n      switch (methodName) {\n        case 'klay_sendTransaction':\n          {\n            var tx = payload.params[0];\n            var error;\n\n            if (!_.isObject(tx)) {\n              sendTxCallback(new Error('The transaction must be defined as an object.'));\n              return;\n            }\n\n            var addressToUse = tx.from;\n\n            if (tx.senderRawTransaction && tx.feePayer) {\n              addressToUse = tx.feePayer;\n\n              if (tx.from) {\n                console.log('\"from\" is ignored for a fee-delegated transaction.');\n                delete tx.from;\n              }\n            }\n\n            var wallet;\n\n            try {\n              wallet = method.accounts.wallet.getAccount(addressToUse);\n            } catch (e) {\n              sendTxCallback(e);\n              return;\n            }\n\n            if (wallet && wallet.privateKey) {\n              var privateKey = method.accounts._getRoleKey(tx, wallet); // If wallet was found, sign tx, and send using sendRawTransaction\n\n\n              return method.accounts.signTransaction(tx, privateKey).then(sendSignedTx).catch(function (e) {\n                sendTxCallback(e);\n              });\n            }\n\n            if (tx.signatures) {\n              // If signatures is defined inside of the transaction object,\n              // get rawTransaction string from signed transaction object and send to network\n              return method.accounts.getRawTransactionWithSignatures(tx).then(sendSignedTx).catch(function (e) {\n                sendTxCallback(e);\n              });\n            } // If wallet was not found in caver-js wallet, then it has to use wallet in Node.\n            // Signing to transaction using wallet in Node supports only LEGACY transaction, so if transaction is not LEGACY, return error.\n\n\n            if (tx.feePayer !== undefined || tx.type !== undefined && tx.type !== 'LEGACY') {\n              error = new Error(\"No private key found in the caver-js wallet. Trying to use the Klaytn node's wallet, but it only supports legacy transactions. Please add private key of \".concat(addressToUse, \" to the caver-js wallet.\"));\n              sendTxCallback(error);\n              return;\n            }\n\n            error = validateParams(tx);\n\n            if (error) {\n              sendTxCallback(error);\n              return;\n            }\n\n            break;\n          }\n\n        case 'klay_sign':\n          {\n            var data = payload.params[1];\n\n            var _wallet = method.accounts.wallet.getAccount(payload.params[0]);\n\n            if (_wallet && _wallet.privateKey) {\n              // If wallet was found, sign tx, and send using sendRawTransaction\n              var sign = method.accounts.sign(data, _wallet.privateKey);\n              if (payload.callback) payload.callback(null, sign.signature);\n              defer.resolve(sign.signature);\n              return;\n            }\n\n            break;\n          }\n      }\n    } // When sending a request to send or sign a transaction using a key stored in a Klaytn node,\n    // the variable names inside the transaction must be properly formatted.\n    // { _from: '0x..', _signatures: ['0x..', '0x..', '0x..'] } -> { from: '0x..', signatures: { V: '0x..', R: '0x..', S: '0x..'} }\n\n\n    if (methodName.includes('sendTransaction') || methodName.includes('signTransaction')) {\n      var _tx = {};\n      Object.keys(payload.params[0]).map(function (k) {\n        var key = k;\n        if (key.startsWith('_')) key = key.slice(1);\n\n        if (key === 'signatures' || key === 'feePayerSignatures') {\n          if (!utils.isEmptySig(payload.params[0][key])) {\n            _tx[key] = utils.transformSignaturesToObject(payload.params[0][key]);\n\n            if (key === 'signatures' && (methodName === 'klay_signTransaction' || methodName === 'klay_sendTransaction')) {\n              console.warn(\"When sign/send a transaction using the Node API, existing 'signatures' can be initialized.\");\n            }\n\n            if (key === 'feePayerSignatures' && (methodName === 'klay_signTransactionAsFeePayer' || methodName === 'klay_sendTransactionAsFeePayer')) {\n              console.warn(\"When sign/send a transaction using the Node API, existing 'feePayerSignatures' can be initialized.\");\n            }\n          }\n        } else if (key === 'codeFormat') {\n          _tx[key] = utils.hexToNumber(payload.params[0][key]);\n        } else if (key === 'key' && _.isObject(payload.params[0][key])) {\n          // If key field is `AccountForUpdate`, resolve this to raw encoded account key string.\n          _tx.key = resolveRawKeyToAccountKey(payload.params[0]);\n        } else if (key === 'account') {\n          _tx.key = payload.params[0][key].getRLPEncodingAccountKey();\n        } else if (key === 'chainId') {\n          if (payload.params[0].type !== undefined && payload.params[0].type.includes('Ethereum')) {\n            _tx[key] = payload.params[0][key];\n          }\n        } else if (key === 'accessList') {\n          _tx[key] = payload.params[0][key].toObject();\n        } else if (payload.params[0][key] !== '0x') {\n          _tx[key] = payload.params[0][key];\n        }\n      });\n      payload.params[0] = _tx;\n    }\n\n    return method.requestManager.send(payload, sendTxCallback);\n  };\n};\n\nvar buildSendFunc = function buildSendFunc(method, isSendTx) {\n  return function () {\n    var defer = utils.promiEvent(!isSendTx);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var payload = method.toPayload(args);\n    var sendTxCallback = buildSendTxCallbackFunc(defer, method, payload, isSendTx);\n    var sendSignedTx = buildSendSignedTxFunc(method, payload, sendTxCallback);\n    var sendRequest = buildSendRequestFunc(defer, sendSignedTx, sendTxCallback); // isSendTx can determine only for \"send\"Transaction request.\n    // For sign transaction request, we also need to fill up the optional values.\n\n    var isSignTx = method.name.includes('signTransaction');\n    var isGasPriceInputMissing = false;\n\n    if ((isSendTx || isSignTx) && _.isObject(payload.params[0]) && payload.params[0].gasPrice === undefined) {\n      isGasPriceInputMissing = true;\n    } // The TxTypeEthereumDynamicFee transaction does not use the gasPrice field,\n    // so we need to check `maxPriorityFeePerGas` and `maxFeePerGas` field instead of `gasPrice`.\n\n\n    var isDynamicFeeTx = (isSendTx || isSignTx) && payload.params[0].type === TX_TYPE_STRING.TxTypeEthereumDynamicFee;\n    var filledDynamicGasFeeTx = isDynamicFeeTx && payload.params[0].maxPriorityFeePerGas !== undefined && payload.params[0].maxFeePerGas !== undefined; // gasPrice is already set so it is ok to send transaction.\n\n    if (!isGasPriceInputMissing || filledDynamicGasFeeTx) {\n      sendRequest(payload, method);\n      return defer.eventEmitter;\n    } // gasPrice is missing, have to fill gasPrice field before sending tx\n\n\n    var getGasPrice = new Method({\n      name: 'getGasPrice',\n      call: 'klay_gasPrice',\n      params: 0\n    }).createFunction(method.requestManager);\n    var getMaxPriorityFeePerGas = new Method({\n      name: 'getMaxPriorityFeePerGas',\n      call: 'klay_maxPriorityFeePerGas',\n      params: 0\n    }).createFunction(method.requestManager); // `klay_gasPrice` returns a suggestion of gas price.\n    // So using this value in gasPrice field (or maxFeePerGas).\n\n    getGasPrice(function (err, gp) {\n      // The TxTypeEthereumDynamicFee transaction does not use the gasPrice field,\n      // so the gas price default is not set for TxTypeEthereumDynamicFee.\n      if (!isDynamicFeeTx) {\n        payload.params[0].gasPrice = payload.params[0].gasPrice || gp;\n      } else {\n        payload.params[0].maxFeePerGas = payload.params[0].maxFeePerGas || gp; // If maxPriorityFeePerGas is undefined, call `klay_maxPriorityFeePerGas`.\n\n        if (payload.params[0].maxPriorityFeePerGas === undefined) {\n          return getMaxPriorityFeePerGas(function (e, maxPriorityFeePerGas) {\n            payload.params[0].maxPriorityFeePerGas = maxPriorityFeePerGas; // Format gas price parameters(gasPrice, maxPriorityFeePerGas, maxFeePerGas)\n\n            formatGasParametersToHex(payload.params[0]);\n            sendRequest(payload, method);\n          });\n        }\n      } // Format gas price parameters(gasPrice, maxPriorityFeePerGas, maxFeePerGas)\n\n\n      formatGasParametersToHex(payload.params[0]);\n      sendRequest(payload, method);\n    });\n    /**\r\n     * attaching `.on('receipt')` is possible by returning defer.eventEmitter\r\n     */\n\n    return defer.eventEmitter;\n  };\n}; // A function to change the format to a hex string after randomly filling the default gasPrice value\n// with the API (personal_sendValueTransfer, personal_sendAccountUpdate) that does not use a transaction object.\n\n\nfunction formatGasParametersToHex(txObject) {\n  if (txObject.gasPrice !== undefined && !utils.isHexStrict(txObject.gasPrice)) {\n    txObject.gasPrice = utils.toHex(txObject.gasPrice);\n  }\n\n  if (txObject.maxPriorityFeePerGas !== undefined && !utils.isHexStrict(txObject.maxPriorityFeePerGas)) {\n    txObject.maxPriorityFeePerGas = utils.toHex(txObject.maxPriorityFeePerGas);\n  }\n\n  if (txObject.maxFeePerGas !== undefined && !utils.isHexStrict(txObject.maxFeePerGas)) {\n    txObject.maxFeePerGas = utils.toHex(txObject.maxFeePerGas);\n  }\n}\n\nfunction buildCall() {\n  var method = this;\n  var isSendTx = method.call === 'klay_sendTransaction' || method.call === 'klay_sendTransactionAsFeePayer' || method.call === 'klay_sendRawTransaction' || method.call === 'personal_sendTransaction' || method.call === 'personal_sendValueTransfer' || method.call === 'personal_sendAccountUpdate';\n  var send = buildSendFunc(method, isSendTx); // necessary to attach things to the method\n\n  send.method = method; // necessary for batch requests\n\n  send.request = this.request.bind(this);\n  return send;\n}\n\nfunction _confirmTransaction(defer, result, payload) {\n  var payloadTxObject = payload.params && _.isObject(payload.params[0]) && payload.params[0] || {}; // If payload.params[0] is RLP-encoded string, decode RLP-encoded string to Transaction instance.\n\n  if (_.isString(payload.params[0])) payloadTxObject = TransactionDecoder.decode(payload.params[0]); // mutableConfirmationPack will be used in\n  // 1) checkConfirmation,\n  // 2) startWatching functions\n  // It is * mutable *, both functions can affect properties mutably.\n\n  var mutableConfirmationPack = {\n    method: this,\n    promiseResolved: false,\n    canUnsubscribe: true,\n    timeoutCount: 0,\n    intervalId: null,\n    gasProvided: payloadTxObject.gas || null,\n    isContractDeployment: utils.isContractDeployment(payloadTxObject),\n    defer: defer,\n    result: result,\n    _klaytnCall: {}\n  };\n  addCustomSendMethod(mutableConfirmationPack);\n  kickoffConfirmation(mutableConfirmationPack);\n}\n\nvar addCustomSendMethod = function addCustomSendMethod(mutableConfirmationPack) {\n  var customSendMethods = [new Method({\n    name: 'getTransactionReceipt',\n    call: 'klay_getTransactionReceipt',\n    params: 1,\n    outputFormatter: !mutableConfirmationPack.method.outputFormatterDisable ? formatters.outputTransactionReceiptFormatter : undefined\n  }), new Method({\n    name: 'getCode',\n    call: 'klay_getCode',\n    params: 2,\n    inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n  }), new Subscriptions({\n    name: 'subscribe',\n    type: 'klay',\n    subscriptions: {\n      newBlockHeaders: {\n        subscriptionName: 'newHeads',\n        // replace subscription with this name\n        params: 0,\n        outputFormatter: formatters.outputBlockFormatter\n      }\n    }\n  })]; // add custom send Methods\n\n  _.each(customSendMethods, function (mthd) {\n    // attach methods to _klaytnCall\n    mthd.attachToObject(mutableConfirmationPack._klaytnCall); // assign rather than call setRequestManager()\n\n    mthd.requestManager = mutableConfirmationPack.method.requestManager;\n  });\n};\n\nvar kickoffConfirmation = function kickoffConfirmation(mutableConfirmationPack) {\n  // eslint-disable-next-line no-unused-vars\n  var defer = mutableConfirmationPack.defer,\n      promiseResolved = mutableConfirmationPack.promiseResolved,\n      result = mutableConfirmationPack.result,\n      _klaytnCall = mutableConfirmationPack._klaytnCall; // first check if we already have a confirmed transaction\n\n  _klaytnCall.getTransactionReceipt(result).then(function (receipt) {\n    if (receipt && receipt.blockHash) {\n      // `isPolling` is false in default.\n      checkConfirmation(mutableConfirmationPack, receipt, false);\n    } else if (!promiseResolved) startWatching(mutableConfirmationPack, receipt);\n  }).catch(function () {\n    if (!promiseResolved) startWatching(mutableConfirmationPack);\n  });\n}; // start watching for confirmation depending on the support features of the provider\n\n\nvar startWatching = function startWatching(mutableConfirmationPack, existingReceipt) {\n  // eslint-disable-next-line no-unused-vars\n  var _klaytnCall = mutableConfirmationPack._klaytnCall,\n      intervalId = mutableConfirmationPack.intervalId,\n      method = mutableConfirmationPack.method; // if provider allows PUB/SUB\n\n  if (method.requestManager.provider.supportsSubscriptions()) {\n    _klaytnCall.subscribe('newBlockHeaders', checkConfirmation.bind(null, mutableConfirmationPack, existingReceipt, false));\n  } else {\n    mutableConfirmationPack.intervalId = setInterval(checkConfirmation.bind(null, mutableConfirmationPack, existingReceipt, true), 1000);\n  }\n}; // fire \"receipt\" and confirmation events and resolve after\n\n\nvar checkConfirmation = function checkConfirmation(mutableConfirmationPack, existingReceipt, isPolling, err, blockHeader, sub) {\n  var intervalId = mutableConfirmationPack.intervalId,\n      defer = mutableConfirmationPack.defer,\n      method = mutableConfirmationPack.method,\n      canUnsubscribe = mutableConfirmationPack.canUnsubscribe,\n      _klaytnCall = mutableConfirmationPack._klaytnCall,\n      isContractDeployment = mutableConfirmationPack.isContractDeployment,\n      promiseResolved = mutableConfirmationPack.promiseResolved,\n      timeoutCount = mutableConfirmationPack.timeoutCount,\n      result = mutableConfirmationPack.result;\n\n  if (err) {\n    sub.unsubscribe();\n    mutableConfirmationPack.promiseResolved = true;\n\n    utils._fireError({\n      message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\n      data: err\n    }, defer.eventEmitter, defer.reject);\n\n    return;\n  } // create fake unsubscribe\n\n\n  sub = sub || {\n    unsubscribe: function unsubscribe() {\n      return clearInterval(mutableConfirmationPack.intervalId);\n    }\n  }; // if we have a valid receipt we don't need to send a request\n\n  return (existingReceipt && utils.promiEvent.resolve(existingReceipt) || _klaytnCall.getTransactionReceipt(result) // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n  ).then(function (receipt) {\n    checkIsReceiptInBlock(receipt);\n    var formattedReceipt = formatReceipt(receipt, method);\n    if (mutableConfirmationPack.promiseResolved) return;\n    return isContractDeployment ? checkForContractDeployment(mutableConfirmationPack, formattedReceipt, sub) : checkForNormalTx(mutableConfirmationPack, formattedReceipt, sub);\n  }).catch(countTimeout);\n};\n\nvar checkIsReceiptInBlock = function checkIsReceiptInBlock(receipt) {\n  if (receipt && !receipt.blockHash) throw errors.blockHashNull;\n};\n\nvar formatReceipt = function formatReceipt(receipt, method) {\n  if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n    receipt = method.extraFormatters.receiptFormatter(receipt);\n  }\n\n  return receipt;\n};\n\nvar countTimeout = function countTimeout(mutableConfirmationPack, isPolling, sub) {\n  // eslint-disable-next-line no-unused-vars\n  var defer = mutableConfirmationPack.defer,\n      timeoutCount = mutableConfirmationPack.timeoutCount,\n      promiseResolved = mutableConfirmationPack.promiseResolved; // time out the transaction if not mined after 50 blocks\n\n  mutableConfirmationPack.timeoutCount++; // check to see if we are http polling\n\n  if (isPolling) {\n    // polling timeout is different than TIMEOUTBLOCK blocks since we are triggering every second\n    if (mutableConfirmationPack.timeoutCount - 1 >= POLLINGTIMEOUT) {\n      sub.unsubscribe();\n      mutableConfirmationPack.promiseResolved = true;\n\n      utils._fireError(new Error(\"Transaction was not mined within\".concat(POLLINGTIMEOUT, \" seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!\")), defer.eventEmitter, defer.reject);\n    }\n  } else if (mutableConfirmationPack.timeoutCount - 1 >= TIMEOUTBLOCK) {\n    sub.unsubscribe();\n    mutableConfirmationPack.promiseResolved = true;\n\n    utils._fireError(new Error('Transaction was not mined within 50 blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n  }\n};\n\nvar checkForContractDeployment = function checkForContractDeployment(mutableConfirmationPack, receipt, sub) {\n  // eslint-disable-next-line no-unused-vars\n  var defer = mutableConfirmationPack.defer,\n      method = mutableConfirmationPack.method,\n      canUnsubscribe = mutableConfirmationPack.canUnsubscribe,\n      _klaytnCall = mutableConfirmationPack._klaytnCall,\n      promiseResolved = mutableConfirmationPack.promiseResolved; // If contract address doesn't exist, fire error.\n\n  if (!receipt.contractAddress) {\n    if (canUnsubscribe) {\n      sub.unsubscribe();\n      mutableConfirmationPack.promiseResolved = true;\n    }\n\n    utils._fireError(errors.receiptDidntContainContractAddress, defer.eventEmitter, defer.reject);\n\n    return;\n  }\n\n  if (!receipt.status && receipt.txError) {\n    var receiptJSON = JSON.stringify(receipt, null, 2);\n\n    utils._fireError(new Error(\"\".concat(errors.txErrorTable[receipt.txError], \"\\n \").concat(receiptJSON)), defer.eventEmitter, defer.reject);\n  }\n\n  _klaytnCall.getCode(receipt.contractAddress, function (e, code) {\n    if (!code) return;\n    defer.eventEmitter.emit('receipt', receipt); // if contract, return instance instead of receipt\n\n    defer.resolve(method.extraFormatters && method.extraFormatters.contractDeployFormatter && method.extraFormatters.contractDeployFormatter(receipt) || receipt); // need to remove listeners, as they aren't removed automatically when succesfull\n\n    if (canUnsubscribe) defer.eventEmitter.removeAllListeners();\n    if (canUnsubscribe) sub.unsubscribe();\n    mutableConfirmationPack.promiseResolved = true;\n  });\n\n  return receipt;\n};\n\nvar checkForNormalTx = function checkForNormalTx(mutableConfirmationPack, receipt, sub) {\n  // eslint-disable-next-line no-unused-vars\n  var defer = mutableConfirmationPack.defer,\n      canUnsubscribe = mutableConfirmationPack.canUnsubscribe,\n      promiseResolved = mutableConfirmationPack.promiseResolved,\n      gasProvided = mutableConfirmationPack.gasProvided;\n\n  if (receipt && !receipt.outOfGas && (!gasProvided || gasProvided !== receipt.gasUsed) && (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {\n    // Happy case: transaction is processed well. A.K.A 'well-done receipt'.\n    try {\n      mutableConfirmationPack.defer.eventEmitter.emit('receipt', receipt);\n      mutableConfirmationPack.defer.resolve(receipt);\n    } catch (e) {\n      console.log('receipt error', e);\n    } // need to remove listeners, as they aren't removed automatically when succesfull\n\n\n    if (canUnsubscribe) {\n      mutableConfirmationPack.defer.eventEmitter.removeAllListeners();\n    }\n  } else {\n    // Unhappy case: trasaction has error. A.K.A 'bad receipt'.\n    if (!receipt) return;\n    var receiptJSON = JSON.stringify(receipt, null, 2);\n    var txError = receipt.txError;\n\n    if (txError && errors.txErrorTable[txError]) {\n      utils._fireError(new Error(\"\".concat(errors.txErrorTable[txError], \"\\n \").concat(receiptJSON)), mutableConfirmationPack.defer.eventEmitter, mutableConfirmationPack.defer.reject);\n    } else if (receipt.status === false || receipt.status === '0x0') {\n      utils._fireError(errors.transactionReverted(receiptJSON), mutableConfirmationPack.defer.eventEmitter, mutableConfirmationPack.defer.reject);\n    } else if (receipt.gasUsed >= gasProvided) {\n      utils._fireError(errors.transactionRanOutOfGas(receiptJSON), mutableConfirmationPack.defer.eventEmitter, mutableConfirmationPack.defer.reject);\n    } else {\n      utils._fireError(errors.transactionRanOutOfGas(receiptJSON), mutableConfirmationPack.defer.eventEmitter, mutableConfirmationPack.defer.reject);\n    }\n  }\n\n  if (canUnsubscribe) sub.unsubscribe();\n  mutableConfirmationPack.promiseResolved = true;\n};\n/**\r\n * Should be called to create the pure JSONRPC request which can be used in a batch request\r\n *\r\n * @method request\r\n * @return {Object} jsonrpc request\r\n */\n\n\nfunction request() {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  var payload = this.toPayload(args);\n  payload.format = this.formatOutput.bind(this);\n  return payload;\n}\n\nmodule.exports = Method;","map":{"version":3,"names":["_","require","errors","formatters","utils","Subscriptions","subscriptions","validateParams","validateFunction","TIMEOUTBLOCK","AVERAGE_BLOCK_TIME","POLLINGTIMEOUT","TransactionDecoder","TX_TYPE_STRING","resolveRawKeyToAccountKey","Method","options","call","name","needNameCallPropertyToCreateMethod","hexCall","params","inputFormatter","outputFormatter","transformPayload","extraFormatters","requestManager","accounts","defaultBlock","defaultAccount","outputFormatterDisable","prototype","setRequestManager","createFunction","attachToObject","getCall","extractCallback","validateArgs","formatInput","formatOutput","toPayload","buildCall","_confirmTransaction","request","func","obj","split","callName","optionalName","getMethod","args","isHexParameter","isFunction","length","pop","InvalidNumberOfParams","_this","isEmpty","map","formatter","index","formattedInput","result","_formatOutput","res","isArray","callback","inputParams","payload","method","buildSendTxCallbackFunc","defer","isSendTx","err","e","Error","_fireError","error","eventEmitter","reject","resolve","emit","buildSendSignedTxFunc","sendTxCallback","signed","rawTransaction","signedPayload","extend","send","buildSendRequestFunc","sendSignedTx","methodName","transaction","isObject","getRawTransactionWithSignatures","then","catch","isString","getRLPEncoding","wallet","tx","addressToUse","from","senderRawTransaction","feePayer","console","log","getAccount","privateKey","_getRoleKey","signTransaction","signatures","undefined","type","data","sign","signature","includes","Object","keys","k","key","startsWith","slice","isEmptySig","transformSignaturesToObject","warn","hexToNumber","getRLPEncodingAccountKey","toObject","buildSendFunc","promiEvent","sendRequest","isSignTx","isGasPriceInputMissing","gasPrice","isDynamicFeeTx","TxTypeEthereumDynamicFee","filledDynamicGasFeeTx","maxPriorityFeePerGas","maxFeePerGas","getGasPrice","getMaxPriorityFeePerGas","gp","formatGasParametersToHex","txObject","isHexStrict","toHex","bind","payloadTxObject","decode","mutableConfirmationPack","promiseResolved","canUnsubscribe","timeoutCount","intervalId","gasProvided","gas","isContractDeployment","_klaytnCall","addCustomSendMethod","kickoffConfirmation","customSendMethods","outputTransactionReceiptFormatter","inputAddressFormatter","inputDefaultBlockNumberFormatter","newBlockHeaders","subscriptionName","outputBlockFormatter","each","mthd","getTransactionReceipt","receipt","blockHash","checkConfirmation","startWatching","existingReceipt","provider","supportsSubscriptions","subscribe","setInterval","isPolling","blockHeader","sub","unsubscribe","message","clearInterval","checkIsReceiptInBlock","formattedReceipt","formatReceipt","checkForContractDeployment","checkForNormalTx","countTimeout","blockHashNull","receiptFormatter","contractAddress","receiptDidntContainContractAddress","status","txError","receiptJSON","JSON","stringify","txErrorTable","getCode","code","contractDeployFormatter","removeAllListeners","outOfGas","gasUsed","transactionReverted","transactionRanOutOfGas","format","module","exports"],"sources":["C:/Users/User/Documents/clone-starter-kit-08/node_modules/caver-js/packages/caver-core-method/src/index.js"],"sourcesContent":["/*\r\n    Modifications copyright 2018 The caver-js Authors\r\n    This file is part of web3.js.\r\n\r\n    web3.js is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    web3.js is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n    This file is derived from web3.js/packages/web3-core-method/src/index.js (2019/06/12).\r\n    Modified and improved for the caver-js development.\r\n*/\r\n/**\r\n * @file index.js\r\n * @author Fabian Vogelsteller <fabian@ethereum.org>\r\n * @author Marek Kotewicz <marek@parity.io>\r\n * @date 2017\r\n */\r\n\r\nconst _ = require('lodash')\r\nconst errors = require('../../caver-core-helpers').errors\r\nconst formatters = require('../../caver-core-helpers').formatters\r\nconst utils = require('../../caver-utils')\r\nconst Subscriptions = require('../../caver-core-subscriptions').subscriptions\r\nconst validateParams = require('../../caver-core-helpers').validateFunction.validateParams\r\n\r\nconst TIMEOUTBLOCK = 50\r\nconst AVERAGE_BLOCK_TIME = 1 // 1s\r\nconst POLLINGTIMEOUT = AVERAGE_BLOCK_TIME * TIMEOUTBLOCK // ~average block time (seconds) * TIMEOUTBLOCK\r\n\r\nconst TransactionDecoder = require('../../caver-transaction/src/transactionDecoder/transactionDecoder')\r\nconst { TX_TYPE_STRING } = require('../../caver-transaction/src/transactionHelper/transactionHelper')\r\nconst { resolveRawKeyToAccountKey } = require('../../caver-klay/caver-klay-accounts/src/transactionType/account')\r\n\r\nfunction Method(options) {\r\n    // call, name should be existed to create a method.\r\n    if (!options.call || !options.name) throw errors.needNameCallPropertyToCreateMethod\r\n\r\n    this.name = options.name\r\n    this.call = options.call\r\n    this.hexCall = options.hexCall\r\n    this.params = options.params || 0\r\n    this.inputFormatter = options.inputFormatter || []\r\n    this.outputFormatter = options.outputFormatter\r\n    this.transformPayload = options.transformPayload\r\n    this.extraFormatters = options.extraFormatters\r\n\r\n    this.requestManager = options.requestManager\r\n\r\n    // reference to klay.accounts\r\n    this.accounts = options.accounts\r\n\r\n    this.defaultBlock = options.defaultBlock || 'latest'\r\n    this.defaultAccount = options.defaultAccount || null\r\n\r\n    this.outputFormatterDisable = options.outputFormatterDisable\r\n}\r\n\r\nMethod.prototype.setRequestManager = setRequestManager\r\nMethod.prototype.createFunction = createFunction\r\nMethod.prototype.attachToObject = attachToObject\r\nMethod.prototype.getCall = getCall\r\nMethod.prototype.extractCallback = extractCallback\r\nMethod.prototype.validateArgs = validateArgs\r\nMethod.prototype.formatInput = formatInput\r\nMethod.prototype.formatOutput = formatOutput\r\nMethod.prototype.toPayload = toPayload\r\nMethod.prototype.buildCall = buildCall\r\nMethod.prototype._confirmTransaction = _confirmTransaction\r\nMethod.prototype.request = request\r\n\r\n/**\r\n * Set requestManager for rpc calling.\r\n * If it has accounts parameter also, set it.\r\n * @method setRequestManager\r\n * @param  {Object} requestManager\r\n * @param  {Object} accounts\r\n */\r\nfunction setRequestManager(requestManager, accounts) {\r\n    this.requestManager = requestManager\r\n\r\n    // reference to klay.accounts\r\n    if (accounts) this.accounts = accounts\r\n}\r\n\r\n/**\r\n * createFunction through 'this' context (= instance by created through new Method(...))\r\n * @method createFunction\r\n * @param  {Object} requestManager\r\n * @param  {Object} accounts\r\n * @return {Function} it will be used for sending RPC call.\r\n */\r\nfunction createFunction(requestManager, accounts) {\r\n    // set requestManager for method individulally.\r\n    this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts)\r\n\r\n    // this.buildCall() returns function `send = function() { ... }`\r\n    const func = this.buildCall()\r\n\r\n    // call is directly used for rpc calling,\r\n    // ex) 'klay_sendTransaction'\r\n    func.call = this.call\r\n\r\n    return func\r\n}\r\n\r\n/**\r\n * attach buildCalled method to 'obj' object,\r\n * by adding a property name through this.name\r\n * @method attachToObject\r\n * @param  {Object} obj\r\n */\r\nfunction attachToObject(obj) {\r\n    const func = this.buildCall()\r\n    func.call = this.call\r\n    const [callName, optionalName] = this.name.split('.')\r\n\r\n    if (optionalName) {\r\n        obj[callName] = obj[callName] || {}\r\n        obj[callName][optionalName] = func\r\n        obj[callName][optionalName].getMethod = () => this\r\n    } else {\r\n        obj[callName] = func\r\n        obj[callName].getMethod = () => this\r\n    }\r\n}\r\n\r\n/**\r\n * Should be used to determine name of the jsonrpc method based on arguments\r\n *\r\n * @method getCall\r\n * @param {Array} arguments\r\n * @return {String} name of jsonrpc method\r\n */\r\nfunction getCall(args) {\r\n    // If hexCall is defined, args[0] type is truly hexParameter, return this.hexCall\r\n    // If not, return this.call\r\n    // 'this.call', 'this.hexCall' are defined in rpc.json\r\n    return this.hexCall && utils.isHexParameter(args[0]) ? this.hexCall : this.call\r\n}\r\n\r\n/**\r\n * Should be used to extract callback from array of arguments.\r\n * (caution) It modifies input param.\r\n *\r\n * @method extractCallback\r\n * @param {Array} arguments\r\n * @return {Function|Null} callback, if exists\r\n */\r\nfunction extractCallback(args) {\r\n    if (_.isFunction(args[args.length - 1])) {\r\n        return args.pop() // 'pop' method modifies the original args array!\r\n    }\r\n}\r\n\r\n/**\r\n * Should be called to check if the number of arguments is correct\r\n *\r\n * @method validateArgs\r\n * @param {Array} arguments\r\n * @throws {Error} if it is not\r\n */\r\nfunction validateArgs(args) {\r\n    if (args.length !== this.params) {\r\n        throw errors.InvalidNumberOfParams(args.length, this.params, this.name)\r\n    }\r\n}\r\n\r\n/**\r\n * Should be called to format input args of method\r\n *\r\n * @method formatInput\r\n * @param {Array}\r\n * @return {Array}\r\n */\r\nfunction formatInput(args) {\r\n    const _this = this\r\n\r\n    // If inputFormatter is not defined, or empty just return original args.\r\n    if (!this.inputFormatter || _.isEmpty(this.inputFormatter)) {\r\n        return args\r\n    }\r\n\r\n    // If inputFormatter is defined, map original args by calling formatter.\r\n    return this.inputFormatter.map((formatter, index) => {\r\n        // bind this for defaultBlock, and defaultAccount\r\n        let formattedInput = args[index]\r\n        if (formatter) {\r\n            formattedInput = formatter.call(_this, args[index])\r\n        }\r\n        return formattedInput\r\n    })\r\n}\r\n\r\n/**\r\n * Should be called to format output(result) of method\r\n *\r\n * @method formatOutput\r\n * @param {Object}\r\n * @return {Object}\r\n */\r\nfunction formatOutput(result) {\r\n    const _this = this\r\n\r\n    // If outputFormatter is defined, calling outputFormatter,\r\n    // If not, just return original res.\r\n    const _formatOutput = res => (typeof _this.outputFormatter === 'function' ? _this.outputFormatter(res) : res)\r\n\r\n    // If result is array, map it through calling _formatOuput\r\n    // If result is single, just calling _formatOutput.\r\n    return _.isArray(result) ? result.map(_formatOutput) : _formatOutput(result)\r\n}\r\n\r\n/**\r\n * Should create payload from given input args\r\n *\r\n * @method toPayload\r\n * @param {Array} args\r\n * @return {Object}\r\n */\r\nfunction toPayload(args) {\r\n    const call = this.getCall(args)\r\n    const callback = this.extractCallback(args)\r\n    const inputParams = this.formatInput(args)\r\n    this.validateArgs(inputParams)\r\n\r\n    const payload = {\r\n        method: call,\r\n        params: inputParams,\r\n        callback,\r\n    }\r\n\r\n    // If payload transform option is existing, apply it.\r\n    // If not, just return payload.\r\n    return (this.transformPayload && this.transformPayload(payload)) || payload\r\n}\r\n\r\nconst buildSendTxCallbackFunc = (defer, method, payload, isSendTx) => (err, result) => {\r\n    try {\r\n        result = method.formatOutput(result)\r\n    } catch (e) {\r\n        if (!err) err = e\r\n    }\r\n\r\n    err = (result instanceof Error && result) || err\r\n\r\n    // If err exists, fireError\r\n    if (err) {\r\n        return utils._fireError(\r\n            err.error || err, // sometimes, err.error property exists, in case, fire it instead 'err'\r\n            defer.eventEmitter,\r\n            defer.reject,\r\n            payload.callback\r\n        )\r\n    }\r\n\r\n    // fire callback\r\n    if (payload.callback) payload.callback(null, result)\r\n\r\n    // return PROMISE\r\n    if (!isSendTx) {\r\n        defer.resolve(result)\r\n    } else {\r\n        defer.eventEmitter.emit('transactionHash', result)\r\n        method._confirmTransaction(defer, result, payload)\r\n    }\r\n}\r\n\r\nconst buildSendSignedTxFunc = (method, payload, sendTxCallback) => signed => {\r\n    const rawTransaction = signed.rawTransaction ? signed.rawTransaction : signed\r\n    const signedPayload = _.extend({}, payload, {\r\n        method: 'klay_sendRawTransaction',\r\n        params: [rawTransaction],\r\n    })\r\n\r\n    method.requestManager.send(signedPayload, sendTxCallback)\r\n}\r\n\r\nconst buildSendRequestFunc = (defer, sendSignedTx, sendTxCallback) => (payload, method) => {\r\n    const methodName = payload.method\r\n    // Logic for handling multiple cases of parameters in sendSignedTransaction.\r\n    // 1. Object containing rawTransaction\r\n    //    : call 'klay_sendRawTransaction' with RLP encoded transaction(rawTransaction) in object\r\n    // 2. A transaction object containing signatures or feePayerSignatures\r\n    //    : call 'getRawTransactionWithSignatures', then call 'klay_sendRawTransaction' with result of getRawTransactionWithSignatures\r\n    if (method && methodName === 'klay_sendRawTransaction') {\r\n        // The existence of accounts in the method means the implementation before the common architecture.\r\n        if (method.accounts) {\r\n            const transaction = payload.params[0]\r\n            if (typeof transaction !== 'string' && _.isObject(transaction)) {\r\n                if (transaction.rawTransaction) {\r\n                    return sendSignedTx(transaction)\r\n                }\r\n                return method.accounts\r\n                    .getRawTransactionWithSignatures(transaction)\r\n                    .then(sendSignedTx)\r\n                    .catch(e => {\r\n                        sendTxCallback(e)\r\n                    })\r\n            }\r\n        } else {\r\n            const transaction = payload.params[0]\r\n            if (!_.isString(transaction) && _.isObject(transaction) && _.isFunction(transaction.getRLPEncoding)) {\r\n                return sendSignedTx(transaction.getRLPEncoding())\r\n            }\r\n        }\r\n    }\r\n\r\n    // In the previous implementation of common architecture,\r\n    // if there was an account in the in-memory wallet before requesting to send or sign a transaction to the node,\r\n    // it was handled by using it.\r\n    if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\r\n        switch (methodName) {\r\n            case 'klay_sendTransaction': {\r\n                const tx = payload.params[0]\r\n\r\n                let error\r\n                if (!_.isObject(tx)) {\r\n                    sendTxCallback(new Error('The transaction must be defined as an object.'))\r\n                    return\r\n                }\r\n\r\n                let addressToUse = tx.from\r\n\r\n                if (tx.senderRawTransaction && tx.feePayer) {\r\n                    addressToUse = tx.feePayer\r\n                    if (tx.from) {\r\n                        console.log('\"from\" is ignored for a fee-delegated transaction.')\r\n                        delete tx.from\r\n                    }\r\n                }\r\n\r\n                let wallet\r\n\r\n                try {\r\n                    wallet = method.accounts.wallet.getAccount(addressToUse)\r\n                } catch (e) {\r\n                    sendTxCallback(e)\r\n                    return\r\n                }\r\n\r\n                if (wallet && wallet.privateKey) {\r\n                    const privateKey = method.accounts._getRoleKey(tx, wallet)\r\n                    // If wallet was found, sign tx, and send using sendRawTransaction\r\n                    return method.accounts\r\n                        .signTransaction(tx, privateKey)\r\n                        .then(sendSignedTx)\r\n                        .catch(e => {\r\n                            sendTxCallback(e)\r\n                        })\r\n                }\r\n                if (tx.signatures) {\r\n                    // If signatures is defined inside of the transaction object,\r\n                    // get rawTransaction string from signed transaction object and send to network\r\n                    return method.accounts\r\n                        .getRawTransactionWithSignatures(tx)\r\n                        .then(sendSignedTx)\r\n                        .catch(e => {\r\n                            sendTxCallback(e)\r\n                        })\r\n                }\r\n\r\n                // If wallet was not found in caver-js wallet, then it has to use wallet in Node.\r\n                // Signing to transaction using wallet in Node supports only LEGACY transaction, so if transaction is not LEGACY, return error.\r\n                if (tx.feePayer !== undefined || (tx.type !== undefined && tx.type !== 'LEGACY')) {\r\n                    error = new Error(\r\n                        `No private key found in the caver-js wallet. Trying to use the Klaytn node's wallet, but it only supports legacy transactions. Please add private key of ${addressToUse} to the caver-js wallet.`\r\n                    )\r\n                    sendTxCallback(error)\r\n                    return\r\n                }\r\n\r\n                error = validateParams(tx)\r\n                if (error) {\r\n                    sendTxCallback(error)\r\n                    return\r\n                }\r\n                break\r\n            }\r\n            case 'klay_sign': {\r\n                const data = payload.params[1]\r\n                const wallet = method.accounts.wallet.getAccount(payload.params[0])\r\n\r\n                if (wallet && wallet.privateKey) {\r\n                    // If wallet was found, sign tx, and send using sendRawTransaction\r\n                    const sign = method.accounts.sign(data, wallet.privateKey)\r\n\r\n                    if (payload.callback) payload.callback(null, sign.signature)\r\n\r\n                    defer.resolve(sign.signature)\r\n                    return\r\n                }\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n    // When sending a request to send or sign a transaction using a key stored in a Klaytn node,\r\n    // the variable names inside the transaction must be properly formatted.\r\n    // { _from: '0x..', _signatures: ['0x..', '0x..', '0x..'] } -> { from: '0x..', signatures: { V: '0x..', R: '0x..', S: '0x..'} }\r\n    if (methodName.includes('sendTransaction') || methodName.includes('signTransaction')) {\r\n        const tx = {}\r\n        Object.keys(payload.params[0]).map(k => {\r\n            let key = k\r\n            if (key.startsWith('_')) key = key.slice(1)\r\n            if (key === 'signatures' || key === 'feePayerSignatures') {\r\n                if (!utils.isEmptySig(payload.params[0][key])) {\r\n                    tx[key] = utils.transformSignaturesToObject(payload.params[0][key])\r\n\r\n                    if (key === 'signatures' && (methodName === 'klay_signTransaction' || methodName === 'klay_sendTransaction')) {\r\n                        console.warn(`When sign/send a transaction using the Node API, existing 'signatures' can be initialized.`)\r\n                    }\r\n\r\n                    if (\r\n                        key === 'feePayerSignatures' &&\r\n                        (methodName === 'klay_signTransactionAsFeePayer' || methodName === 'klay_sendTransactionAsFeePayer')\r\n                    ) {\r\n                        console.warn(`When sign/send a transaction using the Node API, existing 'feePayerSignatures' can be initialized.`)\r\n                    }\r\n                }\r\n            } else if (key === 'codeFormat') {\r\n                tx[key] = utils.hexToNumber(payload.params[0][key])\r\n            } else if (key === 'key' && _.isObject(payload.params[0][key])) {\r\n                // If key field is `AccountForUpdate`, resolve this to raw encoded account key string.\r\n                tx.key = resolveRawKeyToAccountKey(payload.params[0])\r\n            } else if (key === 'account') {\r\n                tx.key = payload.params[0][key].getRLPEncodingAccountKey()\r\n            } else if (key === 'chainId') {\r\n                if (payload.params[0].type !== undefined && payload.params[0].type.includes('Ethereum')) {\r\n                    tx[key] = payload.params[0][key]\r\n                }\r\n            } else if (key === 'accessList') {\r\n                tx[key] = payload.params[0][key].toObject()\r\n            } else if (payload.params[0][key] !== '0x') {\r\n                tx[key] = payload.params[0][key]\r\n            }\r\n        })\r\n        payload.params[0] = tx\r\n    }\r\n\r\n    return method.requestManager.send(payload, sendTxCallback)\r\n}\r\n\r\nconst buildSendFunc = (method, isSendTx) => (...args) => {\r\n    const defer = utils.promiEvent(!isSendTx)\r\n    const payload = method.toPayload(args)\r\n\r\n    const sendTxCallback = buildSendTxCallbackFunc(defer, method, payload, isSendTx)\r\n    const sendSignedTx = buildSendSignedTxFunc(method, payload, sendTxCallback)\r\n    const sendRequest = buildSendRequestFunc(defer, sendSignedTx, sendTxCallback)\r\n\r\n    // isSendTx can determine only for \"send\"Transaction request.\r\n    // For sign transaction request, we also need to fill up the optional values.\r\n    const isSignTx = method.name.includes('signTransaction')\r\n    let isGasPriceInputMissing = false\r\n    if ((isSendTx || isSignTx) && _.isObject(payload.params[0]) && payload.params[0].gasPrice === undefined) {\r\n        isGasPriceInputMissing = true\r\n    }\r\n\r\n    // The TxTypeEthereumDynamicFee transaction does not use the gasPrice field,\r\n    // so we need to check `maxPriorityFeePerGas` and `maxFeePerGas` field instead of `gasPrice`.\r\n    const isDynamicFeeTx = (isSendTx || isSignTx) && payload.params[0].type === TX_TYPE_STRING.TxTypeEthereumDynamicFee\r\n    const filledDynamicGasFeeTx =\r\n        isDynamicFeeTx && payload.params[0].maxPriorityFeePerGas !== undefined && payload.params[0].maxFeePerGas !== undefined\r\n\r\n    // gasPrice is already set so it is ok to send transaction.\r\n    if (!isGasPriceInputMissing || filledDynamicGasFeeTx) {\r\n        sendRequest(payload, method)\r\n        return defer.eventEmitter\r\n    }\r\n\r\n    // gasPrice is missing, have to fill gasPrice field before sending tx\r\n    const getGasPrice = new Method({\r\n        name: 'getGasPrice',\r\n        call: 'klay_gasPrice',\r\n        params: 0,\r\n    }).createFunction(method.requestManager)\r\n\r\n    const getMaxPriorityFeePerGas = new Method({\r\n        name: 'getMaxPriorityFeePerGas',\r\n        call: 'klay_maxPriorityFeePerGas',\r\n        params: 0,\r\n    }).createFunction(method.requestManager)\r\n\r\n    // `klay_gasPrice` returns a suggestion of gas price.\r\n    // So using this value in gasPrice field (or maxFeePerGas).\r\n    getGasPrice((err, gp) => {\r\n        // The TxTypeEthereumDynamicFee transaction does not use the gasPrice field,\r\n        // so the gas price default is not set for TxTypeEthereumDynamicFee.\r\n        if (!isDynamicFeeTx) {\r\n            payload.params[0].gasPrice = payload.params[0].gasPrice || gp\r\n        } else {\r\n            payload.params[0].maxFeePerGas = payload.params[0].maxFeePerGas || gp\r\n            // If maxPriorityFeePerGas is undefined, call `klay_maxPriorityFeePerGas`.\r\n            if (payload.params[0].maxPriorityFeePerGas === undefined) {\r\n                return getMaxPriorityFeePerGas((e, maxPriorityFeePerGas) => {\r\n                    payload.params[0].maxPriorityFeePerGas = maxPriorityFeePerGas\r\n                    // Format gas price parameters(gasPrice, maxPriorityFeePerGas, maxFeePerGas)\r\n                    formatGasParametersToHex(payload.params[0])\r\n                    sendRequest(payload, method)\r\n                })\r\n            }\r\n        }\r\n        // Format gas price parameters(gasPrice, maxPriorityFeePerGas, maxFeePerGas)\r\n        formatGasParametersToHex(payload.params[0])\r\n        sendRequest(payload, method)\r\n    })\r\n\r\n    /**\r\n     * attaching `.on('receipt')` is possible by returning defer.eventEmitter\r\n     */\r\n    return defer.eventEmitter\r\n}\r\n\r\n// A function to change the format to a hex string after randomly filling the default gasPrice value\r\n// with the API (personal_sendValueTransfer, personal_sendAccountUpdate) that does not use a transaction object.\r\nfunction formatGasParametersToHex(txObject) {\r\n    if (txObject.gasPrice !== undefined && !utils.isHexStrict(txObject.gasPrice)) {\r\n        txObject.gasPrice = utils.toHex(txObject.gasPrice)\r\n    }\r\n    if (txObject.maxPriorityFeePerGas !== undefined && !utils.isHexStrict(txObject.maxPriorityFeePerGas)) {\r\n        txObject.maxPriorityFeePerGas = utils.toHex(txObject.maxPriorityFeePerGas)\r\n    }\r\n    if (txObject.maxFeePerGas !== undefined && !utils.isHexStrict(txObject.maxFeePerGas)) {\r\n        txObject.maxFeePerGas = utils.toHex(txObject.maxFeePerGas)\r\n    }\r\n}\r\n\r\nfunction buildCall() {\r\n    const method = this\r\n    const isSendTx =\r\n        method.call === 'klay_sendTransaction' ||\r\n        method.call === 'klay_sendTransactionAsFeePayer' ||\r\n        method.call === 'klay_sendRawTransaction' ||\r\n        method.call === 'personal_sendTransaction' ||\r\n        method.call === 'personal_sendValueTransfer' ||\r\n        method.call === 'personal_sendAccountUpdate'\r\n\r\n    const send = buildSendFunc(method, isSendTx)\r\n    // necessary to attach things to the method\r\n    send.method = method\r\n    // necessary for batch requests\r\n    send.request = this.request.bind(this)\r\n    return send\r\n}\r\n\r\nfunction _confirmTransaction(defer, result, payload) {\r\n    let payloadTxObject = (payload.params && _.isObject(payload.params[0]) && payload.params[0]) || {}\r\n\r\n    // If payload.params[0] is RLP-encoded string, decode RLP-encoded string to Transaction instance.\r\n    if (_.isString(payload.params[0])) payloadTxObject = TransactionDecoder.decode(payload.params[0])\r\n\r\n    // mutableConfirmationPack will be used in\r\n    // 1) checkConfirmation,\r\n    // 2) startWatching functions\r\n    // It is * mutable *, both functions can affect properties mutably.\r\n    const mutableConfirmationPack = {\r\n        method: this,\r\n        promiseResolved: false,\r\n        canUnsubscribe: true,\r\n        timeoutCount: 0,\r\n        intervalId: null,\r\n        gasProvided: payloadTxObject.gas || null,\r\n        isContractDeployment: utils.isContractDeployment(payloadTxObject),\r\n        defer,\r\n        result,\r\n        _klaytnCall: {},\r\n    }\r\n\r\n    addCustomSendMethod(mutableConfirmationPack)\r\n\r\n    kickoffConfirmation(mutableConfirmationPack)\r\n}\r\n\r\nconst addCustomSendMethod = mutableConfirmationPack => {\r\n    const customSendMethods = [\r\n        new Method({\r\n            name: 'getTransactionReceipt',\r\n            call: 'klay_getTransactionReceipt',\r\n            params: 1,\r\n            outputFormatter: !mutableConfirmationPack.method.outputFormatterDisable\r\n                ? formatters.outputTransactionReceiptFormatter\r\n                : undefined,\r\n        }),\r\n        new Method({\r\n            name: 'getCode',\r\n            call: 'klay_getCode',\r\n            params: 2,\r\n            inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter],\r\n        }),\r\n        new Subscriptions({\r\n            name: 'subscribe',\r\n            type: 'klay',\r\n            subscriptions: {\r\n                newBlockHeaders: {\r\n                    subscriptionName: 'newHeads', // replace subscription with this name\r\n                    params: 0,\r\n                    outputFormatter: formatters.outputBlockFormatter,\r\n                },\r\n            },\r\n        }),\r\n    ]\r\n\r\n    // add custom send Methods\r\n    _.each(customSendMethods, mthd => {\r\n        // attach methods to _klaytnCall\r\n        mthd.attachToObject(mutableConfirmationPack._klaytnCall)\r\n        // assign rather than call setRequestManager()\r\n        mthd.requestManager = mutableConfirmationPack.method.requestManager\r\n    })\r\n}\r\n\r\nconst kickoffConfirmation = mutableConfirmationPack => {\r\n    // eslint-disable-next-line no-unused-vars\r\n    const { defer, promiseResolved, result, _klaytnCall } = mutableConfirmationPack\r\n    // first check if we already have a confirmed transaction\r\n\r\n    _klaytnCall\r\n        .getTransactionReceipt(result)\r\n        .then(receipt => {\r\n            if (receipt && receipt.blockHash) {\r\n                // `isPolling` is false in default.\r\n                checkConfirmation(mutableConfirmationPack, receipt, false)\r\n            } else if (!promiseResolved) startWatching(mutableConfirmationPack, receipt)\r\n        })\r\n        .catch(() => {\r\n            if (!promiseResolved) startWatching(mutableConfirmationPack)\r\n        })\r\n}\r\n\r\n// start watching for confirmation depending on the support features of the provider\r\nconst startWatching = function(mutableConfirmationPack, existingReceipt) {\r\n    // eslint-disable-next-line no-unused-vars\r\n    const { _klaytnCall, intervalId, method } = mutableConfirmationPack\r\n    // if provider allows PUB/SUB\r\n    if (method.requestManager.provider.supportsSubscriptions()) {\r\n        _klaytnCall.subscribe('newBlockHeaders', checkConfirmation.bind(null, mutableConfirmationPack, existingReceipt, false))\r\n    } else {\r\n        mutableConfirmationPack.intervalId = setInterval(checkConfirmation.bind(null, mutableConfirmationPack, existingReceipt, true), 1000)\r\n    }\r\n}\r\n\r\n// fire \"receipt\" and confirmation events and resolve after\r\n\r\nconst checkConfirmation = function(mutableConfirmationPack, existingReceipt, isPolling, err, blockHeader, sub) {\r\n    const {\r\n        // L1\r\n        intervalId, // eslint-disable-line no-unused-vars\r\n        defer,\r\n        method,\r\n        canUnsubscribe, // eslint-disable-line no-unused-vars\r\n        _klaytnCall,\r\n        // L2\r\n        isContractDeployment,\r\n        promiseResolved, // eslint-disable-line no-unused-vars\r\n        timeoutCount, // eslint-disable-line no-unused-vars\r\n        result,\r\n    } = mutableConfirmationPack\r\n\r\n    if (err) {\r\n        sub.unsubscribe()\r\n        mutableConfirmationPack.promiseResolved = true\r\n        utils._fireError(\r\n            {\r\n                message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\r\n                data: err,\r\n            },\r\n            defer.eventEmitter,\r\n            defer.reject\r\n        )\r\n        return\r\n    }\r\n\r\n    // create fake unsubscribe\r\n    sub = sub || {\r\n        unsubscribe: () => clearInterval(mutableConfirmationPack.intervalId),\r\n    }\r\n\r\n    // if we have a valid receipt we don't need to send a request\r\n    return (\r\n        ((existingReceipt && utils.promiEvent.resolve(existingReceipt)) || _klaytnCall.getTransactionReceipt(result))\r\n            // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\r\n            .then(receipt => {\r\n                checkIsReceiptInBlock(receipt)\r\n\r\n                const formattedReceipt = formatReceipt(receipt, method)\r\n\r\n                if (mutableConfirmationPack.promiseResolved) return\r\n\r\n                return isContractDeployment\r\n                    ? checkForContractDeployment(mutableConfirmationPack, formattedReceipt, sub)\r\n                    : checkForNormalTx(mutableConfirmationPack, formattedReceipt, sub)\r\n            })\r\n            .catch(countTimeout)\r\n    )\r\n}\r\n\r\nconst checkIsReceiptInBlock = receipt => {\r\n    if (receipt && !receipt.blockHash) throw errors.blockHashNull\r\n}\r\n\r\nconst formatReceipt = (receipt, method) => {\r\n    if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\r\n        receipt = method.extraFormatters.receiptFormatter(receipt)\r\n    }\r\n    return receipt\r\n}\r\n\r\nconst countTimeout = (mutableConfirmationPack, isPolling, sub) => {\r\n    // eslint-disable-next-line no-unused-vars\r\n    const { defer, timeoutCount, promiseResolved } = mutableConfirmationPack\r\n    // time out the transaction if not mined after 50 blocks\r\n    mutableConfirmationPack.timeoutCount++\r\n\r\n    // check to see if we are http polling\r\n    if (isPolling) {\r\n        // polling timeout is different than TIMEOUTBLOCK blocks since we are triggering every second\r\n        if (mutableConfirmationPack.timeoutCount - 1 >= POLLINGTIMEOUT) {\r\n            sub.unsubscribe()\r\n            mutableConfirmationPack.promiseResolved = true\r\n            utils._fireError(\r\n                new Error(\r\n                    `Transaction was not mined within${POLLINGTIMEOUT} seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!`\r\n                ),\r\n                defer.eventEmitter,\r\n                defer.reject\r\n            )\r\n        }\r\n    } else if (mutableConfirmationPack.timeoutCount - 1 >= TIMEOUTBLOCK) {\r\n        sub.unsubscribe()\r\n        mutableConfirmationPack.promiseResolved = true\r\n        utils._fireError(\r\n            new Error(\r\n                'Transaction was not mined within 50 blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'\r\n            ),\r\n            defer.eventEmitter,\r\n            defer.reject\r\n        )\r\n    }\r\n}\r\n\r\nconst checkForContractDeployment = (mutableConfirmationPack, receipt, sub) => {\r\n    // eslint-disable-next-line no-unused-vars\r\n    const { defer, method, canUnsubscribe, _klaytnCall, promiseResolved } = mutableConfirmationPack\r\n\r\n    // If contract address doesn't exist, fire error.\r\n    if (!receipt.contractAddress) {\r\n        if (canUnsubscribe) {\r\n            sub.unsubscribe()\r\n            mutableConfirmationPack.promiseResolved = true\r\n        }\r\n\r\n        utils._fireError(errors.receiptDidntContainContractAddress, defer.eventEmitter, defer.reject)\r\n        return\r\n    }\r\n\r\n    if (!receipt.status && receipt.txError) {\r\n        const receiptJSON = JSON.stringify(receipt, null, 2)\r\n        utils._fireError(new Error(`${errors.txErrorTable[receipt.txError]}\\n ${receiptJSON}`), defer.eventEmitter, defer.reject)\r\n    }\r\n\r\n    _klaytnCall.getCode(receipt.contractAddress, (e, code) => {\r\n        if (!code) return\r\n\r\n        defer.eventEmitter.emit('receipt', receipt)\r\n\r\n        // if contract, return instance instead of receipt\r\n        defer.resolve(\r\n            (method.extraFormatters &&\r\n                method.extraFormatters.contractDeployFormatter &&\r\n                method.extraFormatters.contractDeployFormatter(receipt)) ||\r\n                receipt\r\n        )\r\n\r\n        // need to remove listeners, as they aren't removed automatically when succesfull\r\n        if (canUnsubscribe) defer.eventEmitter.removeAllListeners()\r\n\r\n        if (canUnsubscribe) sub.unsubscribe()\r\n        mutableConfirmationPack.promiseResolved = true\r\n    })\r\n\r\n    return receipt\r\n}\r\n\r\nconst checkForNormalTx = (mutableConfirmationPack, receipt, sub) => {\r\n    // eslint-disable-next-line no-unused-vars\r\n    const { defer, canUnsubscribe, promiseResolved, gasProvided } = mutableConfirmationPack\r\n\r\n    if (\r\n        receipt &&\r\n        !receipt.outOfGas &&\r\n        (!gasProvided || gasProvided !== receipt.gasUsed) &&\r\n        (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')\r\n    ) {\r\n        // Happy case: transaction is processed well. A.K.A 'well-done receipt'.\r\n        try {\r\n            mutableConfirmationPack.defer.eventEmitter.emit('receipt', receipt)\r\n            mutableConfirmationPack.defer.resolve(receipt)\r\n        } catch (e) {\r\n            console.log('receipt error', e)\r\n        }\r\n\r\n        // need to remove listeners, as they aren't removed automatically when succesfull\r\n        if (canUnsubscribe) {\r\n            mutableConfirmationPack.defer.eventEmitter.removeAllListeners()\r\n        }\r\n    } else {\r\n        // Unhappy case: trasaction has error. A.K.A 'bad receipt'.\r\n        if (!receipt) return\r\n        const receiptJSON = JSON.stringify(receipt, null, 2)\r\n\r\n        const { txError } = receipt\r\n        if (txError && errors.txErrorTable[txError]) {\r\n            utils._fireError(\r\n                new Error(`${errors.txErrorTable[txError]}\\n ${receiptJSON}`),\r\n                mutableConfirmationPack.defer.eventEmitter,\r\n                mutableConfirmationPack.defer.reject\r\n            )\r\n        } else if (receipt.status === false || receipt.status === '0x0') {\r\n            utils._fireError(\r\n                errors.transactionReverted(receiptJSON),\r\n                mutableConfirmationPack.defer.eventEmitter,\r\n                mutableConfirmationPack.defer.reject\r\n            )\r\n        } else if (receipt.gasUsed >= gasProvided) {\r\n            utils._fireError(\r\n                errors.transactionRanOutOfGas(receiptJSON),\r\n                mutableConfirmationPack.defer.eventEmitter,\r\n                mutableConfirmationPack.defer.reject\r\n            )\r\n        } else {\r\n            utils._fireError(\r\n                errors.transactionRanOutOfGas(receiptJSON),\r\n                mutableConfirmationPack.defer.eventEmitter,\r\n                mutableConfirmationPack.defer.reject\r\n            )\r\n        }\r\n    }\r\n\r\n    if (canUnsubscribe) sub.unsubscribe()\r\n    mutableConfirmationPack.promiseResolved = true\r\n}\r\n\r\n/**\r\n * Should be called to create the pure JSONRPC request which can be used in a batch request\r\n *\r\n * @method request\r\n * @return {Object} jsonrpc request\r\n */\r\nfunction request(...args) {\r\n    const payload = this.toPayload(args)\r\n    payload.format = this.formatOutput.bind(this)\r\n    return payload\r\n}\r\n\r\nmodule.exports = Method\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}